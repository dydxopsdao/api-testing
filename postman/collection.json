{
	"info": {
		"_postman_id": "981cef60-dcd2-4b5e-aefb-c7d1dd2e08dc",
		"name": "dYdX",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "41849022",
		"_collection_link": "https://dydx-ops-services.postman.co/workspace/dYdX~fdeed7e0-d6ed-46c3-926d-fdf269d648ad/collection/41849022-981cef60-dcd2-4b5e-aefb-c7d1dd2e08dc?action=share&source=collection_link&creator=41849022"
	},
	"item": [
		{
			"name": "Indexer",
			"item": [
				{
					"name": "addresses",
					"item": [
						{
							"name": "address",
							"item": [
								{
									"name": "/addresses/{address} valid Address",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify response status code",
													"pm.test(\"Response status code is 200\", function () {",
													"    pm.response.to.have.status(200);",
													"});",
													"",
													"// 2. Check response time (threshold set to 500ms)",
													"pm.test(\"Response time is less than 6000ms\", function () {",
													"    pm.expect(pm.response.responseTime).to.be.below(6000);",
													"});",
													"",
													"// 3. Validate top-level structure",
													"pm.test(\"Response has 'subaccounts' array and 'totalTradingRewards'\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData).to.be.an('object');",
													"",
													"    // Ensure the expected properties exist",
													"    pm.expect(jsonData).to.have.property('subaccounts').that.is.an('array');",
													"    pm.expect(jsonData).to.have.property('totalTradingRewards').that.is.a('string');",
													"",
													"    // Ensure totalTradingRewards is a valid number (even if it's 0)",
													"    const totalTradingRewards = parseFloat(jsonData.totalTradingRewards);",
													"    pm.expect(totalTradingRewards).to.be.a('number');",
													"    pm.expect(totalTradingRewards).to.be.at.least(0);",
													"});",
													"",
													"// 4. Validate the schema of each subaccount dynamically",
													"pm.test(\"Validate schema for each subaccount\", function () {",
													"    const responseData = pm.response.json();",
													"    const subaccounts = responseData.subaccounts;",
													"",
													"    pm.expect(subaccounts).to.be.an('array');",
													"",
													"    subaccounts.forEach((subaccount) => {",
													"        // Basic property checks",
													"        pm.expect(subaccount).to.have.property('address').that.is.a('string');",
													"        pm.expect(subaccount).to.have.property('subaccountNumber').that.is.a('number');",
													"        pm.expect(subaccount).to.have.property('equity').that.is.a('string');",
													"        pm.expect(subaccount).to.have.property('freeCollateral').that.is.a('string');",
													"        pm.expect(subaccount).to.have.property('marginEnabled').that.is.a('boolean');",
													"        pm.expect(subaccount).to.have.property('updatedAtHeight').that.is.a('string');",
													"        pm.expect(subaccount).to.have.property('latestProcessedBlockHeight').that.is.a('string');",
													"        pm.expect(subaccount).to.have.property('openPerpetualPositions').that.is.an('object');",
													"        pm.expect(subaccount).to.have.property('assetPositions').that.is.an('object');",
													"",
													"        // Ensure numerical values are valid",
													"        pm.expect(parseFloat(subaccount.equity)).to.not.be.NaN;",
													"        pm.expect(parseFloat(subaccount.freeCollateral)).to.not.be.NaN;",
													"        pm.expect(parseInt(subaccount.updatedAtHeight)).to.not.be.NaN;",
													"        pm.expect(parseInt(subaccount.latestProcessedBlockHeight)).to.not.be.NaN;",
													"",
													"        // Validate assetPositions structure if not empty",
													"        if (Object.keys(subaccount.assetPositions).length > 0) {",
													"            Object.values(subaccount.assetPositions).forEach(asset => {",
													"                pm.expect(asset).to.have.property('size').that.is.a('string');",
													"                pm.expect(asset).to.have.property('symbol').that.is.a('string');",
													"                pm.expect(asset).to.have.property('side').that.is.a('string');",
													"                pm.expect(asset).to.have.property('assetId');",
													"                pm.expect(asset).to.have.property('subaccountNumber').that.is.a('number');",
													"",
													"                // Ensure size is a valid number",
													"                pm.expect(parseFloat(asset.size)).to.not.be.NaN;",
													"            });",
													"        }",
													"    });",
													"});",
													"",
													"// 5. Ensure no unexpected properties exist in subaccounts (schema integrity check)",
													"pm.test(\"No unexpected properties in subaccount schema\", function () {",
													"    const responseData = pm.response.json();",
													"    const subaccounts = responseData.subaccounts;",
													"",
													"    const expectedKeys = [",
													"        \"address\",",
													"        \"subaccountNumber\",",
													"        \"equity\",",
													"        \"freeCollateral\",",
													"        \"openPerpetualPositions\",",
													"        \"assetPositions\",",
													"        \"marginEnabled\",",
													"        \"updatedAtHeight\",",
													"        \"latestProcessedBlockHeight\"",
													"    ];",
													"",
													"    subaccounts.forEach((subaccount) => {",
													"        const keys = Object.keys(subaccount);",
													"        keys.forEach(key => {",
													"            pm.expect(expectedKeys).to.include(key, `Unexpected property found: ${key}`);",
													"        });",
													"    });",
													"});",
													"",
													"// 6. Ensure each subaccount address is a valid dydx address format (basic check)",
													"pm.test(\"All subaccounts have a valid dydx address format\", function () {",
													"    const subaccounts = pm.response.json().subaccounts;",
													"    const dydxAddressPattern = /^dydx1[a-z0-9]{38}$/; // Rough regex for dydx address",
													"",
													"    subaccounts.forEach((subaccount) => {",
													"        pm.expect(subaccount.address).to.match(dydxAddressPattern, \"Invalid dydx address format\");",
													"    });",
													"});",
													"",
													"const schema = {",
													"    \"type\": \"object\",",
													"    \"properties\": {",
													"        \"subaccounts\": {",
													"            \"type\": \"array\",",
													"            \"items\": {",
													"                \"type\": \"object\",",
													"                \"properties\": {",
													"                    \"address\": { \"type\": \"string\" },",
													"                    \"subaccountNumber\": { \"type\": \"number\" },",
													"                    \"equity\": { \"type\": \"string\" },",
													"                    \"freeCollateral\": { \"type\": \"string\" },",
													"                    \"marginEnabled\": { \"type\": \"boolean\" },",
													"                    \"updatedAtHeight\": { \"type\": \"string\" },",
													"                    \"latestProcessedBlockHeight\": { \"type\": \"string\" },",
													"                    \"openPerpetualPositions\": { \"type\": \"object\" },",
													"                    \"assetPositions\": { \"type\": \"object\" }",
													"                },",
													"                \"required\": [\"address\", \"subaccountNumber\", \"equity\", \"freeCollateral\", \"marginEnabled\", \"updatedAtHeight\", \"latestProcessedBlockHeight\", \"openPerpetualPositions\", \"assetPositions\"]",
													"            }",
													"        },",
													"        \"totalTradingRewards\": { \"type\": \"string\" }",
													"    },",
													"    \"required\": [\"subaccounts\", \"totalTradingRewards\"]",
													"};",
													"",
													"pm.test(\"Response matches expected schema\", function () {",
													"    pm.response.to.have.jsonSchema(schema);",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/addresses/{{validdYdXAddress}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"addresses",
												"{{validdYdXAddress}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "/addresses/{address} invalid Address",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify response status code (should be 400 or 404)",
													"pm.test(\"Response status code is 400 or 404 for invalid address\", function () {",
													"    pm.expect(pm.response.code).to.be.oneOf([400, 404]);",
													"});",
													"",
													"// 2. Validate the presence and structure of the 'errors' array",
													"pm.test(\"Response contains 'errors' array\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData).to.have.property(\"errors\").that.is.an(\"array\").with.lengthOf.at.least(1);",
													"});",
													"",
													"// 3. Validate the structure of each error object",
													"pm.test(\"Each error object contains 'msg' property\", function () {",
													"    const jsonData = pm.response.json();",
													"",
													"    jsonData.errors.forEach(error => {",
													"        pm.expect(error).to.have.property(\"msg\").that.is.a(\"string\");",
													"    });",
													"});",
													"",
													"// 4. Validate the specific error message format",
													"pm.test(\"Error message is correct for invalid address\", function () {",
													"    const jsonData = pm.response.json();",
													"    const errorMsg = jsonData.errors[0].msg;",
													"",
													"    pm.expect(errorMsg).to.match(/^No subaccounts found for address /);",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/addresses/{{invaliddYdXAddress}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"addresses",
												"{{invaliddYdXAddress}}"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "subaccountNumber",
							"item": [
								{
									"name": "/addresses/{address}/subaccountNumber Invalid",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify response status code is 400",
													"pm.test(\"Response status code is 400 for invalid subaccountNumber\", function () {",
													"    pm.response.to.have.status(400);",
													"});",
													"",
													"// 2. Validate presence of 'errors' array",
													"pm.test(\"Response contains 'errors' array\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData).to.have.property(\"errors\").that.is.an(\"array\").with.lengthOf.at.least(1);",
													"});",
													"",
													"// 3. Validate structure of error object",
													"pm.test(\"Each error object contains 'msg', 'value', 'param', and 'location'\", function () {",
													"    const jsonData = pm.response.json();",
													"",
													"    jsonData.errors.forEach(error => {",
													"        pm.expect(error).to.have.property(\"msg\").that.is.a(\"string\");",
													"        pm.expect(error).to.have.property(\"value\").that.is.a(\"string\");",
													"        pm.expect(error).to.have.property(\"param\").that.is.a(\"string\");",
													"        pm.expect(error).to.have.property(\"location\").that.is.a(\"string\");",
													"    });",
													"});",
													"",
													"// 4. Validate error message for incorrect subaccountNumber",
													"pm.test(\"Error message is correct for invalid subaccountNumber\", function () {",
													"    const jsonData = pm.response.json();",
													"    const errorMsg = jsonData.errors[0].msg;",
													"",
													"    pm.expect(errorMsg).to.eql(\"subaccountNumber must be a non-negative integer less than 128001\");",
													"});",
													"",
													"// 5. Validate 'param' is correctly identifying subaccountNumber",
													"pm.test(\"Error response correctly identifies 'subaccountNumber' as the invalid parameter\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData.errors[0].param).to.eql(\"subaccountNumber\");",
													"});",
													"",
													"// 6. Validate 'location' is in 'params'",
													"pm.test(\"'location' is correctly specified as 'params'\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData.errors[0].location).to.eql(\"params\");",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/addresses/{{validdYdXAddress}}/subaccountNumber/{{invaliddYdXAddressSubAccountNumber}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"addresses",
												"{{validdYdXAddress}}",
												"subaccountNumber",
												"{{invaliddYdXAddressSubAccountNumber}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "/addresses/{address}/subaccountNumber Valid",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify response status code is 200",
													"pm.test(\"Response status code is 200\", function () {",
													"    pm.response.to.have.status(200);",
													"});",
													"",
													"// 2. Validate top-level response structure",
													"pm.test(\"Response contains 'subaccount' object\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData).to.be.an(\"object\");",
													"    pm.expect(jsonData).to.have.property(\"subaccount\").that.is.an(\"object\");",
													"});",
													"",
													"// 3. Validate the schema of the 'subaccount' object",
													"pm.test(\"Subaccount object contains required properties\", function () {",
													"    const subaccount = pm.response.json().subaccount;",
													"",
													"    pm.expect(subaccount).to.have.property(\"address\").that.is.a(\"string\");",
													"    pm.expect(subaccount).to.have.property(\"subaccountNumber\").that.is.a(\"number\");",
													"    pm.expect(subaccount).to.have.property(\"equity\").that.is.a(\"string\");",
													"    pm.expect(subaccount).to.have.property(\"freeCollateral\").that.is.a(\"string\");",
													"    pm.expect(subaccount).to.have.property(\"marginEnabled\").that.is.a(\"boolean\");",
													"    pm.expect(subaccount).to.have.property(\"updatedAtHeight\").that.is.a(\"string\");",
													"    pm.expect(subaccount).to.have.property(\"latestProcessedBlockHeight\").that.is.a(\"string\");",
													"    pm.expect(subaccount).to.have.property(\"openPerpetualPositions\").that.is.an(\"object\");",
													"    pm.expect(subaccount).to.have.property(\"assetPositions\").that.is.an(\"object\");",
													"});",
													"",
													"// 4. Validate numeric values",
													"pm.test(\"Equity and FreeCollateral should be valid numeric strings\", function () {",
													"    console.log(\"Environment Variables:\");",
													"console.log(\"validdYdXAddress:\", pm.environment.get(\"validdYdXAddress\"));",
													"console.log(\"validdYdXAddressSubAccountNumber:\", pm.environment.get(\"validdYdXAddressSubAccountNumber\"));",
													"    const subaccount = pm.response.json().subaccount;",
													"",
													"    pm.expect(parseFloat(subaccount.equity)).to.not.be.NaN;",
													"    pm.expect(parseFloat(subaccount.freeCollateral)).to.not.be.NaN;",
													"    pm.expect(parseInt(subaccount.updatedAtHeight)).to.not.be.NaN;",
													"    pm.expect(parseInt(subaccount.latestProcessedBlockHeight)).to.not.be.NaN;",
													"});",
													"",
													"// 5. Validate assetPositions if present",
													"pm.test(\"Validate assetPositions structure (if not empty)\", function () {",
													"    const subaccount = pm.response.json().subaccount;",
													"    if (Object.keys(subaccount.assetPositions).length > 0) {",
													"        Object.values(subaccount.assetPositions).forEach(asset => {",
													"            pm.expect(asset).to.have.property(\"size\").that.is.a(\"string\");",
													"            pm.expect(asset).to.have.property(\"symbol\").that.is.a(\"string\");",
													"            pm.expect(asset).to.have.property(\"side\").that.is.a(\"string\");",
													"            pm.expect(asset).to.have.property(\"assetId\");",
													"            pm.expect(asset).to.have.property(\"subaccountNumber\").that.equals(subaccount.subaccountNumber);",
													"",
													"            // Validate size is a numeric string",
													"            pm.expect(parseFloat(asset.size)).to.not.be.NaN;",
													"        });",
													"    }",
													"});",
													"",
													"// 6. Verify the address and subaccountNumber match the request",
													"pm.test(\"Address and subaccountNumber match requested values\", function () {",
													"    const subaccount = pm.response.json().subaccount;",
													"    const expectedAddress = pm.environment.get(\"validdYdXAddress\"); ",
													"    const expectedSubaccountNumber = parseInt(pm.environment.get(\"validdYdXAddressSubAccountNumber\"), 10);",
													"",
													"    pm.expect(subaccount.address).to.eql(expectedAddress);",
													"    pm.expect(subaccount.subaccountNumber).to.eql(expectedSubaccountNumber);",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/addresses/{{validdYdXAddress}}/subaccountNumber/{{validdYdXAddressSubAccountNumber}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"addresses",
												"{{validdYdXAddress}}",
												"subaccountNumber",
												"{{validdYdXAddressSubAccountNumber}}"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "registerToken",
							"item": [
								{
									"name": "/addresses/{address}/registerToken valid",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\n  \"language\": \"string\",\n  \"token\": \"string\"\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{indexerBaseUrl}}addresses/{{validdYdXAddress}}/registerToken",
											"host": [
												"{{indexerBaseUrl}}addresses"
											],
											"path": [
												"{{validdYdXAddress}}",
												"registerToken"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "testNotification",
							"item": [
								{
									"name": "/addresses/{address}/testNotification",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}addresses/{{validdYdXAddress}}/testNotification",
											"host": [
												"{{indexerBaseUrl}}addresses"
											],
											"path": [
												"{{validdYdXAddress}}",
												"testNotification"
											]
										}
									},
									"response": []
								}
							]
						}
					]
				},
				{
					"name": "affiliates",
					"item": [
						{
							"name": "metadata",
							"item": [
								{
									"name": "/affiliates/metadata valid address",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify response status code is 200",
													"pm.test(\"Response status code is 200\", function () {",
													"    pm.response.to.have.status(200);",
													"});",
													"",
													"// 2. Validate top-level response structure",
													"pm.test(\"Response contains referral metadata properties\", function () {",
													"    const jsonData = pm.response.json();",
													"",
													"    pm.expect(jsonData).to.be.an(\"object\");",
													"    pm.expect(jsonData).to.have.property(\"referralCode\").that.is.a(\"string\");",
													"    pm.expect(jsonData).to.have.property(\"isVolumeEligible\").that.is.a(\"boolean\");",
													"    pm.expect(jsonData).to.have.property(\"isAffiliate\").that.is.a(\"boolean\");",
													"});",
													"",
													"// 3. Ensure referralCode is a non-empty string",
													"pm.test(\"Referral code should be a valid non-empty string\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData.referralCode).to.be.a(\"string\").and.not.be.empty;",
													"});",
													"",
													"// 4. Validate `isVolumeEligible` and `isAffiliate` are boolean values",
													"pm.test(\"Boolean fields should be valid\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData.isVolumeEligible).to.be.a(\"boolean\");",
													"    pm.expect(jsonData.isAffiliate).to.be.a(\"boolean\");",
													"});",
													"",
													"if (pm.response.code === 200) {",
													"    const jsonData = pm.response.json();",
													"",
													"    // Ensure referralCode exists and is a valid string",
													"    if (jsonData.referralCode && typeof jsonData.referralCode === \"string\" && jsonData.referralCode.length > 0) {",
													"        pm.environment.set(\"referralCode\", jsonData.referralCode);",
													"        console.log(\"Saved referralCode:\", jsonData.referralCode);",
													"    } else {",
													"        console.log(\"Referral code is missing or invalid\");",
													"    }",
													"}"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/affiliates/metadata?address={{dydxWithReferrals}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"affiliates",
												"metadata"
											],
											"query": [
												{
													"key": "address",
													"value": "{{dydxWithReferrals}}"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "/affiliates/metadata invalid address",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify response status code is 400 or 404",
													"pm.test(\"Response status code is 400 or 404 for invalid address\", function () {",
													"    pm.response.to.have.status(404)",
													"});",
													"",
													"// 2. Validate presence of 'errors' array",
													"pm.test(\"Response contains 'errors' array\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData).to.have.property(\"errors\").that.is.an(\"array\").with.lengthOf.at.least(1);",
													"});",
													"",
													"// 3. Validate the structure of the error message",
													"pm.test(\"Each error object contains 'msg' property\", function () {",
													"    const jsonData = pm.response.json();",
													"",
													"    jsonData.errors.forEach(error => {",
													"        pm.expect(error).to.have.property(\"msg\").that.is.a(\"string\");",
													"    });",
													"});",
													"",
													"// 4. Ensure error message format is correct",
													"pm.test(\"Error message correctly indicates wallet not found\", function () {",
													"    const jsonData = pm.response.json();",
													"    const errorMsg = jsonData.errors[0].msg;",
													"",
													"    pm.expect(errorMsg).to.match(/^Wallet with address /);",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/affiliates/metadata?address={{invaliddYdXAddress}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"affiliates",
												"metadata"
											],
											"query": [
												{
													"key": "address",
													"value": "{{invaliddYdXAddress}}"
												}
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "address",
							"item": [
								{
									"name": "/affiliates/address valid referralCode",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify response status code is 200",
													"pm.test(\"Response status code is 200\", function () {",
													"    pm.response.to.have.status(200);",
													"});",
													"",
													"// 2. Validate response contains 'address' property",
													"pm.test(\"Response contains valid address\", function () {",
													"    const jsonData = pm.response.json();",
													"    ",
													"    pm.expect(jsonData).to.be.an(\"object\");",
													"    pm.expect(jsonData).to.have.property(\"address\").that.is.a(\"string\").and.not.be.empty;",
													"});",
													"",
													"// 3. Validate address format (basic dydx address structure check)",
													"pm.test(\"Address should be a valid dydx address format\", function () {",
													"    const jsonData = pm.response.json();",
													"    const dydxAddressPattern = /^dydx1[a-z0-9]{38}$/; // Basic regex for dydx address",
													"    ",
													"    pm.expect(jsonData.address).to.match(dydxAddressPattern, \"Invalid dydx address format\");",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/affiliates/address?referralCode={{referralCode}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"affiliates",
												"address"
											],
											"query": [
												{
													"key": "referralCode",
													"value": "{{referralCode}}"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "/affiliates/address invalid referralCode",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify response status code is 400 or 404",
													"pm.test(\"Response status code is 400 or 404 for invalid referral code\", function () {",
													"    pm.response.to.have.status(404)",
													"});",
													"",
													"// 2. Validate presence of 'errors' array",
													"pm.test(\"Response contains 'errors' array\", function () {",
													"    const jsonData = pm.response.json();",
													"    ",
													"    pm.expect(jsonData).to.have.property(\"errors\").that.is.an(\"array\").with.lengthOf.at.least(1);",
													"});",
													"",
													"// 3. Validate structure of error object",
													"pm.test(\"Each error object contains 'msg' property\", function () {",
													"    const jsonData = pm.response.json();",
													"    ",
													"    jsonData.errors.forEach(error => {",
													"        pm.expect(error).to.have.property(\"msg\").that.is.a(\"string\");",
													"    });",
													"});",
													"",
													"// 4. Ensure correct error message format",
													"pm.test(\"Error message correctly indicates referral code does not exist\", function () {",
													"    const jsonData = pm.response.json();",
													"    const expectedErrorMessage = `Referral code ${pm.environment.get(\"invalidReferralCode\")} does not exist`;",
													"",
													"    pm.expect(jsonData.errors[0].msg).to.eql(expectedErrorMessage);",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/affiliates/address?referralCode={{invalidReferralCode}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"affiliates",
												"address"
											],
											"query": [
												{
													"key": "referralCode",
													"value": "{{invalidReferralCode}}"
												}
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "snapshot",
							"item": [
								{
									"name": "/affiliates/snapshot valid",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify response status code is 200",
													"pm.test(\"Response status code is 200\", function () {",
													"    pm.response.to.have.status(200);",
													"});",
													"",
													"// 2. Validate response structure",
													"pm.test(\"Response contains 'affiliateList', 'currentOffset', and 'total'\", function () {",
													"    const jsonData = pm.response.json();",
													"",
													"    pm.expect(jsonData).to.be.an(\"object\");",
													"    pm.expect(jsonData).to.have.property(\"affiliateList\").that.is.an(\"array\");",
													"    pm.expect(jsonData).to.have.property(\"currentOffset\").that.is.a(\"number\");",
													"    pm.expect(jsonData).to.have.property(\"total\").that.is.a(\"number\");",
													"});",
													"",
													"// 3. Validate 'affiliateList' contains correct fields",
													"pm.test(\"Each affiliate object contains expected properties\", function () {",
													"    const jsonData = pm.response.json();",
													"    jsonData.affiliateList.forEach(affiliate => {",
													"        pm.expect(affiliate).to.have.property(\"affiliateAddress\").that.is.a(\"string\").and.not.be.empty;",
													"        pm.expect(affiliate).to.have.property(\"affiliateReferralCode\").that.is.a(\"string\").and.not.be.empty;",
													"        pm.expect(affiliate).to.have.property(\"affiliateEarnings\").that.is.a(\"number\");",
													"        pm.expect(affiliate).to.have.property(\"affiliateReferredTrades\").that.is.a(\"number\");",
													"        pm.expect(affiliate).to.have.property(\"affiliateTotalReferredFees\").that.is.a(\"number\");",
													"        pm.expect(affiliate).to.have.property(\"affiliateReferredUsers\").that.is.a(\"number\");",
													"        pm.expect(affiliate).to.have.property(\"affiliateReferredNetProtocolEarnings\").that.is.a(\"number\");",
													"        pm.expect(affiliate).to.have.property(\"affiliateReferredTotalVolume\").that.is.a(\"number\");",
													"        pm.expect(affiliate).to.have.property(\"affiliateReferredMakerFees\").that.is.a(\"number\");",
													"        pm.expect(affiliate).to.have.property(\"affiliateReferredTakerFees\").that.is.a(\"number\");",
													"        pm.expect(affiliate).to.have.property(\"affiliateReferredMakerRebates\").that.is.a(\"number\");",
													"    });",
													"});",
													"",
													"// 4. Validate address format for 'affiliateAddress'",
													"pm.test(\"Affiliate addresses should follow dydx address format\", function () {",
													"    const dydxAddressPattern = /^dydx1[a-z0-9]{38}$/;",
													"    const jsonData = pm.response.json();",
													"    jsonData.affiliateList.forEach(affiliate => {",
													"        pm.expect(affiliate.affiliateAddress).to.match(dydxAddressPattern, \"Invalid dydx address format\");",
													"    });",
													"});",
													"",
													"// 5. Validate numeric values are non-negative where applicable",
													"pm.test(\"Numeric fields should be valid and non-negative where applicable\", function () {",
													"    const jsonData = pm.response.json();",
													"    jsonData.affiliateList.forEach(affiliate => {",
													"        pm.expect(affiliate.affiliateEarnings).to.be.at.least(0);",
													"        pm.expect(affiliate.affiliateReferredTrades).to.be.at.least(0);",
													"        pm.expect(affiliate.affiliateTotalReferredFees).to.be.at.least(0);",
													"        pm.expect(affiliate.affiliateReferredUsers).to.be.at.least(0);",
													"        pm.expect(affiliate.affiliateReferredNetProtocolEarnings).to.be.at.least(0);",
													"        pm.expect(affiliate.affiliateReferredTotalVolume).to.be.at.least(0);",
													"        pm.expect(affiliate.affiliateReferredMakerFees).to.be.at.least(0);",
													"        pm.expect(affiliate.affiliateReferredTakerFees).to.be.at.least(0);",
													"        // 'affiliateReferredMakerRebates' can be negative, so it's not checked here",
													"    });",
													"});",
													"",
													"// 6. Validate pagination fields",
													"pm.test(\"Pagination fields should be correct\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData.currentOffset).to.be.a(\"number\").and.to.be.at.least(0);",
													"    pm.expect(jsonData.total).to.be.a(\"number\").and.to.be.at.least(0);",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/affiliates/snapshot?addressFilter={{dydxWithReferrals}}&offset=0&limit=10",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"affiliates",
												"snapshot"
											],
											"query": [
												{
													"key": "addressFilter",
													"value": "{{dydxWithReferrals}}"
												},
												{
													"key": "offset",
													"value": "0"
												},
												{
													"key": "limit",
													"value": "10"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "/affiliates/snapshot pagination limit 1",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify response status code is 200",
													"pm.test(\"Response status code is 200\", function () {",
													"    pm.response.to.have.status(200);",
													"});",
													"",
													"// 2. Validate response contains required fields",
													"pm.test(\"Response contains 'affiliateList', 'currentOffset', and 'total'\", function () {",
													"    const jsonData = pm.response.json();",
													"    ",
													"    pm.expect(jsonData).to.be.an(\"object\");",
													"    pm.expect(jsonData).to.have.property(\"affiliateList\").that.is.an(\"array\");",
													"    pm.expect(jsonData).to.have.property(\"currentOffset\").that.is.a(\"number\");",
													"    pm.expect(jsonData).to.have.property(\"total\").that.is.a(\"number\");",
													"});",
													"",
													"// 3. Ensure only one affiliate object is returned",
													"pm.test(\"Affiliate list should contain exactly 1 entry\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData.affiliateList.length).to.eql(1, \"Expected exactly 1 affiliate object\");",
													"});",
													"",
													"// 4. Validate affiliate object contains expected fields",
													"pm.test(\"Affiliate object contains required properties\", function () {",
													"    const jsonData = pm.response.json();",
													"    const affiliate = jsonData.affiliateList[0];",
													"",
													"    pm.expect(affiliate).to.have.property(\"affiliateAddress\").that.is.a(\"string\").and.not.be.empty;",
													"    pm.expect(affiliate).to.have.property(\"affiliateReferralCode\").that.is.a(\"string\").and.not.be.empty;",
													"    pm.expect(affiliate).to.have.property(\"affiliateEarnings\").that.is.a(\"number\");",
													"    pm.expect(affiliate).to.have.property(\"affiliateReferredTrades\").that.is.a(\"number\");",
													"    pm.expect(affiliate).to.have.property(\"affiliateTotalReferredFees\").that.is.a(\"number\");",
													"    pm.expect(affiliate).to.have.property(\"affiliateReferredUsers\").that.is.a(\"number\");",
													"    pm.expect(affiliate).to.have.property(\"affiliateReferredNetProtocolEarnings\").that.is.a(\"number\");",
													"    pm.expect(affiliate).to.have.property(\"affiliateReferredTotalVolume\").that.is.a(\"number\");",
													"    pm.expect(affiliate).to.have.property(\"affiliateReferredMakerFees\").that.is.a(\"number\");",
													"    pm.expect(affiliate).to.have.property(\"affiliateReferredTakerFees\").that.is.a(\"number\");",
													"    pm.expect(affiliate).to.have.property(\"affiliateReferredMakerRebates\").that.is.a(\"number\");",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/affiliates/snapshot?addressFilter[]={{dydxWithReferrals}}&addressFilter[]={{dydxWithReferrals2}}&offset=0&limit=1",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"affiliates",
												"snapshot"
											],
											"query": [
												{
													"key": "addressFilter[]",
													"value": "{{dydxWithReferrals}}"
												},
												{
													"key": "addressFilter[]",
													"value": "{{dydxWithReferrals2}}"
												},
												{
													"key": "offset",
													"value": "0"
												},
												{
													"key": "limit",
													"value": "1"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "/affiliates/snapshot pagination limit 0",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify response status code is 400 (Bad Request)",
													"pm.test(\"Response status code is 400 for invalid limit\", function () {",
													"    pm.response.to.have.status(400);",
													"});",
													"",
													"// 2. Validate response contains 'errors' array",
													"pm.test(\"Response contains 'errors' array\", function () {",
													"    const jsonData = pm.response.json();",
													"    ",
													"    pm.expect(jsonData).to.have.property(\"errors\").that.is.an(\"array\").with.lengthOf.at.least(1);",
													"});",
													"",
													"// 3. Validate error object structure",
													"pm.test(\"Each error object contains required properties\", function () {",
													"    const jsonData = pm.response.json();",
													"",
													"    jsonData.errors.forEach(error => {",
													"        pm.expect(error).to.have.property(\"value\").that.is.a(\"string\");",
													"        pm.expect(error).to.have.property(\"msg\").that.is.a(\"string\");",
													"        pm.expect(error).to.have.property(\"param\").that.is.a(\"string\");",
													"        pm.expect(error).to.have.property(\"location\").that.is.a(\"string\");",
													"    });",
													"});",
													"",
													"// 4. Validate the specific error message for 'limit=0'",
													"pm.test(\"Error message correctly indicates 'limit' must be a valid integer\", function () {",
													"    const jsonData = pm.response.json();",
													"    const expectedError = {",
													"        value: \"0\",",
													"        msg: \"limit must be a valid integer\",",
													"        param: \"limit\",",
													"        location: \"query\"",
													"    };",
													"",
													"    // Check if at least one error object matches expected structure",
													"    const matchingError = jsonData.errors.find(error =>",
													"        error.value === expectedError.value &&",
													"        error.msg === expectedError.msg &&",
													"        error.param === expectedError.param &&",
													"        error.location === expectedError.location",
													"    );",
													"",
													"    pm.expect(matchingError).to.be.an(\"object\", \"Expected error for invalid limit was not found\");",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/affiliates/snapshot?addressFilter[]={{dydxWithReferrals}}&addressFilter[]={{dydxWithReferrals2}}&offset=0&limit=0",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"affiliates",
												"snapshot"
											],
											"query": [
												{
													"key": "addressFilter[]",
													"value": "{{dydxWithReferrals}}"
												},
												{
													"key": "addressFilter[]",
													"value": "{{dydxWithReferrals2}}"
												},
												{
													"key": "offset",
													"value": "0"
												},
												{
													"key": "limit",
													"value": "0"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "/affiliates/snapshot pagination limit 2",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"Response status code is 200\", function () {",
													"    pm.response.to.have.status(200);",
													"});",
													"",
													"pm.test(\"Response contains 'affiliateList', 'currentOffset', and 'total'\", function () {",
													"    const jsonData = pm.response.json();",
													"    ",
													"    pm.expect(jsonData).to.be.an(\"object\");",
													"    pm.expect(jsonData).to.have.property(\"affiliateList\").that.is.an(\"array\");",
													"    pm.expect(jsonData).to.have.property(\"currentOffset\").that.is.a(\"number\");",
													"    pm.expect(jsonData).to.have.property(\"total\").that.is.a(\"number\");",
													"});",
													"",
													"pm.test(\"Affiliate list should contain 2 entries\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData.affiliateList.length).to.equal(2, \"Expected 2 affiliate objects\");",
													"});",
													"",
													"pm.test(\"Each affiliate object contains required properties\", function () {",
													"    const jsonData = pm.response.json();",
													"    ",
													"    jsonData.affiliateList.forEach(affiliate => {",
													"        pm.expect(affiliate.affiliateAddress).to.be.a(\"string\").and.not.be.empty;",
													"        pm.expect(affiliate.affiliateReferralCode).to.be.a(\"string\").and.not.be.empty;",
													"        pm.expect(affiliate.affiliateEarnings).to.be.a(\"number\");",
													"        pm.expect(affiliate.affiliateReferredTrades).to.be.a(\"number\");",
													"        pm.expect(affiliate.affiliateTotalReferredFees).to.be.a(\"number\");",
													"        pm.expect(affiliate.affiliateReferredUsers).to.be.a(\"number\");",
													"        pm.expect(affiliate.affiliateReferredNetProtocolEarnings).to.be.a(\"number\");",
													"        pm.expect(affiliate.affiliateReferredTotalVolume).to.be.a(\"number\");",
													"        pm.expect(affiliate.affiliateReferredMakerFees).to.be.a(\"number\");",
													"        pm.expect(affiliate.affiliateReferredTakerFees).to.be.a(\"number\");",
													"        pm.expect(affiliate.affiliateReferredMakerRebates).to.be.a(\"number\");",
													"    });",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/affiliates/snapshot?addressFilter[]={{dydxWithReferrals}}&addressFilter[]={{dydxWithReferrals2}}&offset=0&limit=3",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"affiliates",
												"snapshot"
											],
											"query": [
												{
													"key": "addressFilter[]",
													"value": "{{dydxWithReferrals}}"
												},
												{
													"key": "addressFilter[]",
													"value": "{{dydxWithReferrals2}}"
												},
												{
													"key": "offset",
													"value": "0"
												},
												{
													"key": "limit",
													"value": "3"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "/affiliates/snapshot pagination limit 999999",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"Response status code is 200\", function () {",
													"    pm.response.to.have.status(200);",
													"});",
													"",
													"pm.test(\"Response contains 'affiliateList', 'currentOffset', and 'total'\", function () {",
													"    const jsonData = pm.response.json();",
													"    ",
													"    pm.expect(jsonData).to.be.an(\"object\");",
													"    pm.expect(jsonData).to.have.property(\"affiliateList\").that.is.an(\"array\");",
													"    pm.expect(jsonData).to.have.property(\"currentOffset\").that.is.a(\"number\");",
													"    pm.expect(jsonData).to.have.property(\"total\").that.is.a(\"number\");",
													"});",
													"",
													"pm.test(\"Affiliate list should contain 2 entries\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData.affiliateList.length).to.equal(2, \"Expected 2 affiliate objects\");",
													"});",
													"",
													"pm.test(\"Each affiliate object contains required properties\", function () {",
													"    const jsonData = pm.response.json();",
													"    ",
													"    jsonData.affiliateList.forEach(affiliate => {",
													"        pm.expect(affiliate.affiliateAddress).to.be.a(\"string\").and.not.be.empty;",
													"        pm.expect(affiliate.affiliateReferralCode).to.be.a(\"string\").and.not.be.empty;",
													"        pm.expect(affiliate.affiliateEarnings).to.be.a(\"number\");",
													"        pm.expect(affiliate.affiliateReferredTrades).to.be.a(\"number\");",
													"        pm.expect(affiliate.affiliateTotalReferredFees).to.be.a(\"number\");",
													"        pm.expect(affiliate.affiliateReferredUsers).to.be.a(\"number\");",
													"        pm.expect(affiliate.affiliateReferredNetProtocolEarnings).to.be.a(\"number\");",
													"        pm.expect(affiliate.affiliateReferredTotalVolume).to.be.a(\"number\");",
													"        pm.expect(affiliate.affiliateReferredMakerFees).to.be.a(\"number\");",
													"        pm.expect(affiliate.affiliateReferredTakerFees).to.be.a(\"number\");",
													"        pm.expect(affiliate.affiliateReferredMakerRebates).to.be.a(\"number\");",
													"    });",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/affiliates/snapshot?addressFilter[]={{dydxWithReferrals}}&addressFilter[]={{dydxWithReferrals2}}&offset=0&limit=999999",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"affiliates",
												"snapshot"
											],
											"query": [
												{
													"key": "addressFilter[]",
													"value": "{{dydxWithReferrals}}"
												},
												{
													"key": "addressFilter[]",
													"value": "{{dydxWithReferrals2}}"
												},
												{
													"key": "offset",
													"value": "0"
												},
												{
													"key": "limit",
													"value": "999999"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "/affiliates/snapshot invalid",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify response status code is 200 even for invalid address",
													"pm.test(\"Response status code is 200 for invalid dYdX address\", function () {",
													"    pm.response.to.have.status(200);",
													"});",
													"",
													"// 2. Validate response structure",
													"pm.test(\"Response contains 'affiliateList', 'currentOffset', and 'total'\", function () {",
													"    const jsonData = pm.response.json();",
													"    ",
													"    pm.expect(jsonData).to.be.an(\"object\");",
													"    pm.expect(jsonData).to.have.property(\"affiliateList\").that.is.an(\"array\");",
													"    pm.expect(jsonData).to.have.property(\"currentOffset\").that.is.a(\"number\");",
													"    pm.expect(jsonData).to.have.property(\"total\").that.is.a(\"number\");",
													"});",
													"",
													"// 3. Ensure 'affiliateList' is empty for invalid address",
													"pm.test(\"Affiliate list should be empty for invalid dYdX address\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData.affiliateList).to.be.an(\"array\").that.is.empty;",
													"});",
													"",
													"// 4. Validate pagination values",
													"pm.test(\"Pagination values should be correct for invalid address\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData.currentOffset).to.equal(0);",
													"    pm.expect(jsonData.total).to.equal(0);",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/affiliates/snapshot?addressFilter[]={{invaliddYdXAddress}}&offset=0&limit=10",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"affiliates",
												"snapshot"
											],
											"query": [
												{
													"key": "addressFilter[]",
													"value": "{{invaliddYdXAddress}}"
												},
												{
													"key": "offset",
													"value": "0"
												},
												{
													"key": "limit",
													"value": "10"
												}
											]
										}
									},
									"response": []
								}
							]
						}
					]
				},
				{
					"name": "assetPositions",
					"item": [
						{
							"name": "/assetPositions VALID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify response status code",
											"pm.test(\"Response status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"// 2. Check response time (threshold set to 6000ms)",
											"pm.test(\"Response time is less than 6000ms\", function () {",
											"    pm.expect(pm.response.responseTime).to.be.below(6000);",
											"});",
											"",
											"// 3. Validate top-level structure: Ensure response is an object with a \"positions\" array",
											"pm.test(\"Response has 'positions' array\", function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData).to.be.an(\"object\");",
											"    pm.expect(jsonData).to.have.property(\"positions\").that.is.an(\"array\");",
											"});",
											"",
											"// 4. Validate the schema for each position in the \"positions\" array",
											"pm.test(\"Validate schema for each position\", function () {",
											"    const jsonData = pm.response.json();",
											"    jsonData.positions.forEach((position) => {",
											"        pm.expect(position).to.be.an(\"object\");",
											"        pm.expect(position).to.have.property(\"symbol\").that.is.a(\"string\");",
											"        pm.expect(position).to.have.property(\"side\").that.is.a(\"string\");",
											"        pm.expect(position).to.have.property(\"size\").that.is.a(\"string\");",
											"        pm.expect(position).to.have.property(\"assetId\").that.is.a(\"string\");",
											"        pm.expect(position).to.have.property(\"subaccountNumber\").that.is.a(\"number\");",
											"",
											"        // Optionally, check that size is a valid numeric value",
											"        pm.expect(parseFloat(position.size)).to.not.be.NaN;",
											"    });",
											"});",
											"",
											"// 5. Validate the response against a JSON schema",
											"pm.test(\"Response matches expected JSON schema\", function () {",
											"    const schema = {",
											"        type: \"object\",",
											"        properties: {",
											"            positions: {",
											"                type: \"array\",",
											"                items: {",
											"                    type: \"object\",",
											"                    properties: {",
											"                        symbol: { type: \"string\" },",
											"                        side: { type: \"string\" },",
											"                        size: { type: \"string\" },",
											"                        assetId: { type: \"string\" },",
											"                        subaccountNumber: { type: \"number\" }",
											"                    },",
											"                    required: [\"symbol\", \"side\", \"size\", \"assetId\", \"subaccountNumber\"]",
											"                }",
											"            }",
											"        },",
											"        required: [\"positions\"]",
											"    };",
											"",
											"    pm.response.to.have.jsonSchema(schema);",
											"});",
											"",
											"",
											"// 6. Ensure no unexpected properties exist in each position object",
											"pm.test(\"No unexpected properties in position schema\", function () {",
											"    const jsonData = pm.response.json();",
											"    const expectedKeys = [\"symbol\", \"side\", \"size\", \"assetId\", \"subaccountNumber\"];",
											"    jsonData.positions.forEach((position) => {",
											"        Object.keys(position).forEach((key) => {",
											"            pm.expect(expectedKeys).to.include(key, `Unexpected property found in position: ${key}`);",
											"        });",
											"    });",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/assetPositions/?address={{validdYdXAddress}}&subaccountNumber=0",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"assetPositions",
										""
									],
									"query": [
										{
											"key": "address",
											"value": "{{validdYdXAddress}}"
										},
										{
											"key": "subaccountNumber",
											"value": "0"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "/assetPositions INVALID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify the response status code is 400 (Bad Request)",
											"pm.test(\"Status code is 400\", function () {",
											"    pm.response.to.have.status(400);",
											"});",
											"",
											"// 2. Verify that the response contains an 'errors' array with at least one error object",
											"pm.test(\"Response contains an 'errors' array\", function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData).to.be.an(\"object\");",
											"    pm.expect(jsonData).to.have.property(\"errors\").that.is.an(\"array\");",
											"    pm.expect(jsonData.errors.length).to.be.above(0);",
											"});",
											"",
											"// 3. Validate the structure and content of the first error object",
											"pm.test(\"Error object for subaccountNumber has the expected structure and values\", function () {",
											"    const error = pm.response.json().errors[0];",
											"    pm.expect(error).to.be.an(\"object\");",
											"    pm.expect(error).to.have.property(\"value\").that.eql(\"-\");",
											"    pm.expect(error).to.have.property(\"msg\").that.eql(\"subaccountNumber must be a non-negative integer less than 128001\");",
											"    pm.expect(error).to.have.property(\"param\").that.eql(\"subaccountNumber\");",
											"    pm.expect(error).to.have.property(\"location\").that.eql(\"query\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/assetPositions/?address={{validdYdXAddress}}&subaccountNumber=-",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"assetPositions",
										""
									],
									"query": [
										{
											"key": "address",
											"value": "{{validdYdXAddress}}"
										},
										{
											"key": "subaccountNumber",
											"value": "-"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "/assetPositions/parentSubaccountNumber VALID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify the response status code is 200",
											"pm.test(\"Response status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"// 2. Check that the response time is acceptable (e.g., less than 6000ms)",
											"pm.test(\"Response time is less than 6000ms\", function () {",
											"    pm.expect(pm.response.responseTime).to.be.below(6000);",
											"});",
											"",
											"// 3. Validate that the response contains a top-level \"subaccount\" object",
											"pm.test(\"Response contains 'subaccount' object\", function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData).to.be.an(\"object\");",
											"    pm.expect(jsonData).to.have.property(\"subaccount\").that.is.an(\"object\");",
											"});",
											"",
											"// 4. Validate the structure of the \"subaccount\" object",
											"pm.test(\"Subaccount object structure is valid\", function () {",
											"    const subaccount = pm.response.json().subaccount;",
											"",
											"    // Validate basic properties and their types",
											"    pm.expect(subaccount).to.have.property(\"address\").that.is.a(\"string\");",
											"    pm.expect(subaccount).to.have.property(\"parentSubaccountNumber\").that.is.a(\"number\");",
											"    pm.expect(subaccount).to.have.property(\"equity\").that.is.a(\"string\");",
											"    pm.expect(subaccount).to.have.property(\"freeCollateral\").that.is.a(\"string\");",
											"    pm.expect(subaccount).to.have.property(\"childSubaccounts\").that.is.an(\"array\");",
											"",
											"    // Validate the address follows the expected DYDX address format (rough check)",
											"    const dydxAddressPattern = /^dydx1[a-z0-9]{38}$/;",
											"    pm.expect(subaccount.address).to.match(dydxAddressPattern, \"Subaccount address format is invalid\");",
											"});",
											"",
											"// 5. Validate the structure of each child subaccount in the \"childSubaccounts\" array",
											"pm.test(\"Child subaccounts structure is valid\", function () {",
											"    const childSubaccounts = pm.response.json().subaccount.childSubaccounts;",
											"    ",
											"    // Ensure there is at least one child subaccount",
											"    pm.expect(childSubaccounts.length).to.be.above(0);",
											"",
											"    childSubaccounts.forEach((child, index) => {",
											"        pm.test(`Child subaccount ${index + 1} structure`, function () {",
											"            pm.expect(child).to.be.an(\"object\");",
											"            pm.expect(child).to.have.property(\"address\").that.is.a(\"string\");",
											"            pm.expect(child).to.have.property(\"subaccountNumber\").that.is.a(\"number\");",
											"            pm.expect(child).to.have.property(\"equity\").that.is.a(\"string\");",
											"            pm.expect(child).to.have.property(\"freeCollateral\").that.is.a(\"string\");",
											"            pm.expect(child).to.have.property(\"openPerpetualPositions\").that.is.an(\"object\");",
											"            pm.expect(child).to.have.property(\"assetPositions\").that.is.an(\"object\");",
											"            pm.expect(child).to.have.property(\"marginEnabled\").that.is.a(\"boolean\");",
											"            pm.expect(child).to.have.property(\"updatedAtHeight\").that.is.a(\"string\");",
											"            pm.expect(child).to.have.property(\"latestProcessedBlockHeight\").that.is.a(\"string\");",
											"",
											"            // Validate the address format for the child subaccount",
											"            const dydxAddressPattern = /^dydx1[a-z0-9]{38}$/;",
											"            pm.expect(child.address).to.match(dydxAddressPattern, \"Child subaccount address format is invalid\");",
											"        });",
											"    });",
											"});",
											"",
											"// 6. Validate the \"assetPositions\" inside each child subaccount without checking exact values",
											"pm.test(\"Asset positions structure is valid\", function () {",
											"    const childSubaccounts = pm.response.json().subaccount.childSubaccounts;",
											"    ",
											"    childSubaccounts.forEach((child, index) => {",
											"        pm.test(`Asset positions for child subaccount ${index + 1}`, function () {",
											"            const assetPositions = child.assetPositions;",
											"            pm.expect(assetPositions).to.be.an(\"object\");",
											"",
											"            // Check that assetPositions has at least one key (example: \"USDC\")",
											"            pm.expect(Object.keys(assetPositions).length).to.be.above(0);",
											"",
											"            // Validate each asset position's structure",
											"            Object.values(assetPositions).forEach((position) => {",
											"                pm.expect(position).to.be.an(\"object\");",
											"                pm.expect(position).to.have.property(\"size\").that.is.a(\"string\");",
											"                pm.expect(position).to.have.property(\"symbol\").that.is.a(\"string\");",
											"                pm.expect(position).to.have.property(\"side\").that.is.a(\"string\");",
											"                pm.expect(position).to.have.property(\"assetId\").that.is.a(\"string\");",
											"                pm.expect(position).to.have.property(\"subaccountNumber\").that.is.a(\"number\");",
											"",
											"                // Optionally, validate that size is a numeric string",
											"                pm.expect(parseFloat(position.size)).to.not.be.NaN;",
											"            });",
											"        });",
											"    });",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/addresses/{{validdYdXAddress}}/parentSubaccountNumber/0",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"addresses",
										"{{validdYdXAddress}}",
										"parentSubaccountNumber",
										"0"
									]
								}
							},
							"response": []
						},
						{
							"name": "/assetPositions/parentSubaccountNumber INVALID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify the response status code is 400 (Bad Request)",
											"pm.test(\"Status code is 400\", function () {",
											"    pm.response.to.have.status(400);",
											"});",
											"",
											"// 2. Verify that the response contains an 'errors' array with at least one error object",
											"pm.test(\"Response contains an 'errors' array\", function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData).to.be.an(\"object\");",
											"    pm.expect(jsonData).to.have.property(\"errors\").that.is.an(\"array\");",
											"    pm.expect(jsonData.errors.length).to.be.above(0);",
											"});",
											"",
											"// 3. Validate the structure and content of the error object for parentSubaccountNumber",
											"pm.test(\"Error object for parentSubaccountNumber has the expected structure and values\", function () {",
											"    const error = pm.response.json().errors[0];",
											"    pm.expect(error).to.be.an(\"object\");",
											"    pm.expect(error).to.have.property(\"value\").that.eql(\"-\");",
											"    pm.expect(error).to.have.property(\"msg\").that.eql(\"parentSubaccountNumber must be a non-negative integer less than 128\");",
											"    pm.expect(error).to.have.property(\"param\").that.eql(\"parentSubaccountNumber\");",
											"    pm.expect(error).to.have.property(\"location\").that.eql(\"params\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/addresses/{{validdYdXAddress}}/parentSubaccountNumber/-",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"addresses",
										"{{validdYdXAddress}}",
										"parentSubaccountNumber",
										"-"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "candles",
					"item": [
						{
							"name": "/candles/perpetualMarkets/ticker/ VALID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify the response status code is 200",
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"// 2. Verify the response time is less than 6000ms",
											"pm.test(\"Response time is less than 6000ms\", function () {",
											"    pm.expect(pm.response.responseTime).to.be.below(6000);",
											"});",
											"",
											"// 3. Verify that the response contains a top-level \"candles\" array with at least one candle",
											"pm.test(\"Response contains a 'candles' array\", function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData).to.be.an(\"object\");",
											"    pm.expect(jsonData).to.have.property(\"candles\").that.is.an(\"array\");",
											"    pm.expect(jsonData.candles.length).to.be.above(0);",
											"});",
											"",
											"// 4. Validate the structure of each candle in the \"candles\" array",
											"pm.test(\"Each candle has the expected structure for 1MIN resolution\", function () {",
											"    const candles = pm.response.json().candles;",
											"    candles.forEach((candle) => {",
											"        pm.expect(candle).to.be.an(\"object\");",
											"",
											"        // Validate required properties and types",
											"        pm.expect(candle).to.have.property(\"startedAt\").that.is.a(\"string\");",
											"        pm.expect(candle).to.have.property(\"ticker\").that.is.a(\"string\");",
											"        pm.expect(candle).to.have.property(\"resolution\").that.is.a(\"string\");",
											"        // Ensure the resolution is \"1MIN\"",
											"        pm.expect(candle.resolution).to.eql(\"1MIN\");",
											"",
											"        pm.expect(candle).to.have.property(\"low\").that.is.a(\"string\");",
											"        pm.expect(candle).to.have.property(\"high\").that.is.a(\"string\");",
											"        pm.expect(candle).to.have.property(\"open\").that.is.a(\"string\");",
											"        pm.expect(candle).to.have.property(\"close\").that.is.a(\"string\");",
											"        pm.expect(candle).to.have.property(\"baseTokenVolume\").that.is.a(\"string\");",
											"        pm.expect(candle).to.have.property(\"usdVolume\").that.is.a(\"string\");",
											"        pm.expect(candle).to.have.property(\"trades\").that.is.a(\"number\");",
											"        pm.expect(candle).to.have.property(\"startingOpenInterest\").that.is.a(\"string\");",
											"    });",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/candles/perpetualMarkets/{{ticker}}?resolution=1MIN",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"candles",
										"perpetualMarkets",
										"{{ticker}}"
									],
									"query": [
										{
											"key": "resolution",
											"value": "1MIN"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "/candles/perpetualMarkets/ticker/ INVALID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify the response status code is 400 (Bad Request)",
											"pm.test(\"Status code is 400\", function () {",
											"    pm.response.to.have.status(400);",
											"});",
											"",
											"// 2. Verify that the response contains an 'errors' array with at least one error object",
											"pm.test(\"Response contains an 'errors' array\", function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData).to.be.an(\"object\");",
											"    pm.expect(jsonData).to.have.property(\"errors\").that.is.an(\"array\");",
											"    pm.expect(jsonData.errors.length).to.be.above(0);",
											"});",
											"",
											"// 3. Validate the structure and content of the first error object",
											"pm.test(\"Error object has the expected structure and values\", function () {",
											"    const error = pm.response.json().errors[0];",
											"    pm.expect(error).to.be.an(\"object\");",
											"    pm.expect(error).to.have.property(\"value\").that.eql(\"1MINS\");",
											"    pm.expect(error).to.have.property(\"msg\").that.eql(\"resolution must be a valid Candle Resolution, one of 1MIN,5MINS,15MINS,30MINS,1HOUR,4HOURS,1DAY\");",
											"    pm.expect(error).to.have.property(\"param\").that.eql(\"resolution\");",
											"    pm.expect(error).to.have.property(\"location\").that.eql(\"query\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/candles/perpetualMarkets/{{ticker}}?resolution=1MINS",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"candles",
										"perpetualMarkets",
										"{{ticker}}"
									],
									"query": [
										{
											"key": "resolution",
											"value": "1MINS"
										}
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "compliance",
					"item": [
						{
							"name": "screen",
							"item": [
								{
									"name": "compliance/screen/ VALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify the response status code is 200",
													"pm.test(\"Status code is 200\", function () {",
													"    pm.response.to.have.status(200);",
													"});",
													"",
													"// 2. Check that the response time is acceptable (e.g., less than 6000ms)",
													"pm.test(\"Response time is less than 6000ms\", function () {",
													"    pm.expect(pm.response.responseTime).to.be.below(6000);",
													"});",
													"",
													"// 3. Verify the response body contains the expected properties",
													"pm.test(\"Response body has the required properties\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData).to.be.an(\"object\");",
													"    pm.expect(jsonData).to.have.property(\"status\").that.is.a(\"string\");",
													"    // 'reason' can be null or a string",
													"    pm.expect(jsonData).to.have.property(\"reason\");",
													"    pm.expect(jsonData).to.have.property(\"updatedAt\").that.is.a(\"string\");",
													"});",
													"",
													"// 4. Validate the 'status' value (in this example, it should be \"COMPLIANT\")",
													"pm.test(\"Status is 'COMPLIANT'\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData.status).to.eql(\"COMPLIANT\");",
													"});",
													"",
													"// 5. Validate that the 'updatedAt' property is a valid ISO 8601 date-time string",
													"pm.test(\"updatedAt is a valid ISO 8601 date-time string\", function () {",
													"    const jsonData = pm.response.json();",
													"    // Basic regex for ISO 8601 formatted date-time string (e.g., 2024-11-05T08:45:51.899Z)",
													"    const iso8601Pattern = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?Z$/;",
													"    pm.expect(jsonData.updatedAt).to.match(iso8601Pattern);",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/compliance/screen/{{validdYdXAddress}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"compliance",
												"screen",
												"{{validdYdXAddress}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "compliance/screen/INVALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify the response status code is 200",
													"pm.test(\"Status code is 200\", function () {",
													"    pm.response.to.have.status(200);",
													"});",
													"",
													"// 2. Validate the response structure for an invalid dYdX address",
													"pm.test(\"Response contains only the 'status' property with value 'COMPLIANT'\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData).to.be.an(\"object\");",
													"    ",
													"    // Check that 'status' exists and equals \"COMPLIANT\"",
													"    pm.expect(jsonData).to.have.property(\"status\").that.eql(\"COMPLIANT\");",
													"    ",
													"    // Optionally, ensure that other expected properties (reason, updatedAt) are absent",
													"    pm.expect(jsonData).to.not.have.property(\"reason\");",
													"    pm.expect(jsonData).to.not.have.property(\"updatedAt\");",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/compliance/screen/{{invaliddYdXAddress}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"compliance",
												"screen",
												"{{invaliddYdXAddress}}"
											]
										}
									},
									"response": []
								}
							]
						}
					]
				},
				{
					"name": "fills",
					"item": [
						{
							"name": "parentSubaccount",
							"item": []
						},
						{
							"name": "/fills/ VALID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// Define a JSON Schema for a fill object",
											"const fillSchema = {",
											"    type: \"object\",",
											"    properties: {",
											"        id: { type: \"string\" },",
											"        side: { type: \"string\", enum: [\"BUY\", \"SELL\"] },",
											"        liquidity: { type: \"string\", enum: [\"MAKER\", \"TAKER\"] },",
											"        type: { type: \"string\", enum: [\"LIMIT\", \"MARKET\"] },",
											"        market: { type: \"string\" },",
											"        marketType: { type: \"string\", enum: [\"PERPETUAL\", \"SPOT\"] },",
											"        price: { type: \"string\" },",
											"        size: { type: \"string\" },",
											"        fee: { type: \"string\" },",
											"        affiliateRevShare: { type: \"string\" },",
											"        createdAt: { type: \"string\", format: \"date-time\" },",
											"        createdAtHeight: { type: \"string\" },",
											"        orderId: { type: \"string\" },",
											"        clientMetadata: { type: \"string\" },",
											"        subaccountNumber: { type: \"number\" }",
											"    },",
											"    required: [",
											"        \"id\",",
											"        \"side\",",
											"        \"liquidity\",",
											"        \"type\",",
											"        \"market\",",
											"        \"marketType\",",
											"        \"price\",",
											"        \"size\",",
											"        \"fee\",",
											"        \"affiliateRevShare\",",
											"        \"createdAt\",",
											"        \"createdAtHeight\",",
											"        \"orderId\",",
											"        \"clientMetadata\",",
											"        \"subaccountNumber\"",
											"    ]",
											"};",
											"",
											"// Define the overall response schema and require that the 'fills' array is non-empty",
											"const responseSchema = {",
											"    type: \"object\",",
											"    properties: {",
											"        fills: {",
											"            type: \"array\",",
											"            minItems: 1,  // This enforces that the array must contain at least one element.",
											"            items: fillSchema",
											"        }",
											"    },",
											"    required: [\"fills\"]",
											"};",
											"",
											"// Run tests",
											"// 1. Status code",
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"// 2. Response time",
											"pm.test(\"Response time is less than 6000ms\", function () {",
											"    pm.expect(pm.response.responseTime).to.be.below(6000);",
											"});",
											"",
											"// 3. Basic structure check for 'fills'",
											"const jsonData = pm.response.json();",
											"pm.test(\"Response contains a non-empty 'fills' array\", function () {",
											"    pm.expect(jsonData).to.be.an(\"object\");",
											"    pm.expect(jsonData).to.have.property(\"fills\").that.is.an(\"array\");",
											"    pm.expect(jsonData.fills.length).to.be.above(0);",
											"});",
											"",
											"// 4. Validate enumerated values in each fill object",
											"pm.test(\"Each fill has valid enumerated values\", function () {",
											"    jsonData.fills.forEach((fill, index) => {",
											"        pm.expect([\"LIMIT\", \"MARKET\"]).to.include(fill.type, `Fill at index ${index} has unexpected type: ${fill.type}`);",
											"        pm.expect([\"MAKER\", \"TAKER\"]).to.include(fill.liquidity, `Fill at index ${index} has unexpected liquidity: ${fill.liquidity}`);",
											"        pm.expect([\"BUY\", \"SELL\"]).to.include(fill.side, `Fill at index ${index} has unexpected side: ${fill.side}`);",
											"    });",
											"});",
											"",
											"// 5. Validate the response against the JSON schema",
											"pm.test(\"Response schema is valid and non-empty\", function () {",
											"    pm.response.to.have.jsonSchema(responseSchema);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/fills?address={{validdYdXAddress}}&subaccountNumber=0",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"fills"
									],
									"query": [
										{
											"key": "address",
											"value": "{{validdYdXAddress}}"
										},
										{
											"key": "subaccountNumber",
											"value": "0"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "/fills INVALID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify the response status code is 200",
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"// 2. Verify that the response time is acceptable (e.g., less than 6000ms)",
											"pm.test(\"Response time is less than 6000ms\", function () {",
											"    pm.expect(pm.response.responseTime).to.be.below(6000);",
											"});",
											"",
											"// 3. Verify that the response is a JSON object containing a 'fills' array",
											"pm.test(\"Response contains a 'fills' array\", function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData).to.be.an(\"object\");",
											"    pm.expect(jsonData).to.have.property(\"fills\").that.is.an(\"array\");",
											"});",
											"",
											"// 4. Verify that the 'fills' array is empty for an invalid address",
											"pm.test(\"The 'fills' array is empty\", function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData.fills.length).to.eql(0);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/fills?address={{invaliddYdXAddress}}&subaccountNumber=0",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"fills"
									],
									"query": [
										{
											"key": "address",
											"value": "{{invaliddYdXAddress}}"
										},
										{
											"key": "subaccountNumber",
											"value": "0"
										}
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "height",
					"item": [
						{
							"name": "/height",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Check that the status code is 200",
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"// 2. Verify the response time is acceptable (e.g., less than 6000ms)",
											"pm.test(\"Response time is less than 6000ms\", function () {",
											"    pm.expect(pm.response.responseTime).to.be.below(6000);",
											"});",
											"",
											"// 3. Check that the response is a JSON object",
											"const jsonData = pm.response.json();",
											"pm.test(\"Response is a valid JSON object\", function () {",
											"    pm.expect(jsonData).to.be.an(\"object\");",
											"});",
											"",
											"// 4. Verify the response contains the required properties",
											"pm.test(\"Response contains 'height' and 'time'\", function () {",
											"    pm.expect(jsonData).to.have.property(\"height\").that.is.a(\"string\");",
											"    pm.expect(jsonData).to.have.property(\"time\").that.is.a(\"string\");",
											"});",
											"",
											"// 5. Verify that 'height' is a numeric string",
											"pm.test(\"'height' is a numeric string\", function () {",
											"    const heightNum = parseInt(jsonData.height, 10);",
											"    pm.expect(heightNum).to.be.a(\"number\");",
											"    pm.expect(heightNum).to.be.above(0);",
											"});",
											"",
											"// 6. Verify that 'time' is a valid ISO 8601 date-time string",
											"pm.test(\"'time' is a valid ISO 8601 date-time string\", function () {",
											"    const iso8601Regex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?Z$/;",
											"    pm.expect(jsonData.time).to.match(iso8601Regex);",
											"});",
											"",
											"// 7. Validate the entire response against a JSON Schema",
											"const schema = {",
											"    type: \"object\",",
											"    properties: {",
											"        height: { type: \"string\" },",
											"        time: { type: \"string\", format: \"date-time\" }",
											"    },",
											"    required: [\"height\", \"time\"]",
											"};",
											"",
											"pm.test(\"Response matches the JSON schema\", function () {",
											"    pm.response.to.have.jsonSchema(schema);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/height",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"height"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "historicalBlockTradingRewards",
					"item": [
						{
							"name": "historicalBlockTradingRewards/ VALID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify the response status code is 200",
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"// 2. Verify that the response time is acceptable (e.g., less than 6000ms)",
											"pm.test(\"Response time is less than 6000ms\", function () {",
											"    pm.expect(pm.response.responseTime).to.be.below(6000);",
											"});",
											"",
											"// 3. Verify that the response is a JSON object containing a 'rewards' array",
											"const jsonData = pm.response.json();",
											"pm.test(\"Response contains a 'rewards' array\", function () {",
											"    pm.expect(jsonData).to.be.an(\"object\");",
											"    pm.expect(jsonData).to.have.property(\"rewards\").that.is.an(\"array\");",
											"});",
											"",
											"// 4. Validate the structure and enumerated values for each reward object",
											"pm.test(\"Each reward has the expected structure and valid values\", function () {",
											"    jsonData.rewards.forEach((reward, index) => {",
											"        pm.expect(reward).to.be.an(\"object\");",
											"",
											"        // Check that tradingReward exists and is a numeric string",
											"        pm.expect(reward).to.have.property(\"tradingReward\").that.is.a(\"string\");",
											"        pm.expect(parseFloat(reward.tradingReward)).to.not.be.NaN;",
											"",
											"        // Check that createdAt exists and is a valid ISO 8601 date-time string",
											"        pm.expect(reward).to.have.property(\"createdAt\").that.is.a(\"string\");",
											"        const iso8601Regex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?Z$/;",
											"        pm.expect(reward.createdAt).to.match(iso8601Regex, `Reward at index ${index} has an invalid createdAt format`);",
											"",
											"        // Check that createdAtHeight exists and is a string (you could also verify it's numeric if needed)",
											"        pm.expect(reward).to.have.property(\"createdAtHeight\").that.is.a(\"string\");",
											"    });",
											"});",
											"",
											"// 5. Define a JSON Schema for the reward object and overall response",
											"const rewardSchema = {",
											"    type: \"object\",",
											"    properties: {",
											"        tradingReward: { type: \"string\" },",
											"        createdAt: { type: \"string\", format: \"date-time\" },",
											"        createdAtHeight: { type: \"string\" }",
											"    },",
											"    required: [\"tradingReward\", \"createdAt\", \"createdAtHeight\"]",
											"};",
											"",
											"const responseSchema = {",
											"    type: \"object\",",
											"    properties: {",
											"        rewards: {",
											"            type: \"array\",",
											"            items: rewardSchema",
											"        }",
											"    },",
											"    required: [\"rewards\"]",
											"};",
											"",
											"// 6. Validate the response against the JSON schema",
											"pm.test(\"Response matches the JSON schema\", function () {",
											"    pm.response.to.have.jsonSchema(responseSchema);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/historicalBlockTradingRewards/{{validdYdXAddress}}",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"historicalBlockTradingRewards",
										"{{validdYdXAddress}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "historicalBlockTradingRewards/ INVALID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify the response status code is 200",
											"pm.test(\"Status code is 200\", function () {",
											"  pm.response.to.have.status(200);",
											"});",
											"",
											"// 2. Verify that the response time is acceptable (e.g., less than 6000ms)",
											"pm.test(\"Response time is less than 6000ms\", function () {",
											"  pm.expect(pm.response.responseTime).to.be.below(6000);",
											"});",
											"",
											"// 3. Verify that the response is a JSON object containing a 'rewards' array",
											"const jsonData = pm.response.json();",
											"pm.test(\"Response contains a 'rewards' array\", function () {",
											"  pm.expect(jsonData).to.be.an(\"object\");",
											"  pm.expect(jsonData).to.have.property(\"rewards\").that.is.an(\"array\");",
											"});",
											"",
											"// 4. Verify that the 'rewards' array is empty for an invalid address",
											"pm.test(\"The 'rewards' array is empty\", function () {",
											"  pm.expect(jsonData.rewards.length).to.eql(0);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/historicalBlockTradingRewards/{{invaliddYdXAddress}}",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"historicalBlockTradingRewards",
										"{{invaliddYdXAddress}}"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "historicalFunding",
					"item": [
						{
							"name": "historicalFunding/ticker/ VALID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"// Parse the JSON response body",
											"var jsonData = pm.response.json();",
											"",
											"// Check that the response contains a 'historicalFunding' property that is an array",
											"pm.test(\"Response has a 'historicalFunding' array\", function () {",
											"    pm.expect(jsonData).to.be.an(\"object\");",
											"    pm.expect(jsonData).to.have.property(\"historicalFunding\").that.is.an(\"array\");",
											"});",
											"",
											"// If the array is not empty, validate the structure of each item",
											"if (jsonData.historicalFunding.length > 0) {",
											"    pm.test(\"Each funding item has the correct structure and valid data\", function () {",
											"        jsonData.historicalFunding.forEach(function(item, index) {",
											"            // Check required properties exist and are strings",
											"            pm.expect(item, \"Item \" + index + \" should have a 'ticker' property\").to.have.property(\"ticker\").that.is.a(\"string\");",
											"            pm.expect(item, \"Item \" + index + \" should have a 'rate' property\").to.have.property(\"rate\").that.is.a(\"string\");",
											"            pm.expect(item, \"Item \" + index + \" should have a 'price' property\").to.have.property(\"price\").that.is.a(\"string\");",
											"            pm.expect(item, \"Item \" + index + \" should have an 'effectiveAtHeight' property\").to.have.property(\"effectiveAtHeight\").that.is.a(\"string\");",
											"            pm.expect(item, \"Item \" + index + \" should have an 'effectiveAt' property\").to.have.property(\"effectiveAt\").that.is.a(\"string\");",
											"            ",
											"            // Check that the rate, price, and effectiveAtHeight can be converted to numbers",
											"            pm.expect(parseFloat(item.rate), \"Rate of item \" + index + \" should be a valid number\").to.be.a(\"number\");",
											"            pm.expect(parseFloat(item.price), \"Price of item \" + index + \" should be a valid number\").to.be.a(\"number\");",
											"            pm.expect(parseInt(item.effectiveAtHeight, 10), \"effectiveAtHeight of item \" + index + \" should be a valid number\").to.be.a(\"number\");",
											"            ",
											"            // Check that effectiveAt is a valid date string",
											"            var effectiveAtTime = Date.parse(item.effectiveAt);",
											"            pm.expect(effectiveAtTime, \"effectiveAt of item \" + index + \" should be a valid date\").to.be.a(\"number\");",
											"            pm.expect(effectiveAtTime, \"effectiveAt of item \" + index + \" should be a valid timestamp\").to.be.above(0);",
											"        });",
											"    });",
											"",
											"    // New test: Ensure that not every funding rate is 0",
											"    pm.test(\"At least one funding rate is non-zero\", function () {",
											"        // Check that not all funding items have a rate equal to 0",
											"        var allRatesZero = jsonData.historicalFunding.every(function(item) {",
											"            return parseFloat(item.rate) === 0;",
											"        });",
											"        pm.expect(allRatesZero, \"All funding rates are zero\").to.be.false;",
											"    });",
											"}",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/historicalFunding/{{ticker}}",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"historicalFunding",
										"{{ticker}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "historicalFunding/ticker/ INVALID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// Check that the response status is 400",
											"pm.test(\"Status code is 400\", function () {",
											"    pm.response.to.have.status(400);",
											"});",
											"",
											"// Parse the JSON response body",
											"var jsonData = pm.response.json();",
											"",
											"// Check that the response has an 'errors' array with at least one error",
											"pm.test(\"Response contains an 'errors' array\", function () {",
											"    pm.expect(jsonData).to.be.an(\"object\");",
											"    pm.expect(jsonData).to.have.property(\"errors\").that.is.an(\"array\");",
											"    pm.expect(jsonData.errors.length).to.be.above(0);",
											"});",
											"",
											"// Validate the structure of the first error object without checking the exact value of 'value'",
											"var error = jsonData.errors[0];",
											"pm.test(\"Error object has the expected properties\", function () {",
											"    // Check that the 'value' property exists and is a string (without checking its exact content)",
											"    pm.expect(error).to.have.property(\"value\");",
											"    pm.expect(error.value).to.be.a(\"string\");",
											"    ",
											"    // Check other properties with their expected values",
											"    pm.expect(error).to.have.property(\"msg\", \"ticker must be a valid ticker (BTC-USD, etc)\");",
											"    pm.expect(error).to.have.property(\"param\", \"ticker\");",
											"    pm.expect(error).to.have.property(\"location\", \"params\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/historicalFunding/{{invalidTicker}}",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"historicalFunding",
										"{{invalidTicker}}"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "historical-pnl",
					"item": [
						{
							"name": "historical-pnl VALID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// parse response JSON",
											"const jsonData = pm.response.json();",
											"",
											"// Check the status code",
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"// Define the JSON schema for the response",
											"const schema = {",
											"    \"type\": \"object\",",
											"    \"required\": [\"historicalPnl\"],",
											"    \"properties\": {",
											"        \"historicalPnl\": {",
											"            \"type\": \"array\",",
											"            \"items\": {",
											"                \"type\": \"object\",",
											"                \"required\": [",
											"                    \"id\", ",
											"                    \"subaccountId\", ",
											"                    \"equity\", ",
											"                    \"totalPnl\", ",
											"                    \"netTransfers\", ",
											"                    \"createdAt\", ",
											"                    \"blockHeight\", ",
											"                    \"blockTime\"",
											"                ],",
											"                \"properties\": {",
											"                    \"id\": { \"type\": \"string\" },",
											"                    \"subaccountId\": { \"type\": \"string\" },",
											"                    \"equity\": { \"type\": \"string\" },",
											"                    \"totalPnl\": { \"type\": \"string\" },",
											"                    \"netTransfers\": { \"type\": \"string\" },",
											"                    \"createdAt\": { \"type\": \"string\", \"format\": \"date-time\" },",
											"                    \"blockHeight\": { \"type\": \"string\" },",
											"                    \"blockTime\": { \"type\": \"string\" }",
											"                }",
											"            }",
											"        }",
											"    }",
											"};",
											"",
											"// Validate the response body against the schema",
											"pm.test(\"Response schema is valid\", function () {",
											"    pm.response.to.have.jsonSchema(schema);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/historical-pnl/?address={{validdYdXAddress}}&subaccountNumber={{subAccountNumber}}",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"historical-pnl",
										""
									],
									"query": [
										{
											"key": "address",
											"value": "{{validdYdXAddress}}"
										},
										{
											"key": "subaccountNumber",
											"value": "{{subAccountNumber}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "historical-pnl INVALID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify response status code is 400 (adjust if a different error status is expected)",
											"pm.test(\"Response status code is 404\", function () {",
											"  pm.response.to.have.status(404);",
											"});",
											"",
											"// 2. Check response time (threshold set to 6000ms)",
											"pm.test(\"Response time is less than 6000ms\", function () {",
											"  pm.expect(pm.response.responseTime).to.be.below(6000);",
											"});",
											"",
											"// 3. Validate top-level structure: Ensure response is an object with an \"errors\" array",
											"pm.test(\"Response has 'errors' array\", function () {",
											"  const jsonData = pm.response.json();",
											"  pm.expect(jsonData).to.be.an(\"object\");",
											"  pm.expect(jsonData).to.have.property(\"errors\").that.is.an(\"array\");",
											"});",
											"",
											"// 4. Validate the schema for each error in the \"errors\" array",
											"pm.test(\"Validate schema for each error\", function () {",
											"  const jsonData = pm.response.json();",
											"  jsonData.errors.forEach((error) => {",
											"    pm.expect(error).to.be.an(\"object\");",
											"    pm.expect(error).to.have.property(\"msg\").that.is.a(\"string\");",
											"  });",
											"});",
											"",
											"// 5. Check that the error message includes expected text",
											"pm.test(\"Error message contains expected text\", function () {",
											"  const jsonData = pm.response.json();",
											"  // Verify that the first error message includes the expected substring",
											"  pm.expect(jsonData.errors[0].msg).to.include(\"No subaccount found\");",
											"});",
											"",
											"// 6. Validate the full response against a JSON schema",
											"pm.test(\"Response matches expected JSON schema\", function () {",
											"  const schema = {",
											"    type: \"object\",",
											"    properties: {",
											"      errors: {",
											"        type: \"array\",",
											"        items: {",
											"          type: \"object\",",
											"          properties: {",
											"            msg: { type: \"string\" }",
											"          },",
											"          required: [\"msg\"]",
											"        }",
											"      }",
											"    },",
											"    required: [\"errors\"]",
											"  };",
											"",
											"  pm.response.to.have.jsonSchema(schema);",
											"});",
											"",
											"// 7. Ensure no unexpected properties exist in each error object",
											"pm.test(\"No unexpected properties in error objects\", function () {",
											"  const jsonData = pm.response.json();",
											"  const expectedKeys = [\"msg\"];",
											"  jsonData.errors.forEach((error) => {",
											"    Object.keys(error).forEach((key) => {",
											"      pm.expect(expectedKeys).to.include(key, `Unexpected property found in error object: ${key}`);",
											"    });",
											"  });",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/historical-pnl/?address={{invaliddYdXAddress}}&subaccountNumber={{subAccountNumber}}",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"historical-pnl",
										""
									],
									"query": [
										{
											"key": "address",
											"value": "{{invaliddYdXAddress}}"
										},
										{
											"key": "subaccountNumber",
											"value": "{{subAccountNumber}}"
										}
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "historicalTradingRewardAggregations",
					"item": [
						{
							"name": "historicalTradingRewardAggregations/ VALID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify response status code is 200",
											"pm.test(\"Response status code is 200\", function () {",
											"  pm.response.to.have.status(200);",
											"});",
											"",
											"// 2. Check response time (threshold set to 6000ms)",
											"pm.test(\"Response time is less than 6000ms\", function () {",
											"  pm.expect(pm.response.responseTime).to.be.below(6000);",
											"});",
											"",
											"// 3. Validate top-level structure: Ensure response is an object with a \"rewards\" array",
											"pm.test(\"Response has 'rewards' array\", function () {",
											"  const jsonData = pm.response.json();",
											"  pm.expect(jsonData).to.be.an(\"object\");",
											"  pm.expect(jsonData).to.have.property(\"rewards\").that.is.an(\"array\");",
											"});",
											"",
											"// 4. Validate the schema for each reward in the \"rewards\" array",
											"pm.test(\"Validate schema for each reward\", function () {",
											"  const jsonData = pm.response.json();",
											"  jsonData.rewards.forEach((reward) => {",
											"    pm.expect(reward).to.be.an(\"object\");",
											"    pm.expect(reward).to.have.property(\"tradingReward\").that.is.a(\"string\");",
											"    pm.expect(reward).to.have.property(\"startedAt\").that.is.a(\"string\");",
											"    pm.expect(reward).to.have.property(\"startedAtHeight\").that.is.a(\"string\");",
											"    // endedAt and endedAtHeight may be null or a string.",
											"    pm.expect(reward.endedAt === null || typeof reward.endedAt === \"string\").to.be.true;",
											"    pm.expect(reward.endedAtHeight === null || typeof reward.endedAtHeight === \"string\").to.be.true;",
											"    pm.expect(reward).to.have.property(\"period\").that.is.a(\"string\");",
											"  });",
											"});",
											"",
											"// 5. Validate the response against a JSON schema",
											"pm.test(\"Response matches expected JSON schema\", function () {",
											"  const schema = {",
											"    type: \"object\",",
											"    properties: {",
											"      rewards: {",
											"        type: \"array\",",
											"        items: {",
											"          type: \"object\",",
											"          properties: {",
											"            tradingReward: { type: \"string\" },",
											"            startedAt: { type: \"string\", format: \"date-time\" },",
											"            startedAtHeight: { type: \"string\" },",
											"            endedAt: { type: [\"string\", \"null\"] },",
											"            endedAtHeight: { type: [\"string\", \"null\"] },",
											"            period: { type: \"string\" }",
											"          },",
											"          required: [",
											"            \"tradingReward\",",
											"            \"startedAt\",",
											"            \"startedAtHeight\",",
											"            \"endedAt\",",
											"            \"endedAtHeight\",",
											"            \"period\"",
											"          ]",
											"        }",
											"      }",
											"    },",
											"    required: [\"rewards\"]",
											"  };",
											"",
											"  pm.response.to.have.jsonSchema(schema);",
											"});",
											"",
											"// 6. Ensure no unexpected properties exist in each reward object",
											"pm.test(\"No unexpected properties in reward objects\", function () {",
											"  const jsonData = pm.response.json();",
											"  const expectedKeys = [\"tradingReward\", \"startedAt\", \"startedAtHeight\", \"endedAt\", \"endedAtHeight\", \"period\"];",
											"  jsonData.rewards.forEach((reward) => {",
											"    Object.keys(reward).forEach((key) => {",
											"      pm.expect(expectedKeys).to.include(key, `Unexpected property found in reward: ${key}`);",
											"    });",
											"  });",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/historicalTradingRewardAggregations/{{validdYdXAddress}}?period=DAILY",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"historicalTradingRewardAggregations",
										"{{validdYdXAddress}}"
									],
									"query": [
										{
											"key": "period",
											"value": "DAILY"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "historicalTradingRewardAggregations/ INVALID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify the response status code is 200",
											"pm.test(\"Response status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"// 2. Check response time (threshold set to 6000ms)",
											"pm.test(\"Response time is less than 6000ms\", function () {",
											"    pm.expect(pm.response.responseTime).to.be.below(6000);",
											"});",
											"",
											"// 3. Validate top-level structure: Ensure response is an object with a \"rewards\" array",
											"pm.test(\"Response has 'rewards' array\", function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData).to.be.an(\"object\");",
											"    pm.expect(jsonData).to.have.property(\"rewards\").that.is.an(\"array\");",
											"});",
											"",
											"// 4. Validate that the rewards array is empty",
											"pm.test(\"Rewards array is empty\", function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData.rewards.length).to.eql(0);",
											"});",
											"",
											"// 5. Validate the full response against a JSON schema (rewards array with 0 items)",
											"pm.test(\"Response matches expected JSON schema\", function () {",
											"    const schema = {",
											"        \"type\": \"object\",",
											"        \"properties\": {",
											"            \"rewards\": {",
											"                \"type\": \"array\",",
											"                \"maxItems\": 0",
											"            }",
											"        },",
											"        \"required\": [\"rewards\"]",
											"    };",
											"    pm.response.to.have.jsonSchema(schema);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/historicalTradingRewardAggregations/{{invaliddYdXAddress}}?period=DAILY",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"historicalTradingRewardAggregations",
										"{{invaliddYdXAddress}}"
									],
									"query": [
										{
											"key": "period",
											"value": "DAILY"
										}
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "orderbooks",
					"item": [
						{
							"name": "orderbooks/perpetualMarket",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify that the response status code is 200",
											"pm.test(\"Response status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"// 2. Check that the response time is less than 6000ms",
											"pm.test(\"Response time is less than 6000ms\", function () {",
											"    pm.expect(pm.response.responseTime).to.be.below(6000);",
											"});",
											"",
											"// 3. Validate top-level structure: Ensure response is an object with non-empty \"bids\" and \"asks\" arrays",
											"pm.test(\"Response has non-empty 'bids' and 'asks' arrays\", function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData).to.be.an(\"object\");",
											"    pm.expect(jsonData).to.have.property(\"bids\").that.is.an(\"array\");",
											"    pm.expect(jsonData).to.have.property(\"asks\").that.is.an(\"array\");",
											"    pm.expect(jsonData.bids.length).to.be.above(0);",
											"    pm.expect(jsonData.asks.length).to.be.above(0);",
											"});",
											"",
											"// 4. Validate schema for each bid in the \"bids\" array",
											"pm.test(\"Validate schema for each bid\", function () {",
											"    const jsonData = pm.response.json();",
											"    jsonData.bids.forEach(bid => {",
											"        pm.expect(bid).to.be.an(\"object\");",
											"        pm.expect(bid).to.have.property(\"price\").that.is.a(\"string\");",
											"        pm.expect(bid).to.have.property(\"size\").that.is.a(\"string\");",
											"        // Verify that price and size can be converted to numbers",
											"        pm.expect(parseFloat(bid.price)).to.not.be.NaN;",
											"        pm.expect(parseFloat(bid.size)).to.not.be.NaN;",
											"    });",
											"});",
											"",
											"// 5. Validate schema for each ask in the \"asks\" array",
											"pm.test(\"Validate schema for each ask\", function () {",
											"    const jsonData = pm.response.json();",
											"    jsonData.asks.forEach(ask => {",
											"        pm.expect(ask).to.be.an(\"object\");",
											"        pm.expect(ask).to.have.property(\"price\").that.is.a(\"string\");",
											"        pm.expect(ask).to.have.property(\"size\").that.is.a(\"string\");",
											"        // Verify that price and size can be converted to numbers",
											"        pm.expect(parseFloat(ask.price)).to.not.be.NaN;",
											"        pm.expect(parseFloat(ask.size)).to.not.be.NaN;",
											"    });",
											"});",
											"",
											"// 6. Validate the response against the full JSON schema",
											"pm.test(\"Response matches expected JSON schema\", function () {",
											"    const schema = {",
											"        \"type\": \"object\",",
											"        \"properties\": {",
											"            \"bids\": {",
											"                \"type\": \"array\",",
											"                \"items\": {",
											"                    \"type\": \"object\",",
											"                    \"properties\": {",
											"                        \"price\": { \"type\": \"string\" },",
											"                        \"size\": { \"type\": \"string\" }",
											"                    },",
											"                    \"required\": [\"price\", \"size\"],",
											"                    \"additionalProperties\": false",
											"                }",
											"            },",
											"            \"asks\": {",
											"                \"type\": \"array\",",
											"                \"items\": {",
											"                    \"type\": \"object\",",
											"                    \"properties\": {",
											"                        \"price\": { \"type\": \"string\" },",
											"                        \"size\": { \"type\": \"string\" }",
											"                    },",
											"                    \"required\": [\"price\", \"size\"],",
											"                    \"additionalProperties\": false",
											"                }",
											"            }",
											"        },",
											"        \"required\": [\"bids\", \"asks\"],",
											"        \"additionalProperties\": false",
											"    };",
											"",
											"    pm.response.to.have.jsonSchema(schema);",
											"});",
											"",
											"// 7. Ensure no unexpected properties exist in each bid and ask object",
											"pm.test(\"No unexpected properties in bid and ask objects\", function () {",
											"    const jsonData = pm.response.json();",
											"    const expectedKeys = [\"price\", \"size\"];",
											"    jsonData.bids.forEach(bid => {",
											"        Object.keys(bid).forEach(key => {",
											"            pm.expect(expectedKeys).to.include(key, `Unexpected property found in bid: ${key}`);",
											"        });",
											"    });",
											"    jsonData.asks.forEach(ask => {",
											"        Object.keys(ask).forEach(key => {",
											"            pm.expect(expectedKeys).to.include(key, `Unexpected property found in ask: ${key}`);",
											"        });",
											"    });",
											"});",
											"",
											"// 8. Verify that bids are sorted in descending order by price",
											"pm.test(\"Bids are sorted in descending order\", function () {",
											"    const bids = pm.response.json().bids;",
											"    for (let i = 0; i < bids.length - 1; i++) {",
											"        const currentBid = parseFloat(bids[i].price);",
											"        const nextBid = parseFloat(bids[i+1].price);",
											"        pm.expect(currentBid).to.be.at.least(nextBid);",
											"    }",
											"});",
											"",
											"// 9. Verify that asks are sorted in ascending order by price",
											"pm.test(\"Asks are sorted in ascending order\", function () {",
											"    const asks = pm.response.json().asks;",
											"    for (let i = 0; i < asks.length - 1; i++) {",
											"        const currentAsk = parseFloat(asks[i].price);",
											"        const nextAsk = parseFloat(asks[i+1].price);",
											"        pm.expect(currentAsk).to.be.at.most(nextAsk);",
											"    }",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/orderbooks/perpetualMarket/{{ticker}}",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"orderbooks",
										"perpetualMarket",
										"{{ticker}}"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "orders",
					"item": [
						{
							"name": "orders/listOrders VALID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify response status code is 200",
											"pm.test(\"Response status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"// 2. Check response time (threshold set to 6000ms)",
											"pm.test(\"Response time is less than 6000ms\", function () {",
											"    pm.expect(pm.response.responseTime).to.be.below(6000);",
											"});",
											"",
											"// 3. Ensure the response is an array",
											"pm.test(\"Response is an array\", function () {",
											"    const responseData = pm.response.json();",
											"    pm.expect(responseData).to.be.an('array');",
											"});",
											"",
											"// 4. Validate the schema of each order in the array",
											"pm.test(\"Each order in the array has the correct schema\", function () {",
											"    const orders = pm.response.json();",
											"",
											"    orders.forEach((order) => {",
											"        // Required fields (string or number)",
											"        pm.expect(order).to.have.property('id').that.is.a('string');",
											"        pm.expect(order).to.have.property('subaccountId').that.is.a('string');",
											"        pm.expect(order).to.have.property('clientId').that.is.a('string');",
											"        pm.expect(order).to.have.property('clobPairId').that.is.a('string');",
											"        pm.expect(order).to.have.property('side').that.is.a('string');",
											"        pm.expect(order).to.have.property('size').that.is.a('string');",
											"        pm.expect(order).to.have.property('totalFilled').that.is.a('string');",
											"        pm.expect(order).to.have.property('price').that.is.a('string');",
											"        pm.expect(order).to.have.property('type').that.is.a('string');",
											"        pm.expect(order).to.have.property('status').that.is.a('string');",
											"        pm.expect(order).to.have.property('timeInForce').that.is.a('string');",
											"        pm.expect(order).to.have.property('reduceOnly').that.is.a('boolean');",
											"        pm.expect(order).to.have.property('orderFlags').that.is.a('string');",
											"        pm.expect(order).to.have.property('createdAtHeight').that.is.a('string');",
											"        pm.expect(order).to.have.property('clientMetadata').that.is.a('string');",
											"        pm.expect(order).to.have.property('updatedAt').that.is.a('string');",
											"        pm.expect(order).to.have.property('updatedAtHeight').that.is.a('string');",
											"        pm.expect(order).to.have.property('postOnly').that.is.a('boolean');",
											"        pm.expect(order).to.have.property('ticker').that.is.a('string');",
											"        pm.expect(order).to.have.property('subaccountNumber').that.is.a('number');",
											"",
											"        // Optional fields (depending on `timeInForce`)",
											"        // Some orders have `goodTilBlockTime`, others have `goodTilBlock`. ",
											"        // We'll check if they exist (optional), and if so, ensure correct types.",
											"        if (order.hasOwnProperty('goodTilBlockTime')) {",
											"            pm.expect(order.goodTilBlockTime).to.be.a('string');",
											"",
											"            // Validate it's a valid date if the field is present",
											"            const date = new Date(order.goodTilBlockTime);",
											"            pm.expect(date.toString()).not.to.equal(\"Invalid Date\");",
											"        }",
											"        if (order.hasOwnProperty('goodTilBlock')) {",
											"            pm.expect(order.goodTilBlock).to.be.a('string');",
											"        }",
											"",
											"        // Validate numeric fields that are string-encoded",
											"        pm.expect(parseFloat(order.size)).to.not.be.NaN;",
											"        pm.expect(parseFloat(order.totalFilled)).to.not.be.NaN;",
											"        pm.expect(parseFloat(order.price)).to.not.be.NaN;",
											"        pm.expect(parseInt(order.createdAtHeight)).to.not.be.NaN;",
											"        pm.expect(parseInt(order.updatedAtHeight)).to.not.be.NaN;",
											"",
											"        // Validate date format for updatedAt",
											"        const updatedAtDate = new Date(order.updatedAt);",
											"        pm.expect(updatedAtDate.toString()).not.to.equal(\"Invalid Date\");",
											"    });",
											"});",
											"",
											"// 5. Ensure no unexpected properties exist in each order (schema integrity check)",
											"pm.test(\"No unexpected properties in each order\", function () {",
											"    const orders = pm.response.json();",
											"",
											"    // Define the core expected fields",
											"    const expectedFields = [",
											"        \"id\",",
											"        \"subaccountId\",",
											"        \"clientId\",",
											"        \"clobPairId\",",
											"        \"side\",",
											"        \"size\",",
											"        \"totalFilled\",",
											"        \"price\",",
											"        \"type\",",
											"        \"status\",",
											"        \"timeInForce\",",
											"        \"reduceOnly\",",
											"        \"orderFlags\",",
											"        \"createdAtHeight\",",
											"        \"clientMetadata\",",
											"        \"updatedAt\",",
											"        \"updatedAtHeight\",",
											"        \"postOnly\",",
											"        \"ticker\",",
											"        \"subaccountNumber\",",
											"",
											"        // optional",
											"        \"goodTilBlockTime\",",
											"        \"goodTilBlock\"",
											"    ];",
											"",
											"    orders.forEach((order) => {",
											"        const keys = Object.keys(order);",
											"        keys.forEach((key) => {",
											"            pm.expect(expectedFields).to.include(key, `Unexpected property found: ${key}`);",
											"        });",
											"    });",
											"});",
											"",
											"// 6. Validate \"side\" field has only expected values",
											"pm.test(\"All orders have a valid 'side' field\", function () {",
											"    const validSides = [\"BUY\", \"SELL\"]; // adjust as needed",
											"    const orders = pm.response.json();",
											"",
											"    orders.forEach((order) => {",
											"        pm.expect(validSides).to.include(order.side, `Unexpected side: ${order.side}`);",
											"    });",
											"});",
											"",
											"// 7. Validate against a JSON schema",
											"pm.test(\"Response matches the expected JSON schema (optional)\", function () {",
											"    const schema = {",
											"        type: \"array\",",
											"        items: {",
											"            type: \"object\",",
											"            properties: {",
											"                id: { type: \"string\" },",
											"                subaccountId: { type: \"string\" },",
											"                clientId: { type: \"string\" },",
											"                clobPairId: { type: \"string\" },",
											"                side: { type: \"string\" },",
											"                size: { type: \"string\" },",
											"                totalFilled: { type: \"string\" },",
											"                price: { type: \"string\" },",
											"                type: { type: \"string\" },",
											"                status: { type: \"string\" },",
											"                timeInForce: { type: \"string\" },",
											"                reduceOnly: { type: \"boolean\" },",
											"                orderFlags: { type: \"string\" },",
											"                createdAtHeight: { type: \"string\" },",
											"                clientMetadata: { type: \"string\" },",
											"                updatedAt: { type: \"string\" },",
											"                updatedAtHeight: { type: \"string\" },",
											"                postOnly: { type: \"boolean\" },",
											"                ticker: { type: \"string\" },",
											"                subaccountNumber: { type: \"number\" },",
											"                goodTilBlockTime: { type: \"string\", optional: true },",
											"                goodTilBlock: { type: \"string\", optional: true }",
											"            },",
											"            required: [",
											"                \"id\",",
											"                \"subaccountId\",",
											"                \"clientId\",",
											"                \"clobPairId\",",
											"                \"side\",",
											"                \"size\",",
											"                \"totalFilled\",",
											"                \"price\",",
											"                \"type\",",
											"                \"status\",",
											"                \"timeInForce\",",
											"                \"reduceOnly\",",
											"                \"orderFlags\",",
											"                \"createdAtHeight\",",
											"                \"clientMetadata\",",
											"                \"updatedAt\",",
											"                \"updatedAtHeight\",",
											"                \"postOnly\",",
											"                \"ticker\",",
											"                \"subaccountNumber\"",
											"                // goodTilBlockTime / goodTilBlock are optional",
											"            ]",
											"        }",
											"    };",
											"    pm.response.to.have.jsonSchema(schema);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/orders/?address={{validdYdXAddress}}&subaccountNumber=0",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"orders",
										""
									],
									"query": [
										{
											"key": "address",
											"value": "{{validdYdXAddress}}"
										},
										{
											"key": "subaccountNumber",
											"value": "0"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "orders/listOrders INVALID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify response status code is 200",
											"pm.test(\"Response status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"// 2. Check response time (threshold set to 6000ms)",
											"pm.test(\"Response time is less than 6000ms\", function () {",
											"    pm.expect(pm.response.responseTime).to.be.below(6000);",
											"});",
											"",
											"// 3. Validate that the response is an array",
											"pm.test(\"Response is an array\", function () {",
											"    const responseData = pm.response.json();",
											"    pm.expect(responseData).to.be.an('array');",
											"});",
											"",
											"// 4. Ensure the array is empty",
											"pm.test(\"Array is empty (invalid address yields no orders)\", function () {",
											"    const responseData = pm.response.json();",
											"    pm.expect(responseData.length).to.eql(0, \"Expected an empty array for invalid address\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/orders/?address={{invaliddYdXAddress}}&subaccountNumber=0",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"orders",
										""
									],
									"query": [
										{
											"key": "address",
											"value": "{{invaliddYdXAddress}}"
										},
										{
											"key": "subaccountNumber",
											"value": "0"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "orders/getOrder VALID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify response status code is 200",
											"pm.test(\"Response status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"// 2. Check response time (threshold set to 6000ms)",
											"pm.test(\"Response time is less than 6000ms\", function () {",
											"    pm.expect(pm.response.responseTime).to.be.below(6000);",
											"});",
											"",
											"// 3. Validate the top-level structure is an object, not an array",
											"pm.test(\"Response is an object (represents a single order)\", function () {",
											"    const responseData = pm.response.json();",
											"    pm.expect(responseData).to.be.an(\"object\");",
											"});",
											"",
											"// 4. Validate the schema of the order",
											"pm.test(\"Order has correct schema\", function () {",
											"    const order = pm.response.json();",
											"",
											"    pm.expect(order).to.have.property(\"id\").that.is.a(\"string\");",
											"    pm.expect(order).to.have.property(\"subaccountId\").that.is.a(\"string\");",
											"    pm.expect(order).to.have.property(\"clientId\").that.is.a(\"string\");",
											"    pm.expect(order).to.have.property(\"clobPairId\").that.is.a(\"string\");",
											"    pm.expect(order).to.have.property(\"side\").that.is.a(\"string\");",
											"    pm.expect(order).to.have.property(\"size\").that.is.a(\"string\");",
											"    pm.expect(order).to.have.property(\"totalFilled\").that.is.a(\"string\");",
											"    pm.expect(order).to.have.property(\"price\").that.is.a(\"string\");",
											"    pm.expect(order).to.have.property(\"type\").that.is.a(\"string\");",
											"    pm.expect(order).to.have.property(\"status\").that.is.a(\"string\");",
											"    pm.expect(order).to.have.property(\"timeInForce\").that.is.a(\"string\");",
											"    pm.expect(order).to.have.property(\"reduceOnly\").that.is.a(\"boolean\");",
											"    pm.expect(order).to.have.property(\"orderFlags\").that.is.a(\"string\");",
											"    pm.expect(order).to.have.property(\"createdAtHeight\").that.is.a(\"string\");",
											"    pm.expect(order).to.have.property(\"clientMetadata\").that.is.a(\"string\");",
											"    pm.expect(order).to.have.property(\"updatedAt\").that.is.a(\"string\");",
											"    pm.expect(order).to.have.property(\"updatedAtHeight\").that.is.a(\"string\");",
											"    pm.expect(order).to.have.property(\"postOnly\").that.is.a(\"boolean\");",
											"    pm.expect(order).to.have.property(\"ticker\").that.is.a(\"string\");",
											"    pm.expect(order).to.have.property(\"subaccountNumber\").that.is.a(\"number\");",
											"",
											"    // Validate optional fields",
											"    if (order.hasOwnProperty(\"goodTilBlockTime\")) {",
											"        pm.expect(order.goodTilBlockTime).to.be.a(\"string\");",
											"        // Check it's a valid date",
											"        const goodTilBlockTimeDate = new Date(order.goodTilBlockTime);",
											"        pm.expect(goodTilBlockTimeDate.toString()).not.to.equal(\"Invalid Date\");",
											"    }",
											"    ",
											"    // Validate numeric fields that are string-encoded",
											"    pm.expect(parseFloat(order.size)).to.not.be.NaN;",
											"    pm.expect(parseFloat(order.totalFilled)).to.not.be.NaN;",
											"    pm.expect(parseFloat(order.price)).to.not.be.NaN;",
											"    pm.expect(parseInt(order.createdAtHeight)).to.not.be.NaN;",
											"    pm.expect(parseInt(order.updatedAtHeight)).to.not.be.NaN;",
											"",
											"    // Validate date format for updatedAt",
											"    const updatedAtDate = new Date(order.updatedAt);",
											"    pm.expect(updatedAtDate.toString()).not.to.equal(\"Invalid Date\");",
											"});",
											"",
											"// 5. Ensure no unexpected properties exist (schema integrity check)",
											"pm.test(\"No unexpected properties in the order\", function () {",
											"    const order = pm.response.json();",
											"    const expectedFields = [",
											"        \"id\",",
											"        \"subaccountId\",",
											"        \"clientId\",",
											"        \"clobPairId\",",
											"        \"side\",",
											"        \"size\",",
											"        \"totalFilled\",",
											"        \"price\",",
											"        \"type\",",
											"        \"status\",",
											"        \"timeInForce\",",
											"        \"reduceOnly\",",
											"        \"orderFlags\",",
											"        \"goodTilBlockTime\", // optional",
											"        \"createdAtHeight\",",
											"        \"clientMetadata\",",
											"        \"updatedAt\",",
											"        \"updatedAtHeight\",",
											"        \"postOnly\",",
											"        \"ticker\",",
											"        \"subaccountNumber\"",
											"    ];",
											"",
											"    Object.keys(order).forEach((key) => {",
											"        pm.expect(expectedFields).to.include(key, `Unexpected property found: ${key}`);",
											"    });",
											"});",
											"",
											"// 6. (Optional) Validate the 'side' field is within expected values",
											"pm.test(\"Side field is valid\", function () {",
											"    const validSides = [\"BUY\", \"SELL\"];",
											"    const order = pm.response.json();",
											"    pm.expect(validSides).to.include(order.side, `Invalid side: ${order.side}`);",
											"});",
											"",
											"// 7. (Optional) Validate the response against a JSON schema",
											"pm.test(\"Response matches expected JSON schema (optional)\", function () {",
											"    const schema = {",
											"        type: \"object\",",
											"        properties: {",
											"            id: { type: \"string\" },",
											"            subaccountId: { type: \"string\" },",
											"            clientId: { type: \"string\" },",
											"            clobPairId: { type: \"string\" },",
											"            side: { type: \"string\" },",
											"            size: { type: \"string\" },",
											"            totalFilled: { type: \"string\" },",
											"            price: { type: \"string\" },",
											"            type: { type: \"string\" },",
											"            status: { type: \"string\" },",
											"            timeInForce: { type: \"string\" },",
											"            reduceOnly: { type: \"boolean\" },",
											"            orderFlags: { type: \"string\" },",
											"            goodTilBlockTime: { type: \"string\", optional: true },",
											"            createdAtHeight: { type: \"string\" },",
											"            clientMetadata: { type: \"string\" },",
											"            updatedAt: { type: \"string\" },",
											"            updatedAtHeight: { type: \"string\" },",
											"            postOnly: { type: \"boolean\" },",
											"            ticker: { type: \"string\" },",
											"            subaccountNumber: { type: \"number\" }",
											"        },",
											"        required: [",
											"            \"id\",",
											"            \"subaccountId\",",
											"            \"clientId\",",
											"            \"clobPairId\",",
											"            \"side\",",
											"            \"size\",",
											"            \"totalFilled\",",
											"            \"price\",",
											"            \"type\",",
											"            \"status\",",
											"            \"timeInForce\",",
											"            \"reduceOnly\",",
											"            \"orderFlags\",",
											"            \"createdAtHeight\",",
											"            \"clientMetadata\",",
											"            \"updatedAt\",",
											"            \"updatedAtHeight\",",
											"            \"postOnly\",",
											"            \"ticker\",",
											"            \"subaccountNumber\"",
											"        ]",
											"    };",
											"    pm.response.to.have.jsonSchema(schema);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/orders/{{validOrderID}}",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"orders",
										"{{validOrderID}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "orders/getOrder INVALID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify response status code is 400",
											"pm.test(\"Response status code is 400 (Invalid Order ID)\", function () {",
											"    pm.response.to.have.status(400);",
											"});",
											"",
											"// 2. Check response time (threshold set to 6000ms)",
											"pm.test(\"Response time is less than 6000ms\", function () {",
											"    pm.expect(pm.response.responseTime).to.be.below(6000);",
											"});",
											"",
											"// 3. Ensure the response body has an 'errors' array",
											"pm.test(\"Response contains 'errors' array\", function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData).to.be.an('object');",
											"    pm.expect(jsonData).to.have.property('errors').that.is.an('array');",
											"});",
											"",
											"// 4. Check the structure of the first error object",
											"pm.test(\"Error object structure is valid\", function () {",
											"    const errors = pm.response.json().errors;",
											"    pm.expect(errors).to.have.lengthOf.at.least(1, \"There should be at least one error object\");",
											"",
											"    const firstError = errors[0];",
											"    pm.expect(firstError).to.have.property('value').that.is.a('string');",
											"    pm.expect(firstError).to.have.property('msg').that.is.a('string');",
											"    pm.expect(firstError).to.have.property('param').that.is.a('string');",
											"    pm.expect(firstError).to.have.property('location').that.is.a('string');",
											"    ",
											"    // Optional: Check specific values",
											"    pm.expect(firstError.value).to.eql(\"1\");",
											"    pm.expect(firstError.msg).to.include(\"Invalid value\");",
											"    pm.expect(firstError.param).to.eql(\"orderId\");",
											"    pm.expect(firstError.location).to.eql(\"params\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/orders/{{inValidOrderID}}",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"orders",
										"{{inValidOrderID}}"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "perpetualMarkets",
					"item": [
						{
							"name": "/perpetualMarkets/ListPerpetualMarkets",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify that the status code is 200",
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"// 2. Check that the response time is less than 6000ms",
											"pm.test(\"Response time is less than 6000ms\", function () {",
											"    pm.expect(pm.response.responseTime).to.be.below(6000);",
											"});",
											"",
											"// 3. Verify the top-level structure: response must be an object with a \"markets\" object property",
											"pm.test(\"Response has a 'markets' object\", function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData).to.be.an(\"object\");",
											"    pm.expect(jsonData).to.have.property(\"markets\");",
											"    pm.expect(jsonData.markets).to.be.an(\"object\");",
											"    pm.expect(Object.keys(jsonData.markets).length).to.be.above(0);",
											"});",
											"",
											"// 4. Validate each market entry’s schema",
											"pm.test(\"Each market entry has the expected properties and types\", function () {",
											"    const markets = pm.response.json().markets;",
											"    Object.keys(markets).forEach((marketKey) => {",
											"        const market = markets[marketKey];",
											"        pm.expect(market).to.be.an(\"object\");",
											"        pm.expect(market).to.have.property(\"clobPairId\").that.is.a(\"string\");",
											"        pm.expect(market).to.have.property(\"ticker\").that.is.a(\"string\");",
											"        pm.expect(market).to.have.property(\"status\").that.is.a(\"string\");",
											"        pm.expect(market).to.have.property(\"oraclePrice\").that.is.a(\"string\");",
											"        pm.expect(market).to.have.property(\"priceChange24H\").that.is.a(\"string\");",
											"        pm.expect(market).to.have.property(\"volume24H\").that.is.a(\"string\");",
											"        pm.expect(market).to.have.property(\"trades24H\").that.is.a(\"number\");",
											"        pm.expect(market).to.have.property(\"nextFundingRate\").that.is.a(\"string\");",
											"        pm.expect(market).to.have.property(\"initialMarginFraction\").that.is.a(\"string\");",
											"        pm.expect(market).to.have.property(\"maintenanceMarginFraction\").that.is.a(\"string\");",
											"        pm.expect(market).to.have.property(\"openInterest\").that.is.a(\"string\");",
											"        pm.expect(market).to.have.property(\"atomicResolution\").that.is.a(\"number\");",
											"        pm.expect(market).to.have.property(\"quantumConversionExponent\").that.is.a(\"number\");",
											"        pm.expect(market).to.have.property(\"tickSize\").that.is.a(\"string\");",
											"        pm.expect(market).to.have.property(\"stepSize\").that.is.a(\"string\");",
											"        pm.expect(market).to.have.property(\"stepBaseQuantums\").that.is.a(\"number\");",
											"        pm.expect(market).to.have.property(\"subticksPerTick\").that.is.a(\"number\");",
											"        pm.expect(market).to.have.property(\"marketType\").that.is.a(\"string\");",
											"        pm.expect(market).to.have.property(\"openInterestLowerCap\").that.is.a(\"string\");",
											"        pm.expect(market).to.have.property(\"openInterestUpperCap\").that.is.a(\"string\");",
											"        pm.expect(market).to.have.property(\"baseOpenInterest\").that.is.a(\"string\");",
											"        // defaultFundingRate1H may sometimes be null (if applicable) so we allow string or null",
											"        pm.expect(market).to.have.property(\"defaultFundingRate1H\").that.satisfies(val => (typeof val === \"string\" || val === null));",
											"    });",
											"});",
											"",
											"// 5. Validate the response against a JSON schema",
											"pm.test(\"Response matches the expected JSON schema\", function () {",
											"    const schema = {",
											"        type: \"object\",",
											"        properties: {",
											"            markets: {",
											"                type: \"object\",",
											"                patternProperties: {",
											"                    \".*\": {",
											"                        type: \"object\",",
											"                        properties: {",
											"                            clobPairId: { type: \"string\" },",
											"                            ticker: { type: \"string\" },",
											"                            status: { type: \"string\" },",
											"                            oraclePrice: { type: \"string\" },",
											"                            priceChange24H: { type: \"string\" },",
											"                            volume24H: { type: \"string\" },",
											"                            trades24H: { type: \"number\" },",
											"                            nextFundingRate: { type: \"string\" },",
											"                            initialMarginFraction: { type: \"string\" },",
											"                            maintenanceMarginFraction: { type: \"string\" },",
											"                            openInterest: { type: \"string\" },",
											"                            atomicResolution: { type: \"number\" },",
											"                            quantumConversionExponent: { type: \"number\" },",
											"                            tickSize: { type: \"string\" },",
											"                            stepSize: { type: \"string\" },",
											"                            stepBaseQuantums: { type: \"number\" },",
											"                            subticksPerTick: { type: \"number\" },",
											"                            marketType: { type: \"string\" },",
											"                            openInterestLowerCap: { type: \"string\" },",
											"                            openInterestUpperCap: { type: \"string\" },",
											"                            baseOpenInterest: { type: \"string\" },",
											"                            defaultFundingRate1H: { type: [\"string\", \"null\"] }",
											"                        },",
											"                        required: [",
											"                            \"clobPairId\",",
											"                            \"ticker\",",
											"                            \"status\",",
											"                            \"oraclePrice\",",
											"                            \"priceChange24H\",",
											"                            \"volume24H\",",
											"                            \"trades24H\",",
											"                            \"nextFundingRate\",",
											"                            \"initialMarginFraction\",",
											"                            \"maintenanceMarginFraction\",",
											"                            \"openInterest\",",
											"                            \"atomicResolution\",",
											"                            \"quantumConversionExponent\",",
											"                            \"tickSize\",",
											"                            \"stepSize\",",
											"                            \"stepBaseQuantums\",",
											"                            \"subticksPerTick\",",
											"                            \"marketType\",",
											"                            \"openInterestLowerCap\",",
											"                            \"openInterestUpperCap\",",
											"                            \"baseOpenInterest\",",
											"                            \"defaultFundingRate1H\"",
											"                        ],",
											"                        additionalProperties: false",
											"                    }",
											"                },",
											"                additionalProperties: false",
											"            }",
											"        },",
											"        required: [\"markets\"],",
											"        additionalProperties: false",
											"    };",
											"",
											"    pm.response.to.have.jsonSchema(schema);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/perpetualMarkets/",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"perpetualMarkets",
										""
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "perpetualPositions",
					"item": [
						{
							"name": "getPositions VALID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify the response status code is 200",
											"pm.test(\"Response status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"// 2. Check that the response time is less than 6000ms",
											"pm.test(\"Response time is less than 6000ms\", function () {",
											"    pm.expect(pm.response.responseTime).to.be.below(6000);",
											"});",
											"",
											"// 3. Validate top-level structure: Ensure it's an object with a \"positions\" array",
											"pm.test(\"Response contains a 'positions' array\", function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData).to.be.an(\"object\");",
											"    pm.expect(jsonData).to.have.property(\"positions\").that.is.an(\"array\");",
											"});",
											"",
											"// 4. Ensure 'positions' is not empty, then validate each position's structure",
											"pm.test(\"Positions array is not empty and valid\", function () {",
											"    const { positions } = pm.response.json();",
											"",
											"    // *Fail* if no positions returned:",
											"    pm.expect(positions.length).to.be.above(",
											"        0,",
											"        \"Expected at least one position, but got none.\"",
											"    );",
											"",
											"    // If we get here, positions.length > 0, so validate each item:",
											"    positions.forEach((pos, index) => {",
											"        pm.expect(pos).to.be.an(\"object\");",
											"",
											"        // Required properties and their types",
											"        pm.expect(pos).to.have.property(\"market\").that.is.a(\"string\");",
											"        pm.expect(pos).to.have.property(\"status\").that.is.a(\"string\");",
											"        pm.expect(pos).to.have.property(\"side\").that.is.a(\"string\");",
											"        pm.expect(pos).to.have.property(\"size\").that.is.a(\"string\");",
											"        pm.expect(pos).to.have.property(\"maxSize\").that.is.a(\"string\");",
											"        pm.expect(pos).to.have.property(\"entryPrice\").that.is.a(\"string\");",
											"        // exitPrice can be null or string",
											"        pm.expect(pos).to.have.property(\"exitPrice\");",
											"        pm.expect(",
											"            pos.exitPrice === null || typeof pos.exitPrice === \"string\",",
											"            `exitPrice must be null or a string (index ${index})`",
											"        ).to.be.true;",
											"        pm.expect(pos).to.have.property(\"realizedPnl\").that.is.a(\"string\");",
											"        pm.expect(pos).to.have.property(\"unrealizedPnl\").that.is.a(\"string\");",
											"        pm.expect(pos).to.have.property(\"createdAt\").that.is.a(\"string\");",
											"        pm.expect(pos).to.have.property(\"createdAtHeight\").that.is.a(\"string\");",
											"        // closedAt can be null or string",
											"        pm.expect(pos).to.have.property(\"closedAt\");",
											"        pm.expect(",
											"            pos.closedAt === null || typeof pos.closedAt === \"string\",",
											"            `closedAt must be null or a string (index ${index})`",
											"        ).to.be.true;",
											"        pm.expect(pos).to.have.property(\"sumOpen\").that.is.a(\"string\");",
											"        pm.expect(pos).to.have.property(\"sumClose\").that.is.a(\"string\");",
											"        pm.expect(pos).to.have.property(\"netFunding\").that.is.a(\"string\");",
											"        pm.expect(pos).to.have.property(\"subaccountNumber\").that.is.a(\"number\");",
											"",
											"        // Validate numeric fields that are string-encoded",
											"        pm.expect(parseFloat(pos.size)).to.not.be.NaN;",
											"        pm.expect(parseFloat(pos.maxSize)).to.not.be.NaN;",
											"        pm.expect(parseFloat(pos.entryPrice)).to.not.be.NaN;",
											"        if (pos.exitPrice !== null) {",
											"            pm.expect(parseFloat(pos.exitPrice)).to.not.be.NaN;",
											"        }",
											"        pm.expect(parseFloat(pos.realizedPnl)).to.not.be.NaN;",
											"        pm.expect(parseFloat(pos.unrealizedPnl)).to.not.be.NaN;",
											"        pm.expect(parseFloat(pos.sumOpen)).to.not.be.NaN;",
											"        pm.expect(parseFloat(pos.sumClose)).to.not.be.NaN;",
											"        pm.expect(parseFloat(pos.netFunding)).to.not.be.NaN;",
											"        pm.expect(parseInt(pos.createdAtHeight)).to.not.be.NaN;",
											"",
											"        // Validate createdAt is a valid date",
											"        const createdDate = new Date(pos.createdAt);",
											"        pm.expect(createdDate.toString()).not.to.equal(\"Invalid Date\");",
											"",
											"        // If closedAt is not null, validate it's a valid date",
											"        if (pos.closedAt) {",
											"            const closedDate = new Date(pos.closedAt);",
											"            pm.expect(closedDate.toString()).not.to.equal(\"Invalid Date\");",
											"        }",
											"    });",
											"});",
											"",
											"// 5. Validate enumerated fields where possible",
											"pm.test(\"Check 'status' and 'side' fields are within expected enumerations\", function () {",
											"    const validStatus = [\"OPEN\", \"CLOSED\"];",
											"    const validSides = [\"LONG\", \"SHORT\"];",
											"",
											"    const { positions } = pm.response.json();",
											"    // Only checking enumerations if we actually have positions",
											"    if (positions.length > 0) {",
											"        positions.forEach((pos) => {",
											"            pm.expect(validStatus).to.include(",
											"                pos.status,",
											"                `Unexpected status: ${pos.status}`",
											"            );",
											"            pm.expect(validSides).to.include(",
											"                pos.side,",
											"                `Unexpected side: ${pos.side}`",
											"            );",
											"        });",
											"    }",
											"});",
											"",
											"// 6. (Optional) Validate the response against a JSON schema",
											"pm.test(\"Response matches expected JSON schema\", function () {",
											"    const schema = {",
											"        type: \"object\",",
											"        properties: {",
											"            positions: {",
											"                type: \"array\",",
											"                items: {",
											"                    type: \"object\",",
											"                    properties: {",
											"                        market: { type: \"string\" },",
											"                        status: { type: \"string\", enum: [\"OPEN\", \"CLOSED\"] },",
											"                        side: { type: \"string\", enum: [\"LONG\", \"SHORT\"] },",
											"                        size: { type: \"string\" },",
											"                        maxSize: { type: \"string\" },",
											"                        entryPrice: { type: \"string\" },",
											"                        exitPrice: { type: [\"string\", \"null\"] },",
											"                        realizedPnl: { type: \"string\" },",
											"                        unrealizedPnl: { type: \"string\" },",
											"                        createdAt: { type: \"string\", format: \"date-time\" },",
											"                        createdAtHeight: { type: \"string\" },",
											"                        closedAt: { type: [\"string\", \"null\"] },",
											"                        sumOpen: { type: \"string\" },",
											"                        sumClose: { type: \"string\" },",
											"                        netFunding: { type: \"string\" },",
											"                        subaccountNumber: { type: \"number\" }",
											"                    },",
											"                    required: [",
											"                        \"market\",",
											"                        \"status\",",
											"                        \"side\",",
											"                        \"size\",",
											"                        \"maxSize\",",
											"                        \"entryPrice\",",
											"                        \"exitPrice\",",
											"                        \"realizedPnl\",",
											"                        \"unrealizedPnl\",",
											"                        \"createdAt\",",
											"                        \"createdAtHeight\",",
											"                        \"closedAt\",",
											"                        \"sumOpen\",",
											"                        \"sumClose\",",
											"                        \"netFunding\",",
											"                        \"subaccountNumber\"",
											"                    ]",
											"                }",
											"            }",
											"        },",
											"        required: [\"positions\"]",
											"    };",
											"    pm.response.to.have.jsonSchema(schema);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/perpetualPositions?address={{validdYdXAddress}}&subaccountNumber=0",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"perpetualPositions"
									],
									"query": [
										{
											"key": "address",
											"value": "{{validdYdXAddress}}"
										},
										{
											"key": "subaccountNumber",
											"value": "0"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "getPositions INVALID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify the response status code is 200",
											"pm.test(\"Response status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"// 2. Check that the response time is less than 6000ms",
											"pm.test(\"Response time is less than 6000ms\", function () {",
											"    pm.expect(pm.response.responseTime).to.be.below(6000);",
											"});",
											"",
											"// 3. Validate top-level structure: Ensure it's an object with a \"positions\" array",
											"pm.test(\"Response contains a 'positions' array\", function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData).to.be.an(\"object\");",
											"    pm.expect(jsonData).to.have.property(\"positions\").that.is.an(\"array\");",
											"});",
											"",
											"// 4. Verify that the 'positions' array is empty for an invalid address",
											"pm.test(\"'positions' array is empty for invalid address\", function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData.positions.length).to.eql(0, \"Expected no positions for invalid address\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/perpetualPositions?address={{invaliddYdXAddress}}&subaccountNumber=0",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"perpetualPositions"
									],
									"query": [
										{
											"key": "address",
											"value": "{{invaliddYdXAddress}}"
										},
										{
											"key": "subaccountNumber",
											"value": "0"
										}
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "sparklines",
					"item": [
						{
							"name": "sparklines",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify that the status code is 200",
											"pm.test(\"Status code is 200\", function () {",
											"  pm.response.to.have.status(200);",
											"});",
											"",
											"// 2. Verify that the response time is less than 6000ms",
											"pm.test(\"Response time is less than 6000ms\", function () {",
											"  pm.expect(pm.response.responseTime).to.be.below(6000);",
											"});",
											"",
											"// 3. Verify that the response is an object and that each property is an array",
											"pm.test(\"Response is an object with sparkline arrays\", function () {",
											"  const jsonData = pm.response.json();",
											"  pm.expect(jsonData).to.be.an(\"object\");",
											"  Object.keys(jsonData).forEach((key) => {",
											"    pm.expect(jsonData[key]).to.be.an(\"array\");",
											"  });",
											"});",
											"",
											"// 4. Validate that each sparkline array contains only string values (which represent numbers)",
											"pm.test(\"Each sparkline array contains string values\", function () {",
											"  const data = pm.response.json();",
											"  Object.keys(data).forEach((key) => {",
											"    data[key].forEach((value) => {",
											"      pm.expect(value).to.be.a(\"string\");",
											"      // Optionally, verify that the string can be converted to a valid number:",
											"      pm.expect(parseFloat(value)).to.be.a(\"number\");",
											"    });",
											"  });",
											"});",
											"",
											"// 5. Validate the response against a JSON schema",
											"pm.test(\"Response matches the expected JSON schema\", function () {",
											"  const schema = {",
											"    type: \"object\",",
											"    patternProperties: {",
											"      \".*\": {",
											"        type: \"array\",",
											"        items: { type: \"string\" }",
											"      }",
											"    },",
											"    additionalProperties: false",
											"  };",
											"  pm.response.to.have.jsonSchema(schema);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/sparklines/?timePeriod=ONE_DAY",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"sparklines",
										""
									],
									"query": [
										{
											"key": "timePeriod",
											"value": "ONE_DAY"
										}
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "trader",
					"item": [
						{
							"name": "search/ VALID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify response status code is 200",
											"pm.test(\"Response status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"// 2. Check response time (threshold set to 6000ms)",
											"pm.test(\"Response time is less than 6000ms\", function () {",
											"    pm.expect(pm.response.responseTime).to.be.below(6000);",
											"});",
											"",
											"// 3. Validate top-level structure has a 'result' object",
											"pm.test(\"Response has a 'result' object\", function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData).to.be.an('object');",
											"    pm.expect(jsonData).to.have.property('result').that.is.an('object');",
											"});",
											"",
											"// 4. Validate fields within 'result'",
											"pm.test(\"Result object has correct fields\", function () {",
											"    const { result } = pm.response.json();",
											"",
											"    pm.expect(result).to.have.property('address').that.is.a('string');",
											"    pm.expect(result).to.have.property('subaccountNumber').that.is.a('number');",
											"    pm.expect(result).to.have.property('subaccountId').that.is.a('string');",
											"    pm.expect(result).to.have.property('username').that.is.a('string');",
											"",
											"    // (Optional) Validate address format if you need a rough dydx address check",
											"    const dydxAddressPattern = /^dydx1[a-z0-9]{38}$/;",
											"    pm.expect(result.address).to.match(dydxAddressPattern, \"Invalid dydx address format\");",
											"});",
											"",
											"// 5. Ensure no unexpected properties exist",
											"pm.test(\"No unexpected properties in 'result'\", function () {",
											"    const expectedKeys = [",
											"        \"address\",",
											"        \"subaccountNumber\",",
											"        \"subaccountId\",",
											"        \"username\"",
											"    ];",
											"    const { result } = pm.response.json();",
											"    ",
											"    Object.keys(result).forEach((key) => {",
											"        pm.expect(expectedKeys).to.include(key, `Unexpected property found: ${key}`);",
											"    });",
											"});",
											"",
											"// 6. (Optional) Validate the structure against a JSON schema",
											"pm.test(\"Response matches expected JSON schema (optional)\", function () {",
											"    const schema = {",
											"        \"type\": \"object\",",
											"        \"properties\": {",
											"            \"result\": {",
											"                \"type\": \"object\",",
											"                \"properties\": {",
											"                    \"address\": { \"type\": \"string\" },",
											"                    \"subaccountNumber\": { \"type\": \"number\" },",
											"                    \"subaccountId\": { \"type\": \"string\" },",
											"                    \"username\": { \"type\": \"string\" }",
											"                },",
											"                \"required\": [\"address\", \"subaccountNumber\", \"subaccountId\", \"username\"]",
											"            }",
											"        },",
											"        \"required\": [\"result\"]",
											"    };",
											"    pm.response.to.have.jsonSchema(schema);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/trader/search?searchParam={{validdYdXAddress}}",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"trader",
										"search"
									],
									"query": [
										{
											"key": "searchParam",
											"value": "{{validdYdXAddress}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "search/ INVALID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify response status code (e.g., 404 or 400)",
											"pm.test(\"Response status code indicates 'Not Found' or 'Bad Request'\", function () {",
											"    pm.response.to.have.status(404);",
											"});",
											"",
											"// 2. Check response time (threshold set to 6000ms)",
											"pm.test(\"Response time is less than 6000ms\", function () {",
											"    pm.expect(pm.response.responseTime).to.be.below(6000);",
											"});",
											"",
											"// 3. Ensure the response has an 'errors' array",
											"pm.test(\"Response contains 'errors' array\", function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData).to.be.an('object');",
											"    pm.expect(jsonData).to.have.property('errors').that.is.an('array').with.lengthOf.at.least(1);",
											"});",
											"",
											"// 4. Validate the error object structure and message",
											"pm.test(\"Error object has valid 'msg' property\", function () {",
											"    const errors = pm.response.json().errors;",
											"    const firstError = errors[0];",
											"",
											"    pm.expect(firstError).to.have.property('msg').that.is.a('string');",
											"    pm.expect(firstError.msg).to.include(\"Subaccount not found\", \"Error message should indicate subaccount not found\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/trader/search?searchParam={{invaliddYdXAddress}}",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"trader",
										"search"
									],
									"query": [
										{
											"key": "searchParam",
											"value": "{{invaliddYdXAddress}}"
										}
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "time",
					"item": [
						{
							"name": "getTime",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify response status code is 200",
											"pm.test(\"Response status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"// 2. Check response time (threshold set to 6000ms)",
											"pm.test(\"Response time is less than 6000ms\", function () {",
											"    pm.expect(pm.response.responseTime).to.be.below(6000);",
											"});",
											"",
											"// 3. Validate top-level structure and types",
											"pm.test(\"Response has 'iso' (string) and 'epoch' (number)\", function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData).to.be.an('object');",
											"    pm.expect(jsonData).to.have.property('iso').that.is.a('string');",
											"    pm.expect(jsonData).to.have.property('epoch');",
											"",
											"    // Ensure 'epoch' is a valid number",
											"    pm.expect(parseFloat(jsonData.epoch)).to.not.be.NaN;",
											"});",
											"",
											"// 4. Basic validation of the ISO time format (ensuring it parses to a valid date)",
											"pm.test(\"ISO string is a valid date\", function () {",
											"    const jsonData = pm.response.json();",
											"    const date = new Date(jsonData.iso);",
											"    pm.expect(date.toString()).not.to.equal(\"Invalid Date\");",
											"});",
											"",
											"// 5. Validate the response against a JSON schema",
											"pm.test(\"Response matches expected schema\", function () {",
											"    const schema = {",
											"        \"type\": \"object\",",
											"        \"properties\": {",
											"            \"iso\": { \"type\": \"string\" },",
											"            \"epoch\": { \"type\": \"number\" }",
											"        },",
											"        \"required\": [\"iso\", \"epoch\"]",
											"    };",
											"    pm.response.to.have.jsonSchema(schema);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/time",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"time"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "trades",
					"item": [
						{
							"name": "trades/perptualMarket/ VALID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify response status code is 200",
											"pm.test(\"Response status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"// 2. Check response time (threshold set to 6000ms)",
											"pm.test(\"Response time is less than 6000ms\", function () {",
											"    pm.expect(pm.response.responseTime).to.be.below(6000);",
											"});",
											"",
											"// 3. Validate that the response has a \"trades\" array",
											"pm.test(\"Response has 'trades' array\", function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData).to.be.an('object');",
											"    pm.expect(jsonData).to.have.property('trades').that.is.an('array');",
											"});",
											"",
											"// 4. Validate the schema of each trade",
											"pm.test(\"Validate trade schema for each element in 'trades'\", function () {",
											"    const jsonData = pm.response.json();",
											"    const trades = jsonData.trades;",
											"    ",
											"    // Basic checks: ensure each trade object has the expected properties",
											"    trades.forEach(trade => {",
											"        pm.expect(trade).to.be.an('object');",
											"        pm.expect(trade).to.have.property('id').that.is.a('string');",
											"        pm.expect(trade).to.have.property('side').that.is.a('string');",
											"        pm.expect(trade).to.have.property('size').that.is.a('string');",
											"        pm.expect(trade).to.have.property('price').that.is.a('string');",
											"        pm.expect(trade).to.have.property('type').that.is.a('string');",
											"        pm.expect(trade).to.have.property('createdAt').that.is.a('string');",
											"        pm.expect(trade).to.have.property('createdAtHeight').that.is.a('string');",
											"",
											"        // Additional numeric validations",
											"        pm.expect(parseFloat(trade.size)).to.not.be.NaN;",
											"        pm.expect(parseFloat(trade.price)).to.not.be.NaN;",
											"        ",
											"        // Validate that createdAt is a valid date",
											"        const date = new Date(trade.createdAt);",
											"        pm.expect(date.toString()).not.to.equal(\"Invalid Date\");",
											"    });",
											"});",
											"",
											"// 5. Ensure no unexpected properties exist in each trade (schema integrity check)",
											"pm.test(\"No unexpected properties in trade schema\", function () {",
											"    const trades = pm.response.json().trades;",
											"    const expectedKeys = [",
											"        \"id\",",
											"        \"side\",",
											"        \"size\",",
											"        \"price\",",
											"        \"type\",",
											"        \"createdAt\",",
											"        \"createdAtHeight\"",
											"    ];",
											"",
											"    trades.forEach((trade) => {",
											"        const keys = Object.keys(trade);",
											"        keys.forEach(key => {",
											"            pm.expect(expectedKeys).to.include(key, `Unexpected property found: ${key}`);",
											"        });",
											"    });",
											"});",
											"",
											"// 6. Check if all trades have valid \"side\" (SELL or BUY, for example)",
											"pm.test(\"All trades have a valid side (BUY or SELL)\", function () {",
											"    const trades = pm.response.json().trades;",
											"    trades.forEach((trade) => {",
											"        pm.expect([\"BUY\", \"SELL\"]).to.include(trade.side, `Invalid side: ${trade.side}`);",
											"    });",
											"});",
											"",
											"// 7. Optional: Check that the trades are returned in descending chronological order",
											"pm.test(\"Trades are in descending chronological order (optional)\", function () {",
											"    const trades = pm.response.json().trades;",
											"    for (let i = 0; i < trades.length - 1; i++) {",
											"        const current = new Date(trades[i].createdAt).getTime();",
											"        const next = new Date(trades[i + 1].createdAt).getTime();",
											"        pm.expect(current).to.be.at.least(next, `Trade at index ${i} is older than index ${i+1}`);",
											"    }",
											"});",
											"",
											"// 8. Validate JSON schema (optional)",
											"pm.test(\"Response matches expected schema (optional)\", function () {",
											"    const schema = {",
											"        \"type\": \"object\",",
											"        \"properties\": {",
											"            \"trades\": {",
											"                \"type\": \"array\",",
											"                \"items\": {",
											"                    \"type\": \"object\",",
											"                    \"properties\": {",
											"                        \"id\": { \"type\": \"string\" },",
											"                        \"side\": { \"type\": \"string\" },",
											"                        \"size\": { \"type\": \"string\" },",
											"                        \"price\": { \"type\": \"string\" },",
											"                        \"type\": { \"type\": \"string\" },",
											"                        \"createdAt\": { \"type\": \"string\" },",
											"                        \"createdAtHeight\": { \"type\": \"string\" }",
											"                    },",
											"                    \"required\": [",
											"                        \"id\",",
											"                        \"side\",",
											"                        \"size\",",
											"                        \"price\",",
											"                        \"type\",",
											"                        \"createdAt\",",
											"                        \"createdAtHeight\"",
											"                    ]",
											"                }",
											"            }",
											"        },",
											"        \"required\": [\"trades\"]",
											"    };",
											"    pm.response.to.have.jsonSchema(schema);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/trades/perpetualMarket/{{ticker}}",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"trades",
										"perpetualMarket",
										"{{ticker}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "trades/perptualMarket/ INVALID",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify response status code (usually 400 if it's a validation error)",
											"pm.test(\"Response status code is 400 (Invalid Ticker)\", function () {",
											"    pm.response.to.have.status(400);",
											"});",
											"",
											"// 2. Ensure the response body has an 'errors' array",
											"pm.test(\"Response contains 'errors' array\", function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData).to.be.an('object');",
											"    pm.expect(jsonData).to.have.property('errors').that.is.an('array');",
											"});",
											"",
											"// 3. Check the structure of the error object",
											"pm.test(\"Error object structure is valid\", function () {",
											"    const errors = pm.response.json().errors;",
											"    pm.expect(errors).to.have.lengthOf.at.least(1, \"There should be at least one error object\");",
											"",
											"    const firstError = errors[0];",
											"    pm.expect(firstError).to.have.property('value').that.is.a('string');",
											"    pm.expect(firstError).to.have.property('msg').that.is.a('string');",
											"    pm.expect(firstError).to.have.property('param').that.is.a('string');",
											"    pm.expect(firstError).to.have.property('location').that.is.a('string');",
											"",
											"    // Optional: Check specific values if you want strict matching",
											"    pm.expect(firstError.value).to.eql(\"!!!-!!!\");",
											"    pm.expect(firstError.msg).to.include(\"must be a valid ticker\");",
											"    pm.expect(firstError.param).to.eql(\"ticker\");",
											"    pm.expect(firstError.location).to.eql(\"params\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/trades/perpetualMarket/{{invalidTicker}}",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"trades",
										"perpetualMarket",
										"{{invalidTicker}}"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "transfers",
					"item": [
						{
							"name": "getTransfers",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify response status code is 200",
											"pm.test(\"Response status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"// 2. Check response time (threshold set to 6000ms)",
											"pm.test(\"Response time is less than 6000ms\", function () {",
											"    pm.expect(pm.response.responseTime).to.be.below(6000);",
											"});",
											"",
											"// 3. Validate that the response has a \"transfers\" array",
											"pm.test(\"Response has 'transfers' array\", function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData).to.be.an(\"object\");",
											"    pm.expect(jsonData).to.have.property(\"transfers\").that.is.an(\"array\");",
											"});",
											"",
											"// 4. Validate the schema of each transfer",
											"pm.test(\"Validate each transfer object in 'transfers' array\", function () {",
											"    const { transfers } = pm.response.json();",
											"",
											"    // Basic checks: ensure each object has the expected properties",
											"    transfers.forEach((transfer) => {",
											"        pm.expect(transfer).to.be.an(\"object\");",
											"        pm.expect(transfer).to.have.property(\"id\").that.is.a(\"string\");",
											"        pm.expect(transfer).to.have.property(\"sender\").that.is.an(\"object\");",
											"        pm.expect(transfer).to.have.property(\"recipient\").that.is.an(\"object\");",
											"        pm.expect(transfer).to.have.property(\"size\").that.is.a(\"string\");",
											"        pm.expect(transfer).to.have.property(\"createdAt\").that.is.a(\"string\");",
											"        pm.expect(transfer).to.have.property(\"createdAtHeight\").that.is.a(\"string\");",
											"        pm.expect(transfer).to.have.property(\"symbol\").that.is.a(\"string\");",
											"        pm.expect(transfer).to.have.property(\"type\").that.is.a(\"string\");",
											"        pm.expect(transfer).to.have.property(\"transactionHash\").that.is.a(\"string\");",
											"",
											"        // Validate numeric fields",
											"        pm.expect(parseFloat(transfer.size)).to.not.be.NaN;",
											"        pm.expect(parseInt(transfer.createdAtHeight)).to.not.be.NaN;",
											"",
											"        // Validate date format for createdAt",
											"        const date = new Date(transfer.createdAt);",
											"        pm.expect(date.toString()).not.to.equal(\"Invalid Date\");",
											"",
											"        // Validate sender structure",
											"        pm.expect(transfer.sender).to.have.property(\"address\").that.is.a(\"string\");",
											"        pm.expect(transfer.sender).to.have.property(\"subaccountNumber\").that.is.a(\"number\");",
											"",
											"        // Validate recipient structure",
											"        pm.expect(transfer.recipient).to.have.property(\"address\").that.is.a(\"string\");",
											"        pm.expect(transfer.recipient).to.have.property(\"subaccountNumber\").that.is.a(\"number\");",
											"    });",
											"});",
											"",
											"// 5. Ensure no unexpected properties exist in each transfer object (schema integrity check)",
											"pm.test(\"No unexpected properties in 'transfers' objects\", function () {",
											"    const { transfers } = pm.response.json();",
											"    const expectedKeys = [",
											"        \"id\",",
											"        \"sender\",",
											"        \"recipient\",",
											"        \"size\",",
											"        \"createdAt\",",
											"        \"createdAtHeight\",",
											"        \"symbol\",",
											"        \"type\",",
											"        \"transactionHash\"",
											"    ];",
											"",
											"    transfers.forEach((transfer) => {",
											"        const keys = Object.keys(transfer);",
											"        keys.forEach((key) => {",
											"            pm.expect(expectedKeys).to.include(key, `Unexpected property found: ${key}`);",
											"        });",
											"    });",
											"});",
											"",
											"// 6. Ensure sender and recipient addresses are valid dYdX format (basic regex check) [Optional]",
											"pm.test(\"All sender/recipient addresses have a valid dydx address format\", function () {",
											"    const dydxAddressPattern = /^dydx1[a-z0-9]{38}$/; // Basic pattern example",
											"    const { transfers } = pm.response.json();",
											"",
											"    transfers.forEach((transfer) => {",
											"        pm.expect(transfer.sender.address).to.match(dydxAddressPattern, \"Invalid sender address format\");",
											"        pm.expect(transfer.recipient.address).to.match(dydxAddressPattern, \"Invalid recipient address format\");",
											"    });",
											"});",
											"",
											"// 7. (Optional) Validate the 'type' field has expected enum values (e.g., TRANSFER_IN, TRANSFER_OUT)",
											"pm.test(\"All transfers have a valid 'type' field\", function () {",
											"    const validTypes = [\"TRANSFER_IN\", \"TRANSFER_OUT\"];",
											"    const { transfers } = pm.response.json();",
											"",
											"    transfers.forEach((transfer) => {",
											"        pm.expect(validTypes).to.include(transfer.type, `Unexpected type: ${transfer.type}`);",
											"    });",
											"});",
											"",
											"// 8. (Optional) Validate the response against a JSON schema",
											"pm.test(\"Response matches expected JSON schema (optional)\", function () {",
											"    const schema = {",
											"        type: \"object\",",
											"        properties: {",
											"            transfers: {",
											"                type: \"array\",",
											"                items: {",
											"                    type: \"object\",",
											"                    properties: {",
											"                        id: { type: \"string\" },",
											"                        sender: {",
											"                            type: \"object\",",
											"                            properties: {",
											"                                address: { type: \"string\" },",
											"                                subaccountNumber: { type: \"number\" }",
											"                            },",
											"                            required: [\"address\", \"subaccountNumber\"]",
											"                        },",
											"                        recipient: {",
											"                            type: \"object\",",
											"                            properties: {",
											"                                address: { type: \"string\" },",
											"                                subaccountNumber: { type: \"number\" }",
											"                            },",
											"                            required: [\"address\", \"subaccountNumber\"]",
											"                        },",
											"                        size: { type: \"string\" },",
											"                        createdAt: { type: \"string\" },",
											"                        createdAtHeight: { type: \"string\" },",
											"                        symbol: { type: \"string\" },",
											"                        type: { type: \"string\" },",
											"                        transactionHash: { type: \"string\" }",
											"                    },",
											"                    required: [",
											"                        \"id\",",
											"                        \"sender\",",
											"                        \"recipient\",",
											"                        \"size\",",
											"                        \"createdAt\",",
											"                        \"createdAtHeight\",",
											"                        \"symbol\",",
											"                        \"type\",",
											"                        \"transactionHash\"",
											"                    ]",
											"                }",
											"            }",
											"        },",
											"        required: [\"transfers\"]",
											"    };",
											"",
											"    pm.response.to.have.jsonSchema(schema);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/transfers?address={{validdYdXAddress}}&subaccountNumber=0",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"transfers"
									],
									"query": [
										{
											"key": "address",
											"value": "{{validdYdXAddress}}"
										},
										{
											"key": "subaccountNumber",
											"value": "0"
										}
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "vault",
					"item": [
						{
							"name": "v1/megavault/historicalPnl",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify response status code is 200",
											"pm.test(\"Response status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"// 2. Check that the response time is below 6000ms",
											"pm.test(\"Response time is less than 6000ms\", function () {",
											"    pm.expect(pm.response.responseTime).to.be.below(6000);",
											"});",
											"",
											"// 3. Validate the top-level structure",
											"pm.test(\"Response contains a 'megavaultPnl' array\", function () {",
											"    const responseJson = pm.response.json();",
											"    pm.expect(responseJson).to.be.an(\"object\");",
											"    pm.expect(responseJson).to.have.property(\"megavaultPnl\").that.is.an(\"array\");",
											"});",
											"",
											"// 4. Ensure `megavaultPnl` is not empty",
											"pm.test(\"'megavaultPnl' array is not empty\", function () {",
											"    const { megavaultPnl } = pm.response.json();",
											"    pm.expect(megavaultPnl.length).to.be.above(",
											"        0,",
											"        \"Expected at least one historicalPnl record, but got none.\"",
											"    );",
											"});",
											"",
											"// 5. Validate each record's structure",
											"pm.test(\"Validate structure of each record in 'megavaultPnl'\", function () {",
											"    const { megavaultPnl } = pm.response.json();",
											"    ",
											"    megavaultPnl.forEach((record, index) => {",
											"        pm.expect(record).to.be.an(\"object\");",
											"",
											"        // Required properties",
											"        pm.expect(record).to.have.property(\"id\").that.is.a(\"string\");",
											"        pm.expect(record).to.have.property(\"subaccountId\").that.is.a(\"string\");",
											"        pm.expect(record).to.have.property(\"equity\").that.is.a(\"string\");",
											"        pm.expect(record).to.have.property(\"totalPnl\").that.is.a(\"string\");",
											"        pm.expect(record).to.have.property(\"netTransfers\").that.is.a(\"string\");",
											"        pm.expect(record).to.have.property(\"createdAt\").that.is.a(\"string\");",
											"        pm.expect(record).to.have.property(\"blockHeight\").that.is.a(\"string\");",
											"        pm.expect(record).to.have.property(\"blockTime\").that.is.a(\"string\");",
											"",
											"        // Check numeric fields are indeed parseable as numbers",
											"        pm.expect(parseFloat(record.equity)).to.not.be.NaN;",
											"        pm.expect(parseFloat(record.totalPnl)).to.not.be.NaN;",
											"        pm.expect(parseFloat(record.netTransfers)).to.not.be.NaN;",
											"",
											"        // Check blockHeight looks parseable as an integer",
											"        pm.expect(parseInt(record.blockHeight, 10)).to.not.be.NaN;",
											"",
											"        // Check date fields are valid",
											"        const createdDate = new Date(record.createdAt);",
											"        pm.expect(createdDate.toString()).not.to.equal(\"Invalid Date\");",
											"",
											"        const blockDate = new Date(record.blockTime);",
											"        pm.expect(blockDate.toString()).not.to.equal(\"Invalid Date\");",
											"    });",
											"});",
											"",
											"// 6. Validate the response body against a JSON Schema",
											"pm.test(\"Response matches JSON schema for megavaultPnl\", function () {",
											"    const schema = {",
											"        type: \"object\",",
											"        required: [\"megavaultPnl\"],",
											"        properties: {",
											"            megavaultPnl: {",
											"                type: \"array\",",
											"                items: {",
											"                    type: \"object\",",
											"                    required: [",
											"                        \"id\",",
											"                        \"subaccountId\",",
											"                        \"equity\",",
											"                        \"totalPnl\",",
											"                        \"netTransfers\",",
											"                        \"createdAt\",",
											"                        \"blockHeight\",",
											"                        \"blockTime\"",
											"                    ],",
											"                    properties: {",
											"                        id: { type: \"string\" },",
											"                        subaccountId: { type: \"string\" },",
											"                        equity: { type: \"string\" },",
											"                        totalPnl: { type: \"string\" },",
											"                        netTransfers: { type: \"string\" },",
											"                        createdAt: { type: \"string\", format: \"date-time\" },",
											"                        blockHeight: { type: \"string\" },",
											"                        blockTime: { type: \"string\", format: \"date-time\" }",
											"                    }",
											"                }",
											"            }",
											"        }",
											"    };",
											"",
											"    pm.response.to.have.jsonSchema(schema);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/vault/v1/megavault/historicalPnl",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"vault",
										"v1",
										"megavault",
										"historicalPnl"
									]
								}
							},
							"response": []
						},
						{
							"name": "v1/vaults/historicalPnl",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify response status code is 200",
											"pm.test(\"Response status code is 200\", function () {",
											"  pm.response.to.have.status(200);",
											"});",
											"",
											"// 2. Check that the response time is below a threshold (increase if needed)",
											"pm.test(\"Response time is under 20000 ms for large data\", function () {",
											"  pm.expect(pm.response.responseTime).to.be.below(20000); // 20 seconds",
											"});",
											"",
											"// 3. Parse the response JSON & top-level structure",
											"pm.test(\"Response has 'vaultsPnl' as an array\", function () {",
											"  const responseJson = pm.response.json();",
											"  pm.expect(responseJson).to.be.an(\"object\");",
											"  pm.expect(responseJson).to.have.property(\"vaultsPnl\").that.is.an(\"array\");",
											"});",
											"",
											"// 4. For each vault, check structure: 'ticker' & 'historicalPnl'",
											"pm.test(\"Each vault has a ticker and a historicalPnl array\", function () {",
											"  const { vaultsPnl } = pm.response.json();",
											"",
											"  pm.expect(vaultsPnl.length).to.be.above(0);",
											"",
											"  const maxVaultsToCheck = 20;",
											"  vaultsPnl.slice(0, maxVaultsToCheck).forEach((vault, vaultIndex) => {",
											"    pm.expect(vault).to.have.property(\"ticker\").that.is.a(\"string\");",
											"    pm.expect(vault).to.have.property(\"historicalPnl\").that.is.an(\"array\");",
											"",
											"    // 5. Validate each record in historicalPnl",
											"    const maxPnlRecordsToCheck = 20; ",
											"    vault.historicalPnl.slice(0, maxPnlRecordsToCheck).forEach((record, recIndex) => {",
											"      pm.expect(record).to.be.an(\"object\");",
											"",
											"      // Check required fields & types",
											"      pm.expect(record).to.have.property(\"id\").that.is.a(\"string\");",
											"      pm.expect(record).to.have.property(\"subaccountId\").that.is.a(\"string\");",
											"      pm.expect(record).to.have.property(\"equity\").that.is.a(\"string\");",
											"      pm.expect(record).to.have.property(\"totalPnl\").that.is.a(\"string\");",
											"      pm.expect(record).to.have.property(\"netTransfers\").that.is.a(\"string\");",
											"      pm.expect(record).to.have.property(\"createdAt\").that.is.a(\"string\");",
											"      pm.expect(record).to.have.property(\"blockHeight\").that.is.a(\"string\");",
											"      pm.expect(record).to.have.property(\"blockTime\").that.is.a(\"string\");",
											"",
											"      // Validate numeric fields are parseable",
											"      pm.expect(parseFloat(record.equity)).to.not.be.NaN;",
											"      pm.expect(parseFloat(record.totalPnl)).to.not.be.NaN;",
											"      pm.expect(parseFloat(record.netTransfers)).to.not.be.NaN;",
											"      pm.expect(parseInt(record.blockHeight, 10)).to.not.be.NaN;",
											"",
											"      // Validate date fields",
											"      const createdAtDate = new Date(record.createdAt);",
											"      pm.expect(createdAtDate.toString()).not.to.equal(\"Invalid Date\");",
											"",
											"      const blockTimeDate = new Date(record.blockTime);",
											"      pm.expect(blockTimeDate.toString()).not.to.equal(\"Invalid Date\");",
											"    });",
											"  });",
											"});",
											"",
											"// 6. Validate the overall response against a JSON Schema",
											"pm.test(\"Response matches JSON schema for vaults/vaultsPnl\", function () {",
											"  const schema = {",
											"    type: \"object\",",
											"    required: [\"vaultsPnl\"],",
											"    properties: {",
											"      vaultsPnl: {",
											"        type: \"array\",",
											"        items: {",
											"          type: \"object\",",
											"          required: [\"ticker\", \"historicalPnl\"],",
											"          properties: {",
											"            ticker: { type: \"string\" },",
											"            historicalPnl: {",
											"              type: \"array\",",
											"              items: {",
											"                type: \"object\",",
											"                required: [",
											"                  \"id\",",
											"                  \"subaccountId\",",
											"                  \"equity\",",
											"                  \"totalPnl\",",
											"                  \"netTransfers\",",
											"                  \"createdAt\",",
											"                  \"blockTime\"",
											"                ],",
											"                properties: {",
											"                  id: { type: \"string\" },",
											"                  subaccountId: { type: \"string\" },",
											"                  equity: { type: \"string\" },",
											"                  totalPnl: { type: \"string\" },",
											"                  netTransfers: { type: \"string\" },",
											"                  createdAt: { type: \"string\", format: \"date-time\" },",
											"                  blockHeight: { type: \"string\" },",
											"                  blockTime: { type: \"string\", format: \"date-time\" }",
											"                }",
											"              }",
											"            }",
											"          }",
											"        }",
											"      }",
											"    }",
											"  };",
											"",
											"  pm.response.to.have.jsonSchema(schema);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/vault/v1/vaults/historicalPnl",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"vault",
										"v1",
										"vaults",
										"historicalPnl"
									]
								}
							},
							"response": []
						},
						{
							"name": "v1/vaults/historicalPnl Copy",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// 1. Verify response status code is 200",
											"pm.test(\"Response status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"// 2. Check that the response time is below a threshold (increase if needed for large data)",
											"pm.test(\"Response time is less than 6000ms\", function () {",
											"    pm.expect(pm.response.responseTime).to.be.below(6000);",
											"});",
											"",
											"// 3. Parse the JSON & check top-level structure",
											"pm.test(\"Response contains a 'positions' array\", function () {",
											"    const jsonData = pm.response.json();",
											"    pm.expect(jsonData).to.be.an(\"object\");",
											"    pm.expect(jsonData).to.have.property(\"positions\").that.is.an(\"array\");",
											"});",
											"",
											"// 4. Validate each position in the 'positions' array",
											"pm.test(\"Validate each position's structure\", function () {",
											"    const { positions } = pm.response.json();",
											"",
											"    positions.forEach((position, index) => {",
											"        // a) 'ticker' is required and should be a string",
											"        pm.expect(position).to.have.property(\"ticker\").that.is.a(\"string\");",
											"",
											"        // b) 'equity' is typically a string representation of a number",
											"        pm.expect(position).to.have.property(\"equity\").that.is.a(\"string\");",
											"        pm.expect(parseFloat(position.equity), `equity parseFloat fail at index ${index}`)",
											"            .to.not.be.NaN;",
											"",
											"        // c) Check 'assetPosition' if present",
											"        if (position.hasOwnProperty(\"assetPosition\") && position.assetPosition !== null) {",
											"            const assetPos = position.assetPosition;",
											"            // Basic required fields in assetPosition (based on your snippet)",
											"            pm.expect(assetPos).to.be.an(\"object\");",
											"            pm.expect(assetPos).to.have.property(\"size\").that.is.a(\"string\");",
											"            pm.expect(assetPos).to.have.property(\"symbol\").that.is.a(\"string\");",
											"            pm.expect(assetPos).to.have.property(\"side\").that.is.a(\"string\"); // e.g., \"LONG\"",
											"            pm.expect(assetPos).to.have.property(\"assetId\").that.is.a(\"string\");",
											"            pm.expect(assetPos).to.have.property(\"subaccountNumber\").that.is.a(\"number\");",
											"",
											"            // Validate numeric parse",
											"            pm.expect(parseFloat(assetPos.size), `assetPosition.size parseFloat fail at index ${index}`)",
											"                .to.not.be.NaN;",
											"        }",
											"",
											"        // d) Check 'perpetualPosition' if present",
											"        if (position.hasOwnProperty(\"perpetualPosition\") && position.perpetualPosition !== null) {",
											"            const perpPos = position.perpetualPosition;",
											"            // Required fields from the snippet",
											"            pm.expect(perpPos).to.be.an(\"object\");",
											"            pm.expect(perpPos).to.have.property(\"market\").that.is.a(\"string\");",
											"            pm.expect(perpPos).to.have.property(\"status\").that.is.a(\"string\"); // e.g. \"OPEN\", \"CLOSED\"",
											"            pm.expect(perpPos).to.have.property(\"side\").that.is.a(\"string\");   // e.g. \"LONG\", \"SHORT\"",
											"            pm.expect(perpPos).to.have.property(\"size\").that.is.a(\"string\");",
											"            pm.expect(perpPos).to.have.property(\"maxSize\").that.is.a(\"string\");",
											"            pm.expect(perpPos).to.have.property(\"entryPrice\").that.is.a(\"string\");",
											"            pm.expect(perpPos).to.have.property(\"exitPrice\"); // can be null or string",
											"            pm.expect(",
											"                perpPos.exitPrice === null || typeof perpPos.exitPrice === \"string\",",
											"                `\"exitPrice\" must be null or a string (pos index ${index})`",
											"            ).to.be.true;",
											"            pm.expect(perpPos).to.have.property(\"realizedPnl\").that.is.a(\"string\");",
											"            pm.expect(perpPos).to.have.property(\"unrealizedPnl\").that.is.a(\"string\");",
											"            pm.expect(perpPos).to.have.property(\"createdAt\").that.is.a(\"string\");",
											"            pm.expect(perpPos).to.have.property(\"createdAtHeight\").that.is.a(\"string\");",
											"            pm.expect(perpPos).to.have.property(\"closedAt\"); // null or string",
											"            pm.expect(perpPos).to.have.property(\"sumOpen\").that.is.a(\"string\");",
											"            pm.expect(perpPos).to.have.property(\"sumClose\").that.is.a(\"string\");",
											"            pm.expect(perpPos).to.have.property(\"netFunding\").that.is.a(\"string\");",
											"            pm.expect(perpPos).to.have.property(\"subaccountNumber\").that.is.a(\"number\");",
											"",
											"            // e) Validate numeric parse for perpetual fields",
											"            [",
											"                \"size\",",
											"                \"maxSize\",",
											"                \"entryPrice\",",
											"                \"realizedPnl\",",
											"                \"unrealizedPnl\",",
											"                \"sumOpen\",",
											"                \"sumClose\",",
											"                \"netFunding\"",
											"            ].forEach(key => {",
											"                pm.expect(parseFloat(perpPos[key]), `${key} parseFloat fail at index ${index}`).to.not.be.NaN;",
											"            });",
											"            // exitPrice can be null or string",
											"            if (perpPos.exitPrice !== null) {",
											"                pm.expect(parseFloat(perpPos.exitPrice)).to.not.be.NaN;",
											"            }",
											"",
											"            // f) Date/time validations",
											"            const createdAtDate = new Date(perpPos.createdAt);",
											"            pm.expect(createdAtDate.toString()).not.to.equal(\"Invalid Date\");",
											"            if (perpPos.closedAt !== null) {",
											"                const closedAtDate = new Date(perpPos.closedAt);",
											"                pm.expect(closedAtDate.toString()).not.to.equal(\"Invalid Date\");",
											"            }",
											"",
											"            // g) Enumerations for 'status' & 'side'",
											"            const validStatuses = [\"OPEN\", \"CLOSED\"];",
											"            const validSides = [\"LONG\", \"SHORT\"];",
											"            pm.expect(validStatuses, `Invalid 'status' at index ${index}`).to.include(perpPos.status);",
											"            pm.expect(validSides, `Invalid 'side' at index ${index}`).to.include(perpPos.side);",
											"        }",
											"    });",
											"});",
											"",
											"// 5. Validate the entire response against a JSON schema",
											"pm.test(\"Response matches the expected JSON schema for Megavault positions\", function () {",
											"    const schema = {",
											"        type: \"object\",",
											"        required: [\"positions\"],",
											"        properties: {",
											"            positions: {",
											"                type: \"array\",",
											"                items: {",
											"                    type: \"object\",",
											"                    required: [\"ticker\", \"equity\"],",
											"                    properties: {",
											"                        ticker: { type: \"string\" },",
											"                        equity: { type: \"string\" }, ",
											"                        // assetPosition is optional",
											"                        assetPosition: {",
											"                            type: \"object\",",
											"                            properties: {",
											"                                size: { type: \"string\" },",
											"                                symbol: { type: \"string\" },",
											"                                side: { type: \"string\" }, // e.g. \"LONG\"",
											"                                assetId: { type: \"string\" },",
											"                                subaccountNumber: { type: \"number\" }",
											"                            },",
											"                            required: [\"size\", \"symbol\", \"side\", \"assetId\", \"subaccountNumber\"],",
											"                            additionalProperties: true // if you want to allow extra fields",
											"                        },",
											"                        // perpetualPosition is optional",
											"                        perpetualPosition: {",
											"                            type: \"object\",",
											"                            properties: {",
											"                                market: { type: \"string\" },",
											"                                status: { type: \"string\" },",
											"                                side: { type: \"string\" },",
											"                                size: { type: \"string\" },",
											"                                maxSize: { type: \"string\" },",
											"                                entryPrice: { type: \"string\" },",
											"                                exitPrice: { type: [\"string\", \"null\"] },",
											"                                realizedPnl: { type: \"string\" },",
											"                                unrealizedPnl: { type: \"string\" },",
											"                                createdAt: { type: \"string\", format: \"date-time\" },",
											"                                createdAtHeight: { type: \"string\" },",
											"                                closedAt: { type: [\"string\", \"null\"] },",
											"                                sumOpen: { type: \"string\" },",
											"                                sumClose: { type: \"string\" },",
											"                                netFunding: { type: \"string\" },",
											"                                subaccountNumber: { type: \"number\" }",
											"                            },",
											"                            required: [",
											"                                \"market\",",
											"                                \"status\",",
											"                                \"side\",",
											"                                \"size\",",
											"                                \"maxSize\",",
											"                                \"entryPrice\",",
											"                                \"exitPrice\",",
											"                                \"realizedPnl\",",
											"                                \"unrealizedPnl\",",
											"                                \"createdAt\",",
											"                                \"createdAtHeight\",",
											"                                \"closedAt\",",
											"                                \"sumOpen\",",
											"                                \"sumClose\",",
											"                                \"netFunding\",",
											"                                \"subaccountNumber\"",
											"                            ],",
											"                            additionalProperties: true",
											"                        }",
											"                    },",
											"                    additionalProperties: true",
											"                }",
											"            }",
											"        }",
											"    };",
											"",
											"    pm.response.to.have.jsonSchema(schema);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{indexerBaseUrl}}/vault/v1/megavault/positions",
									"host": [
										"{{indexerBaseUrl}}"
									],
									"path": [
										"vault",
										"v1",
										"megavault",
										"positions"
									]
								}
							},
							"response": []
						}
					]
				}
			]
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					""
				]
			}
		}
	]
}