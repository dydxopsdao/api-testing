{
	"info": {
		"_postman_id": "981cef60-dcd2-4b5e-aefb-c7d1dd2e08dc",
		"name": "dYdX",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "41930738",
		"_collection_link": "https://dydx-ops-services.postman.co/workspace/dYdX~fdeed7e0-d6ed-46c3-926d-fdf269d648ad/collection/41849022-981cef60-dcd2-4b5e-aefb-c7d1dd2e08dc?action=share&source=collection_link&creator=41930738"
	},
	"variable": [
		{
			"key": "defaultTimeoutMs",
			"value": "6000"
		}
	],
	"item": [
		{
			"name": "Indexer",
			"item": [
				{
					"name": "Comlink",
					"item": [
						{
							"name": "addresses",
							"item": [
								{
									"name": "address",
									"item": [
										{
											"name": "/addresses/{address} valid Address",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"// Helpers",
															"const asJson = () => {",
															"  try { return pm.response.json(); }",
															"  catch (e) { pm.expect.fail(`Response not JSON: ${e}`); }",
															"};",
															"const isNumericString = (v) => v !== null && v !== undefined && !Number.isNaN(Number(v));",
															"const dydxAddressRe = /^dydx1[a-z0-9]{38}$/;",
															"",
															"// 1) Status & latency",
															"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
															"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
															"",
															"// 2) Top-level structure",
															"const body = asJson();",
															"pm.test(\"has subaccounts[] and totalTradingRewards (string, numeric)\", () => {",
															"  pm.expect(body).to.be.an(\"object\");",
															"  pm.expect(body).to.have.property(\"subaccounts\").that.is.an(\"array\");",
															"  pm.expect(body).to.have.property(\"totalTradingRewards\").that.is.a(\"string\");",
															"  pm.expect(isNumericString(body.totalTradingRewards), \"totalTradingRewards numeric\").to.be.true;",
															"});",
															"",
															"// 3) Subaccount schema (allow future-safe extras via whitelist check)",
															"pm.test(\"subaccounts schema + numeric strings\", () => {",
															"  const expectedKeys = [",
															"    \"address\",",
															"    \"subaccountNumber\",",
															"    \"equity\",",
															"    \"freeCollateral\",",
															"    \"openPerpetualPositions\",",
															"    \"assetPositions\",",
															"    \"marginEnabled\",",
															"    \"updatedAtHeight\",",
															"    \"latestProcessedBlockHeight\",",
															"  ];",
															"",
															"  body.subaccounts.forEach((s, i) => {",
															"    pm.expect(s, `subaccount ${i}`).to.be.an(\"object\");",
															"    pm.expect(s.address).to.be.a(\"string\").and.match(dydxAddressRe);",
															"    pm.expect(s.subaccountNumber).to.be.a(\"number\");",
															"    pm.expect(s.marginEnabled).to.be.a(\"boolean\");",
															"    [\"equity\", \"freeCollateral\", \"updatedAtHeight\", \"latestProcessedBlockHeight\"].forEach((k) => {",
															"      pm.expect(s[k]).to.be.a(\"string\");",
															"      pm.expect(isNumericString(s[k]), `${k} numeric`).to.be.true;",
															"    });",
															"    pm.expect(s.openPerpetualPositions).to.be.an(\"object\");",
															"    pm.expect(s.assetPositions).to.be.an(\"object\");",
															"",
															"    // No unexpected properties (schema integrity)",
															"    Object.keys(s).forEach((k) =>",
															"      pm.expect(expectedKeys).to.include(k, `Unexpected property: ${k}`)",
															"    );",
															"",
															"    // Validate assetPositions if present",
															"    Object.values(s.assetPositions || {}).forEach((asset, j) => {",
															"      pm.expect(asset, `asset ${j}`).to.be.an(\"object\");",
															"      [\"size\", \"symbol\", \"side\"].forEach((k) => pm.expect(asset[k]).to.be.a(\"string\"));",
															"      pm.expect(asset.assetId).to.exist;",
															"      pm.expect(asset.subaccountNumber).to.be.a(\"number\");",
															"      pm.expect(isNumericString(asset.size), \"asset.size numeric\").to.be.true;",
															"    });",
															"  });",
															"});",
															"",
															"// 4) JSON schema (kept concise; allows only expected fields)",
															"pm.test(\"matches JSON schema\", () => {",
															"  const schema = {",
															"    type: \"object\",",
															"    properties: {",
															"      subaccounts: {",
															"        type: \"array\",",
															"        items: {",
															"          type: \"object\",",
															"          properties: {",
															"            address: { type: \"string\", pattern: \"^dydx1[a-z0-9]{38}$\" },",
															"            subaccountNumber: { type: \"number\" },",
															"            equity: { type: \"string\" },",
															"            freeCollateral: { type: \"string\" },",
															"            marginEnabled: { type: \"boolean\" },",
															"            updatedAtHeight: { type: \"string\" },",
															"            latestProcessedBlockHeight: { type: \"string\" },",
															"            openPerpetualPositions: { type: \"object\" },",
															"            assetPositions: { type: \"object\" }",
															"          },",
															"          required: [",
															"            \"address\",",
															"            \"subaccountNumber\",",
															"            \"equity\",",
															"            \"freeCollateral\",",
															"            \"marginEnabled\",",
															"            \"updatedAtHeight\",",
															"            \"latestProcessedBlockHeight\",",
															"            \"openPerpetualPositions\",",
															"            \"assetPositions\"",
															"          ],",
															"          additionalProperties: false",
															"        }",
															"      },",
															"      totalTradingRewards: { type: \"string\" }",
															"    },",
															"    required: [\"subaccounts\", \"totalTradingRewards\"],",
															"    additionalProperties: false",
															"  };",
															"",
															"  pm.response.to.have.jsonSchema(schema);",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{indexerBaseUrl}}/addresses/{{validdYdXAddress}}",
													"host": [
														"{{indexerBaseUrl}}"
													],
													"path": [
														"addresses",
														"{{validdYdXAddress}}"
													]
												},
												"description": "# Get Address Information\n\n## Overview\nThis endpoint retrieves detailed information about a dYdX address from the indexer API. It returns comprehensive data including all subaccounts associated with the address, equity positions, collateral information, open perpetual positions, asset positions, and cumulative trading rewards.\n\n## Endpoint\n```\nGET {{indexerBaseUrl}}/addresses/{address}\n```\n\n## Path Parameters\n\n| Parameter | Type | Required | Description |\n|-----------|------|----------|-------------|\n| `address` | string | Yes | A valid dYdX address (e.g., dydx1...) |\n\n## Variables Used\n\n- **indexerBaseUrl**: Base URL for the dYdX indexer API\n- **validdYdXAddress**: A valid dYdX address used for testing purposes\n\n## Response Structure\n\nThe endpoint returns a JSON object with the following structure:\n\n### Top-Level Fields\n\n- **subaccounts** (array): Array of subaccount objects associated with the address\n- **totalTradingRewards** (string): Cumulative trading rewards earned across all subaccounts\n\n### Subaccount Object\n\nEach subaccount in the array contains:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `address` | string | The dYdX address |\n| `subaccountNumber` | number | Unique identifier for the subaccount |\n| `equity` | string | Total equity in the subaccount |\n| `freeCollateral` | string | Available collateral for trading |\n| `marginEnabled` | boolean | Whether margin trading is enabled |\n| `updatedAtHeight` | string | Block height when last updated |\n| `latestProcessedBlockHeight` | string | Most recent processed block height |\n| `openPerpetualPositions` | object | Open perpetual positions (key-value pairs by market) |\n| `assetPositions` | object | Asset positions held in the subaccount |\n| `pendingDeposits` | array | Pending deposit transactions |\n| `pendingWithdrawals` | array | Pending withdrawal transactions |\n\n## Example Use Cases\n\n1. **Portfolio Overview**: Retrieve complete portfolio information for a user address\n2. **Account Monitoring**: Check equity, collateral, and margin status\n3. **Position Tracking**: Monitor open perpetual positions and asset holdings\n4. **Rewards Calculation**: Access cumulative trading rewards data\n5. **Transaction Status**: View pending deposits and withdrawals\n6. **Multi-Subaccount Management**: Get data for all subaccounts under a single address\n\n## Testing\n\nThis request includes a comprehensive test suite that validates:\n\n- ✅ Response status code (200 OK)\n- ✅ Response time performance (< 6000ms)\n- ✅ Top-level structure (subaccounts array and totalTradingRewards)\n- ✅ Subaccount schema validation for all required fields\n- ✅ Data type validation for all properties\n- ✅ Numeric value constraints (equity, collateral must be >= 0)\n- ✅ Nested object structures (positions, assets, pending transactions)\n\nThe test suite dynamically validates each subaccount in the response, ensuring data integrity across all returned records."
											},
											"response": []
										},
										{
											"name": "/addresses/{address} invalid Address",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"// Helpers",
															"const asJson = () => {",
															"  try { return pm.response.json(); }",
															"  catch (e) { pm.expect.fail(`Response not JSON: ${e}`); }",
															"};",
															"",
															"// 1) Status",
															"pm.test(\"status is 404 or 400\", () => {",
															"  pm.expect(pm.response.code).to.be.oneOf([404, 400]);",
															"});",
															"",
															"// 2) Errors array present",
															"const body = asJson();",
															"pm.test(\"has errors[]\", () => {",
															"  pm.expect(body).to.have.property(\"errors\").that.is.an(\"array\").with.length.greaterThan(0);",
															"});",
															"",
															"// 3) Error objects have msg and mention address",
															"pm.test(\"errors include address-not-found message\", () => {",
															"  const match = body.errors.find((e) => typeof e.msg === \"string\");",
															"  pm.expect(match, \"at least one error has msg\").to.exist;",
															"  pm.expect(match.msg).to.match(/^No subaccounts found for address /);",
															"});",
															"",
															"// 4) Optional: enforce minimal shape of error objects",
															"pm.test(\"error objects have expected keys\", () => {",
															"  const allowed = [\"value\", \"msg\", \"param\", \"location\"];",
															"  body.errors.forEach((err) => {",
															"    pm.expect(err.msg).to.be.a(\"string\");",
															"    Object.keys(err).forEach((k) => pm.expect(allowed).to.include(k));",
															"  });",
															"});",
															"",
															"// 5) JSON schema (minimal)",
															"pm.test(\"matches error schema\", () => {",
															"  const schema = {",
															"    type: \"object\",",
															"    properties: {",
															"      errors: {",
															"        type: \"array\",",
															"        minItems: 1,",
															"        items: {",
															"          type: \"object\",",
															"          properties: {",
															"            msg: { type: \"string\" },",
															"            value: { type: \"string\" },",
															"            param: { type: \"string\" },",
															"            location: { type: \"string\" }",
															"          },",
															"          required: [\"msg\"],",
															"          additionalProperties: true",
															"        }",
															"      }",
															"    },",
															"    required: [\"errors\"],",
															"    additionalProperties: true",
															"  };",
															"  pm.response.to.have.jsonSchema(schema);",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{indexerBaseUrl}}/addresses/{{invaliddYdXAddress}}",
													"host": [
														"{{indexerBaseUrl}}"
													],
													"path": [
														"addresses",
														"{{invaliddYdXAddress}}"
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "subaccountNumber",
									"item": [
										{
											"name": "/addresses/{address}/subaccountNumber Invalid",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"// Helpers",
															"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
															"",
															"// 1) Status",
															"pm.test(\"status is 400\", () => pm.response.to.have.status(400));",
															"",
															"// 2) Errors array present",
															"const body = asJson();",
															"pm.test(\"has errors[]\", () => {",
															"  pm.expect(body).to.have.property(\"errors\").that.is.an(\"array\").with.length.greaterThan(0);",
															"});",
															"",
															"// 3) Error objects contain required fields",
															"pm.test(\"error objects have msg/value/param/location (strings)\", () => {",
															"  body.errors.forEach((err) => {",
															"    [\"msg\", \"value\", \"param\", \"location\"].forEach((k) => pm.expect(err).to.have.property(k).that.is.a(\"string\"));",
															"  });",
															"});",
															"",
															"// 4) Specific validation message, param, location",
															"pm.test(\"subaccountNumber validation message/param/location\", () => {",
															"  const err = body.errors.find((e) => e.param === \"subaccountNumber\") || body.errors[0];",
															"  pm.expect(err.msg).to.eql(\"subaccountNumber must be a non-negative integer less than 128001\");",
															"  pm.expect(err.param).to.eql(\"subaccountNumber\");",
															"  pm.expect(err.location).to.eql(\"params\");",
															"});",
															"",
															"// 5) Minimal schema",
															"pm.test(\"matches error schema\", () => {",
															"  const schema = {",
															"    type: \"object\",",
															"    properties: {",
															"      errors: {",
															"        type: \"array\",",
															"        minItems: 1,",
															"        items: {",
															"          type: \"object\",",
															"          properties: {",
															"            msg: { type: \"string\" },",
															"            value: { type: \"string\" },",
															"            param: { type: \"string\" },",
															"            location: { type: \"string\" }",
															"          },",
															"          required: [\"msg\", \"value\", \"param\", \"location\"],",
															"          additionalProperties: true",
															"        }",
															"      }",
															"    },",
															"    required: [\"errors\"],",
															"    additionalProperties: true",
															"  };",
															"  pm.response.to.have.jsonSchema(schema);",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{indexerBaseUrl}}/addresses/{{validdYdXAddress}}/subaccountNumber/{{invaliddYdXAddressSubAccountNumber}}",
													"host": [
														"{{indexerBaseUrl}}"
													],
													"path": [
														"addresses",
														"{{validdYdXAddress}}",
														"subaccountNumber",
														"{{invaliddYdXAddressSubAccountNumber}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "/addresses/{address}/subaccountNumber Valid",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"// Helpers",
															"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
															"const isNumericString = (v) => v !== null && v !== undefined && !Number.isNaN(Number(v));",
															"const dydxAddressRe = /^dydx1[a-z0-9]{38}$/;",
															"",
															"// 1) Status + latency",
															"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
															"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
															"",
															"// 2) Top-level shape",
															"const body = asJson();",
															"pm.test(\"has subaccount object\", () => {",
															"  pm.expect(body).to.be.an(\"object\");",
															"  pm.expect(body).to.have.property(\"subaccount\").that.is.an(\"object\");",
															"});",
															"",
															"// 3) Subaccount required fields + numeric strings",
															"pm.test(\"subaccount schema + numeric strings\", () => {",
															"  const s = body.subaccount;",
															"  pm.expect(s.address).to.be.a(\"string\").and.match(dydxAddressRe);",
															"  pm.expect(s.subaccountNumber).to.be.a(\"number\");",
															"  pm.expect(s.marginEnabled).to.be.a(\"boolean\");",
															"  [\"equity\", \"freeCollateral\", \"updatedAtHeight\", \"latestProcessedBlockHeight\"].forEach((k) => {",
															"    pm.expect(s[k]).to.be.a(\"string\");",
															"    pm.expect(isNumericString(s[k]), `${k} numeric`).to.be.true;",
															"  });",
															"  pm.expect(s.openPerpetualPositions).to.be.an(\"object\");",
															"  pm.expect(s.assetPositions).to.be.an(\"object\");",
															"});",
															"",
															"// 4) Asset positions (if any)",
															"pm.test(\"assetPositions valid when present\", () => {",
															"  const s = body.subaccount;",
															"  Object.values(s.assetPositions || {}).forEach((asset) => {",
															"    [\"size\", \"symbol\", \"side\"].forEach((k) => pm.expect(asset[k]).to.be.a(\"string\"));",
															"    pm.expect(asset.assetId).to.exist;",
															"    pm.expect(asset.subaccountNumber).to.eql(s.subaccountNumber);",
															"    pm.expect(isNumericString(asset.size), \"asset.size numeric\").to.be.true;",
															"  });",
															"});",
															"",
															"// 5) Request echo",
															"pm.test(\"address and subaccountNumber match request\", () => {",
															"  const s = body.subaccount;",
															"  const expectedAddr = pm.environment.get(\"validdYdXAddress\");",
															"  const expectedSub = Number(pm.environment.get(\"validdYdXAddressSubAccountNumber\"));",
															"  pm.expect(s.address).to.eql(expectedAddr);",
															"  pm.expect(s.subaccountNumber).to.eql(expectedSub);",
															"});",
															"",
															"// 6) JSON schema (concise)",
															"pm.test(\"matches JSON schema\", () => {",
															"  const schema = {",
															"    type: \"object\",",
															"    properties: {",
															"      subaccount: {",
															"        type: \"object\",",
															"        properties: {",
															"          address: { type: \"string\", pattern: \"^dydx1[a-z0-9]{38}$\" },",
															"          subaccountNumber: { type: \"number\" },",
															"          equity: { type: \"string\" },",
															"          freeCollateral: { type: \"string\" },",
															"          marginEnabled: { type: \"boolean\" },",
															"          updatedAtHeight: { type: \"string\" },",
															"          latestProcessedBlockHeight: { type: \"string\" },",
															"          openPerpetualPositions: { type: \"object\" },",
															"          assetPositions: { type: \"object\" }",
															"        },",
															"        required: [",
															"          \"address\",",
															"          \"subaccountNumber\",",
															"          \"equity\",",
															"          \"freeCollateral\",",
															"          \"marginEnabled\",",
															"          \"updatedAtHeight\",",
															"          \"latestProcessedBlockHeight\",",
															"          \"openPerpetualPositions\",",
															"          \"assetPositions\"",
															"        ],",
															"        additionalProperties: false",
															"      }",
															"    },",
															"    required: [\"subaccount\"],",
															"    additionalProperties: false",
															"  };",
															"  pm.response.to.have.jsonSchema(schema);",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{indexerBaseUrl}}/addresses/{{validdYdXAddress}}/subaccountNumber/{{validdYdXAddressSubAccountNumber}}",
													"host": [
														"{{indexerBaseUrl}}"
													],
													"path": [
														"addresses",
														"{{validdYdXAddress}}",
														"subaccountNumber",
														"{{validdYdXAddressSubAccountNumber}}"
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "registerToken",
									"item": [
										{
											"name": "/addresses/{address}/registerToken invalid",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"// Helpers",
															"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON`); } };",
															"",
															"// 1) Status should be 400",
															"pm.test(\"status 400\", () => pm.response.to.have.status(400));",
															"",
															"// 2) Errors array present",
															"const body = asJson();",
															"pm.test(\"has errors[]\", () => {",
															"  pm.expect(body).to.have.property(\"errors\").that.is.an(\"array\").with.length.greaterThan(0);",
															"});",
															"",
															"// 3) Each error has shape",
															"pm.test(\"errors have msg/param/location\", () => {",
															"  body.errors.forEach((err) => {",
															"    [\"msg\", \"param\", \"location\"].forEach((k) => pm.expect(err).to.have.property(k).that.is.a(\"string\"));",
															"    if (err.value !== undefined) pm.expect(err.value).to.be.a(\"string\");",
															"  });",
															"});",
															"",
															"// 4) Expected validation messages present",
															"pm.test(\"expected missing/invalid fields reported\", () => {",
															"  const params = body.errors.map((e) => e.param);",
															"  [\"timestamp\", \"message\", \"signedMessage\", \"pubKey\", \"walletIsKeplr\", \"language\"].forEach((p) =>",
															"    pm.expect(params).to.include(p, `missing error for ${p}`)",
															"  );",
															"  const langErr = body.errors.find((e) => e.param === \"language\");",
															"  pm.expect(langErr && langErr.msg).to.match(/Invalid language code/);",
															"});",
															"",
															"// 5) JSON schema guard",
															"pm.test(\"matches error schema\", () => {",
															"  const schema = {",
															"    type: \"object\",",
															"    properties: {",
															"      errors: {",
															"        type: \"array\",",
															"        minItems: 1,",
															"        items: {",
															"          type: \"object\",",
															"          properties: {",
															"            msg: { type: \"string\" },",
															"            param: { type: \"string\" },",
															"            location: { type: \"string\" },",
															"            value: { type: \"string\" }",
															"          },",
															"          required: [\"msg\", \"param\", \"location\"],",
															"          additionalProperties: true",
															"        }",
															"      }",
															"    },",
															"    required: [\"errors\"],",
															"    additionalProperties: true",
															"  };",
															"  pm.response.to.have.jsonSchema(schema);",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\n  \"language\": \"string\",\n  \"token\": \"string\"\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{indexerBaseUrl}}/addresses/{{validdYdXAddress}}/registerToken",
													"host": [
														"{{indexerBaseUrl}}"
													],
													"path": [
														"addresses",
														"{{validdYdXAddress}}",
														"registerToken"
													]
												}
											},
											"response": []
										},
										{
											"name": "/addresses/{address}/registerToken valid",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\n  \"language\": \"string\",\n  \"token\": \"string\"\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{indexerBaseUrl}}/addresses/{{validdYdXAddress}}/registerToken",
													"host": [
														"{{indexerBaseUrl}}"
													],
													"path": [
														"addresses",
														"{{validdYdXAddress}}",
														"registerToken"
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "testNotification",
									"item": [
										{
											"name": "/addresses/{address}/testNotification",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"url": {
													"raw": "{{indexerBaseUrl}}addresses/{{validdYdXAddress}}/testNotification",
													"host": [
														"{{indexerBaseUrl}}addresses"
													],
													"path": [
														"{{validdYdXAddress}}",
														"testNotification"
													]
												}
											},
											"response": []
										}
									]
								}
							]
						},
						{
							"name": "affiliates",
							"item": [
								{
									"name": "metadata",
									"item": [
										{
											"name": "/affiliates/metadata valid address",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"// Helpers",
															"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
															"const isNonEmptyString = (v) => typeof v === \"string\" && v.length > 0;",
															"const dydxAddressRe = /^dydx1[a-z0-9]{38}$/;",
															"",
															"// 1) Status + latency",
															"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
															"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
															"",
															"// 2) Shape + types",
															"const body = asJson();",
															"pm.test(\"has referralCode, isVolumeEligible, isAffiliate\", () => {",
															"  pm.expect(body).to.be.an(\"object\");",
															"  pm.expect(body.referralCode).to.be.a(\"string\");",
															"  pm.expect(body.isVolumeEligible).to.be.a(\"boolean\");",
															"  pm.expect(body.isAffiliate).to.be.a(\"boolean\");",
															"});",
															"",
															"// 3) referralCode non-empty (store for later)",
															"pm.test(\"referralCode non-empty\", () => {",
															"  pm.expect(isNonEmptyString(body.referralCode), \"referralCode non-empty\").to.be.true;",
															"  pm.environment.set(\"referralCode\", body.referralCode);",
															"});",
															"",
															"// 4) Optional: address format check (if backend echoes/derives address; skip if not present)",
															"// if (body.address) pm.test(\"address looks like dydx bech32\", () => pm.expect(body.address).to.match(dydxAddressRe));",
															"",
															"// 5) JSON schema guard",
															"pm.test(\"matches schema\", () => {",
															"  const schema = {",
															"    type: \"object\",",
															"    properties: {",
															"      referralCode: { type: \"string\" },",
															"      isVolumeEligible: { type: \"boolean\" },",
															"      isAffiliate: { type: \"boolean\" }",
															"    },",
															"    required: [\"referralCode\", \"isVolumeEligible\", \"isAffiliate\"],",
															"    additionalProperties: true // allow future fields",
															"  };",
															"  pm.response.to.have.jsonSchema(schema);",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{indexerBaseUrl}}/affiliates/metadata?address={{dydxWithReferrals}}",
													"host": [
														"{{indexerBaseUrl}}"
													],
													"path": [
														"affiliates",
														"metadata"
													],
													"query": [
														{
															"key": "address",
															"value": "{{dydxWithReferrals}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "/affiliates/metadata invalid address",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"// Helpers",
															"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
															"",
															"// 1) Status (API returns 404 for not found; allow 400 if validation)",
															"pm.test(\"status is 404 or 400\", () => pm.expect(pm.response.code).to.be.oneOf([404, 400]));",
															"",
															"// 2) Errors array present",
															"const body = asJson();",
															"pm.test(\"has errors[]\", () => {",
															"  pm.expect(body).to.have.property(\"errors\").that.is.an(\"array\").with.length.greaterThan(0);",
															"});",
															"",
															"// 3) Error objects have msg and mention wallet/address",
															"pm.test(\"errors include wallet-not-found message\", () => {",
															"  const err = body.errors.find((e) => typeof e.msg === \"string\") || {};",
															"  pm.expect(err.msg, \"msg present\").to.be.a(\"string\");",
															"  pm.expect(err.msg).to.match(/^Wallet with address /);",
															"});",
															"",
															"// 4) Basic shape",
															"pm.test(\"error objects have expected keys\", () => {",
															"  const allowed = [\"value\", \"msg\", \"param\", \"location\"];",
															"  body.errors.forEach((e) => {",
															"    pm.expect(e.msg).to.be.a(\"string\");",
															"    Object.keys(e).forEach((k) => pm.expect(allowed).to.include(k));",
															"  });",
															"});",
															"",
															"// 5) Minimal schema",
															"pm.test(\"matches error schema\", () => {",
															"  const schema = {",
															"    type: \"object\",",
															"    properties: {",
															"      errors: {",
															"        type: \"array\",",
															"        minItems: 1,",
															"        items: {",
															"          type: \"object\",",
															"          properties: {",
															"            msg: { type: \"string\" },",
															"            value: { type: \"string\" },",
															"            param: { type: \"string\" },",
															"            location: { type: \"string\" }",
															"          },",
															"          required: [\"msg\"],",
															"          additionalProperties: true",
															"        }",
															"      }",
															"    },",
															"    required: [\"errors\"],",
															"    additionalProperties: true",
															"  };",
															"  pm.response.to.have.jsonSchema(schema);",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{indexerBaseUrl}}/affiliates/metadata?address={{invaliddYdXAddress}}",
													"host": [
														"{{indexerBaseUrl}}"
													],
													"path": [
														"affiliates",
														"metadata"
													],
													"query": [
														{
															"key": "address",
															"value": "{{invaliddYdXAddress}}"
														}
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "address",
									"item": [
										{
											"name": "/affiliates/address valid referralCode",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"// Helpers",
															"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
															"const dydxAddressRe = /^dydx1[a-z0-9]{38}$/;",
															"",
															"// 1) Status + latency",
															"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
															"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
															"",
															"// 2) Shape and address format",
															"const body = asJson();",
															"pm.test(\"has address (non-empty string)\", () => {",
															"  pm.expect(body).to.be.an(\"object\");",
															"  pm.expect(body.address).to.be.a(\"string\").and.not.be.empty;",
															"});",
															"pm.test(\"address matches dydx format\", () => pm.expect(body.address).to.match(dydxAddressRe));",
															"",
															"// 3) (Optional) store for reuse",
															"pm.environment.set(\"affiliateAddressFromCode\", body.address);",
															"",
															"// 4) JSON schema guard (allows future fields)",
															"pm.test(\"matches schema\", () => {",
															"  const schema = {",
															"    type: \"object\",",
															"    properties: { address: { type: \"string\", pattern: \"^dydx1[a-z0-9]{38}$\" } },",
															"    required: [\"address\"],",
															"    additionalProperties: true",
															"  };",
															"  pm.response.to.have.jsonSchema(schema);",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{indexerBaseUrl}}/affiliates/address?referralCode={{referralCode}}",
													"host": [
														"{{indexerBaseUrl}}"
													],
													"path": [
														"affiliates",
														"address"
													],
													"query": [
														{
															"key": "referralCode",
															"value": "{{referralCode}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "/affiliates/address invalid referralCode",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"// Helpers",
															"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
															"",
															"// 1) Status (API returns 404 for nonexistent referral; allow 400 if validation)",
															"pm.test(\"status is 404 or 400\", () => pm.expect(pm.response.code).to.be.oneOf([404, 400]));",
															"",
															"// 2) Errors array present",
															"const body = asJson();",
															"pm.test(\"has errors[]\", () => {",
															"  pm.expect(body).to.have.property(\"errors\").that.is.an(\"array\").with.length.greaterThan(0);",
															"});",
															"",
															"// 3) Error objects have msg (string)",
															"pm.test(\"error objects have msg\", () => {",
															"  body.errors.forEach((err) => pm.expect(err.msg).to.be.a(\"string\"));",
															"});",
															"",
															"// 4) Message matches expected text",
															"pm.test(\"referral code does not exist message\", () => {",
															"  const expected = `Referral code ${pm.environment.get(\"invalidReferralCode\")} does not exist`;",
															"  pm.expect(body.errors[0].msg).to.eql(expected);",
															"});",
															"",
															"// 5) Minimal schema guard",
															"pm.test(\"matches error schema\", () => {",
															"  const schema = {",
															"    type: \"object\",",
															"    properties: {",
															"      errors: {",
															"        type: \"array\",",
															"        minItems: 1,",
															"        items: {",
															"          type: \"object\",",
															"          properties: { msg: { type: \"string\" } },",
															"          required: [\"msg\"],",
															"          additionalProperties: true",
															"        }",
															"      }",
															"    },",
															"    required: [\"errors\"],",
															"    additionalProperties: true",
															"  };",
															"  pm.response.to.have.jsonSchema(schema);",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{indexerBaseUrl}}/affiliates/address?referralCode={{invalidReferralCode}}",
													"host": [
														"{{indexerBaseUrl}}"
													],
													"path": [
														"affiliates",
														"address"
													],
													"query": [
														{
															"key": "referralCode",
															"value": "{{invalidReferralCode}}"
														}
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "snapshot",
									"item": [
										{
											"name": "/affiliates/snapshot valid",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"// Helpers",
															"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
															"const dydxAddressRe = /^dydx1[a-z0-9]{38}$/;",
															"",
															"// 1) Status + latency",
															"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
															"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
															"",
															"// 2) Shape",
															"const body = asJson();",
															"pm.test(\"has affiliateList[], currentOffset, total\", () => {",
															"  pm.expect(body).to.be.an(\"object\");",
															"  pm.expect(body.affiliateList).to.be.an(\"array\");",
															"  pm.expect(body.currentOffset).to.be.a(\"number\");",
															"  pm.expect(body.total).to.be.a(\"number\");",
															"});",
															"",
															"// 3) Pagination sanity",
															"pm.test(\"pagination respects limit/offset\", () => {",
															"  pm.expect(body.currentOffset).to.equal(0);",
															"  pm.expect(body.affiliateList.length).to.be.at.most(10);",
															"});",
															"",
															"// 4) Affiliate objects schema + values",
															"pm.test(\"affiliate objects valid\", () => {",
															"  body.affiliateList.forEach((a, i) => {",
															"    pm.expect(a.affiliateAddress, `addr ${i}`).to.be.a(\"string\").and.match(dydxAddressRe);",
															"    pm.expect(a.affiliateReferralCode, `code ${i}`).to.be.a(\"string\").and.not.be.empty;",
															"    [",
															"      \"affiliateEarnings\",",
															"      \"affiliateReferredTrades\",",
															"      \"affiliateTotalReferredFees\",",
															"      \"affiliateReferredUsers\",",
															"      \"affiliateReferredNetProtocolEarnings\",",
															"      \"affiliateReferredTotalVolume\",",
															"      \"affiliateReferredMakerFees\",",
															"      \"affiliateReferredTakerFees\",",
															"      \"affiliateReferredMakerRebates\"",
															"    ].forEach((k) => pm.expect(a[k], `${k} ${i}`).to.be.a(\"number\"));",
															"    // Non-negatives except makerRebates (can be negative)",
															"    [",
															"      \"affiliateEarnings\",",
															"      \"affiliateReferredTrades\",",
															"      \"affiliateTotalReferredFees\",",
															"      \"affiliateReferredUsers\",",
															"      \"affiliateReferredNetProtocolEarnings\",",
															"      \"affiliateReferredTotalVolume\",",
															"      \"affiliateReferredMakerFees\",",
															"      \"affiliateReferredTakerFees\"",
															"    ].forEach((k) => pm.expect(a[k], `${k} ${i}`).to.be.at.least(0));",
															"  });",
															"});",
															"",
															"// 5) Schema guard",
															"pm.test(\"matches schema\", () => {",
															"  const schema = {",
															"    type: \"object\",",
															"    properties: {",
															"      affiliateList: {",
															"        type: \"array\",",
															"        items: {",
															"          type: \"object\",",
															"          properties: {",
															"            affiliateAddress: { type: \"string\", pattern: \"^dydx1[a-z0-9]{38}$\" },",
															"            affiliateReferralCode: { type: \"string\" },",
															"            affiliateEarnings: { type: \"number\" },",
															"            affiliateReferredTrades: { type: \"number\" },",
															"            affiliateTotalReferredFees: { type: \"number\" },",
															"            affiliateReferredUsers: { type: \"number\" },",
															"            affiliateReferredNetProtocolEarnings: { type: \"number\" },",
															"            affiliateReferredTotalVolume: { type: \"number\" },",
															"            affiliateReferredMakerFees: { type: \"number\" },",
															"            affiliateReferredTakerFees: { type: \"number\" },",
															"            affiliateReferredMakerRebates: { type: \"number\" }",
															"          },",
															"          required: [",
															"            \"affiliateAddress\",",
															"            \"affiliateReferralCode\",",
															"            \"affiliateEarnings\",",
															"            \"affiliateReferredTrades\",",
															"            \"affiliateTotalReferredFees\",",
															"            \"affiliateReferredUsers\",",
															"            \"affiliateReferredNetProtocolEarnings\",",
															"            \"affiliateReferredTotalVolume\",",
															"            \"affiliateReferredMakerFees\",",
															"            \"affiliateReferredTakerFees\",",
															"            \"affiliateReferredMakerRebates\"",
															"          ],",
															"          additionalProperties: true",
															"        }",
															"      },",
															"      currentOffset: { type: \"number\" },",
															"      total: { type: \"number\" }",
															"    },",
															"    required: [\"affiliateList\", \"currentOffset\", \"total\"],",
															"    additionalProperties: true",
															"  };",
															"  pm.response.to.have.jsonSchema(schema);",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{indexerBaseUrl}}/affiliates/snapshot?addressFilter={{dydxWithReferrals}}&offset=0&limit=10",
													"host": [
														"{{indexerBaseUrl}}"
													],
													"path": [
														"affiliates",
														"snapshot"
													],
													"query": [
														{
															"key": "addressFilter",
															"value": "{{dydxWithReferrals}}"
														},
														{
															"key": "offset",
															"value": "0"
														},
														{
															"key": "limit",
															"value": "10"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "/affiliates/snapshot pagination limit 1",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"// Helpers",
															"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
															"const dydxAddressRe = /^dydx1[a-z0-9]{38}$/;",
															"",
															"// 1) Status + latency",
															"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
															"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
															"",
															"// 2) Shape",
															"const body = asJson();",
															"pm.test(\"has affiliateList[], currentOffset, total\", () => {",
															"  pm.expect(body).to.be.an(\"object\");",
															"  pm.expect(body.affiliateList).to.be.an(\"array\");",
															"  pm.expect(body.currentOffset).to.be.a(\"number\");",
															"  pm.expect(body.total).to.be.a(\"number\");",
															"});",
															"",
															"// 3) Pagination sanity (limit=1)",
															"pm.test(\"returns at most 1 affiliate\", () => pm.expect(body.affiliateList.length).to.be.at.most(1));",
															"pm.test(\"offset honored\", () => pm.expect(body.currentOffset).to.equal(0));",
															"",
															"// 4) Affiliate object schema + values",
															"pm.test(\"affiliate object fields valid\", () => {",
															"  body.affiliateList.forEach((a, i) => {",
															"    pm.expect(a.affiliateAddress, `addr ${i}`).to.be.a(\"string\").and.match(dydxAddressRe);",
															"    pm.expect(a.affiliateReferralCode, `code ${i}`).to.be.a(\"string\").and.not.be.empty;",
															"    [",
															"      \"affiliateEarnings\",",
															"      \"affiliateReferredTrades\",",
															"      \"affiliateTotalReferredFees\",",
															"      \"affiliateReferredUsers\",",
															"      \"affiliateReferredNetProtocolEarnings\",",
															"      \"affiliateReferredTotalVolume\",",
															"      \"affiliateReferredMakerFees\",",
															"      \"affiliateReferredTakerFees\",",
															"      \"affiliateReferredMakerRebates\"",
															"    ].forEach((k) => pm.expect(a[k], `${k} ${i}`).to.be.a(\"number\"));",
															"    // Non-negatives except makerRebates (can be negative)",
															"    [",
															"      \"affiliateEarnings\",",
															"      \"affiliateReferredTrades\",",
															"      \"affiliateTotalReferredFees\",",
															"      \"affiliateReferredUsers\",",
															"      \"affiliateReferredNetProtocolEarnings\",",
															"      \"affiliateReferredTotalVolume\",",
															"      \"affiliateReferredMakerFees\",",
															"      \"affiliateReferredTakerFees\"",
															"    ].forEach((k) => pm.expect(a[k], `${k} ${i}`).to.be.at.least(0));",
															"  });",
															"});",
															"",
															"// 5) JSON schema guard",
															"pm.test(\"matches schema\", () => {",
															"  const schema = {",
															"    type: \"object\",",
															"    properties: {",
															"      affiliateList: {",
															"        type: \"array\",",
															"        maxItems: 1,",
															"        items: {",
															"          type: \"object\",",
															"          properties: {",
															"            affiliateAddress: { type: \"string\", pattern: \"^dydx1[a-z0-9]{38}$\" },",
															"            affiliateReferralCode: { type: \"string\" },",
															"            affiliateEarnings: { type: \"number\" },",
															"            affiliateReferredTrades: { type: \"number\" },",
															"            affiliateTotalReferredFees: { type: \"number\" },",
															"            affiliateReferredUsers: { type: \"number\" },",
															"            affiliateReferredNetProtocolEarnings: { type: \"number\" },",
															"            affiliateReferredTotalVolume: { type: \"number\" },",
															"            affiliateReferredMakerFees: { type: \"number\" },",
															"            affiliateReferredTakerFees: { type: \"number\" },",
															"            affiliateReferredMakerRebates: { type: \"number\" }",
															"          },",
															"          required: [",
															"            \"affiliateAddress\",",
															"            \"affiliateReferralCode\",",
															"            \"affiliateEarnings\",",
															"            \"affiliateReferredTrades\",",
															"            \"affiliateTotalReferredFees\",",
															"            \"affiliateReferredUsers\",",
															"            \"affiliateReferredNetProtocolEarnings\",",
															"            \"affiliateReferredTotalVolume\",",
															"            \"affiliateReferredMakerFees\",",
															"            \"affiliateReferredTakerFees\",",
															"            \"affiliateReferredMakerRebates\"",
															"          ],",
															"          additionalProperties: true",
															"        }",
															"      },",
															"      currentOffset: { type: \"number\" },",
															"      total: { type: \"number\" }",
															"    },",
															"    required: [\"affiliateList\", \"currentOffset\", \"total\"],",
															"    additionalProperties: true",
															"  };",
															"  pm.response.to.have.jsonSchema(schema);",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{indexerBaseUrl}}/affiliates/snapshot?addressFilter[]={{dydxWithReferrals}}&addressFilter[]={{dydxWithReferrals2}}&offset=0&limit=1",
													"host": [
														"{{indexerBaseUrl}}"
													],
													"path": [
														"affiliates",
														"snapshot"
													],
													"query": [
														{
															"key": "addressFilter[]",
															"value": "{{dydxWithReferrals}}"
														},
														{
															"key": "addressFilter[]",
															"value": "{{dydxWithReferrals2}}"
														},
														{
															"key": "offset",
															"value": "0"
														},
														{
															"key": "limit",
															"value": "1"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "/affiliates/snapshot pagination limit 0",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"// Helpers",
															"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
															"",
															"// 1) Status",
															"pm.test(\"status 400\", () => pm.response.to.have.status(400));",
															"",
															"// 2) Errors array present",
															"const body = asJson();",
															"pm.test(\"has errors[]\", () => {",
															"  pm.expect(body).to.have.property(\"errors\").that.is.an(\"array\").with.length.greaterThan(0);",
															"});",
															"",
															"// 3) Error objects shape",
															"pm.test(\"errors have value/msg/param/location\", () => {",
															"  body.errors.forEach((err) => {",
															"    [\"value\", \"msg\", \"param\", \"location\"].forEach((k) => pm.expect(err).to.have.property(k).that.is.a(\"string\"));",
															"  });",
															"});",
															"",
															"// 4) Specific limit error present",
															"pm.test(\"limit=0 yields expected validation error\", () => {",
															"  const match = body.errors.find(",
															"    (e) =>",
															"      e.value === \"0\" &&",
															"      e.msg === \"limit must be a valid integer\" &&",
															"      e.param === \"limit\" &&",
															"      e.location === \"query\"",
															"  );",
															"  pm.expect(match, \"expected limit error not found\").to.exist;",
															"});",
															"",
															"// 5) Minimal schema guard",
															"pm.test(\"matches error schema\", () => {",
															"  const schema = {",
															"    type: \"object\",",
															"    properties: {",
															"      errors: {",
															"        type: \"array\",",
															"        minItems: 1,",
															"        items: {",
															"          type: \"object\",",
															"          properties: {",
															"            value: { type: \"string\" },",
															"            msg: { type: \"string\" },",
															"            param: { type: \"string\" },",
															"            location: { type: \"string\" }",
															"          },",
															"          required: [\"value\", \"msg\", \"param\", \"location\"],",
															"          additionalProperties: true",
															"        }",
															"      }",
															"    },",
															"    required: [\"errors\"],",
															"    additionalProperties: true",
															"  };",
															"  pm.response.to.have.jsonSchema(schema);",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{indexerBaseUrl}}/affiliates/snapshot?addressFilter[]={{dydxWithReferrals}}&addressFilter[]={{dydxWithReferrals2}}&offset=0&limit=0",
													"host": [
														"{{indexerBaseUrl}}"
													],
													"path": [
														"affiliates",
														"snapshot"
													],
													"query": [
														{
															"key": "addressFilter[]",
															"value": "{{dydxWithReferrals}}"
														},
														{
															"key": "addressFilter[]",
															"value": "{{dydxWithReferrals2}}"
														},
														{
															"key": "offset",
															"value": "0"
														},
														{
															"key": "limit",
															"value": "0"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "/affiliates/snapshot pagination limit 2",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"// Helpers",
															"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
															"const dydxAddressRe = /^dydx1[a-z0-9]{38}$/;",
															"",
															"// 1) Status + latency",
															"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
															"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
															"",
															"// 2) Shape",
															"const body = asJson();",
															"pm.test(\"has affiliateList[], currentOffset, total\", () => {",
															"  pm.expect(body).to.be.an(\"object\");",
															"  pm.expect(body.affiliateList).to.be.an(\"array\");",
															"  pm.expect(body.currentOffset).to.be.a(\"number\");",
															"  pm.expect(body.total).to.be.a(\"number\");",
															"});",
															"",
															"// 3) Pagination sanity",
															"pm.test(\"returns ≤ limit and offset honored\", () => {",
															"  pm.expect(body.currentOffset).to.equal(0);",
															"  pm.expect(body.affiliateList.length).to.be.at.most(3);",
															"  pm.expect(body.total).to.be.at.least(body.affiliateList.length);",
															"});",
															"",
															"// 4) Affiliate objects schema + values",
															"pm.test(\"affiliate objects valid\", () => {",
															"  body.affiliateList.forEach((a, i) => {",
															"    pm.expect(a.affiliateAddress, `addr ${i}`).to.be.a(\"string\").and.match(dydxAddressRe);",
															"    pm.expect(a.affiliateReferralCode, `code ${i}`).to.be.a(\"string\").and.not.be.empty;",
															"    [",
															"      \"affiliateEarnings\",",
															"      \"affiliateReferredTrades\",",
															"      \"affiliateTotalReferredFees\",",
															"      \"affiliateReferredUsers\",",
															"      \"affiliateReferredNetProtocolEarnings\",",
															"      \"affiliateReferredTotalVolume\",",
															"      \"affiliateReferredMakerFees\",",
															"      \"affiliateReferredTakerFees\",",
															"      \"affiliateReferredMakerRebates\"",
															"    ].forEach((k) => pm.expect(a[k], `${k} ${i}`).to.be.a(\"number\"));",
															"    // Non-negatives except makerRebates (can be negative)",
															"    [",
															"      \"affiliateEarnings\",",
															"      \"affiliateReferredTrades\",",
															"      \"affiliateTotalReferredFees\",",
															"      \"affiliateReferredUsers\",",
															"      \"affiliateReferredNetProtocolEarnings\",",
															"      \"affiliateReferredTotalVolume\",",
															"      \"affiliateReferredMakerFees\",",
															"      \"affiliateReferredTakerFees\"",
															"    ].forEach((k) => pm.expect(a[k], `${k} ${i}`).to.be.at.least(0));",
															"  });",
															"});",
															"",
															"// 5) JSON schema guard",
															"pm.test(\"matches schema\", () => {",
															"  const schema = {",
															"    type: \"object\",",
															"    properties: {",
															"      affiliateList: {",
															"        type: \"array\",",
															"        maxItems: 3,",
															"        items: {",
															"          type: \"object\",",
															"          properties: {",
															"            affiliateAddress: { type: \"string\", pattern: \"^dydx1[a-z0-9]{38}$\" },",
															"            affiliateReferralCode: { type: \"string\" },",
															"            affiliateEarnings: { type: \"number\" },",
															"            affiliateReferredTrades: { type: \"number\" },",
															"            affiliateTotalReferredFees: { type: \"number\" },",
															"            affiliateReferredUsers: { type: \"number\" },",
															"            affiliateReferredNetProtocolEarnings: { type: \"number\" },",
															"            affiliateReferredTotalVolume: { type: \"number\" },",
															"            affiliateReferredMakerFees: { type: \"number\" },",
															"            affiliateReferredTakerFees: { type: \"number\" },",
															"            affiliateReferredMakerRebates: { type: \"number\" }",
															"          },",
															"          required: [",
															"            \"affiliateAddress\",",
															"            \"affiliateReferralCode\",",
															"            \"affiliateEarnings\",",
															"            \"affiliateReferredTrades\",",
															"            \"affiliateTotalReferredFees\",",
															"            \"affiliateReferredUsers\",",
															"            \"affiliateReferredNetProtocolEarnings\",",
															"            \"affiliateReferredTotalVolume\",",
															"            \"affiliateReferredMakerFees\",",
															"            \"affiliateReferredTakerFees\",",
															"            \"affiliateReferredMakerRebates\"",
															"          ],",
															"          additionalProperties: true",
															"        }",
															"      },",
															"      currentOffset: { type: \"number\" },",
															"      total: { type: \"number\" }",
															"    },",
															"    required: [\"affiliateList\", \"currentOffset\", \"total\"],",
															"    additionalProperties: true",
															"  };",
															"  pm.response.to.have.jsonSchema(schema);",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{indexerBaseUrl}}/affiliates/snapshot?addressFilter[]={{dydxWithReferrals}}&addressFilter[]={{dydxWithReferrals2}}&offset=0&limit=3",
													"host": [
														"{{indexerBaseUrl}}"
													],
													"path": [
														"affiliates",
														"snapshot"
													],
													"query": [
														{
															"key": "addressFilter[]",
															"value": "{{dydxWithReferrals}}"
														},
														{
															"key": "addressFilter[]",
															"value": "{{dydxWithReferrals2}}"
														},
														{
															"key": "offset",
															"value": "0"
														},
														{
															"key": "limit",
															"value": "3"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "/affiliates/snapshot pagination limit 999999",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"// Helpers",
															"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
															"const dydxAddressRe = /^dydx1[a-z0-9]{38}$/;",
															"",
															"// 1) Status + latency",
															"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
															"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
															"",
															"// 2) Shape",
															"const body = asJson();",
															"pm.test(\"has affiliateList[], currentOffset, total\", () => {",
															"  pm.expect(body).to.be.an(\"object\");",
															"  pm.expect(body.affiliateList).to.be.an(\"array\");",
															"  pm.expect(body.currentOffset).to.be.a(\"number\");",
															"  pm.expect(body.total).to.be.a(\"number\");",
															"});",
															"",
															"// 3) Pagination sanity (very large limit)",
															"pm.test(\"returns all up to total, offset honored\", () => {",
															"  pm.expect(body.currentOffset).to.equal(0);",
															"  pm.expect(body.affiliateList.length).to.be.at.most(body.total);",
															"});",
															"",
															"// 4) Affiliate objects schema + values",
															"pm.test(\"affiliate objects valid\", () => {",
															"  body.affiliateList.forEach((a, i) => {",
															"    pm.expect(a.affiliateAddress, `addr ${i}`).to.be.a(\"string\").and.match(dydxAddressRe);",
															"    pm.expect(a.affiliateReferralCode, `code ${i}`).to.be.a(\"string\").and.not.be.empty;",
															"    [",
															"      \"affiliateEarnings\",",
															"      \"affiliateReferredTrades\",",
															"      \"affiliateTotalReferredFees\",",
															"      \"affiliateReferredUsers\",",
															"      \"affiliateReferredNetProtocolEarnings\",",
															"      \"affiliateReferredTotalVolume\",",
															"      \"affiliateReferredMakerFees\",",
															"      \"affiliateReferredTakerFees\",",
															"      \"affiliateReferredMakerRebates\"",
															"    ].forEach((k) => pm.expect(a[k], `${k} ${i}`).to.be.a(\"number\"));",
															"    // Non-negatives except makerRebates (can be negative)",
															"    [",
															"      \"affiliateEarnings\",",
															"      \"affiliateReferredTrades\",",
															"      \"affiliateTotalReferredFees\",",
															"      \"affiliateReferredUsers\",",
															"      \"affiliateReferredNetProtocolEarnings\",",
															"      \"affiliateReferredTotalVolume\",",
															"      \"affiliateReferredMakerFees\",",
															"      \"affiliateReferredTakerFees\"",
															"    ].forEach((k) => pm.expect(a[k], `${k} ${i}`).to.be.at.least(0));",
															"  });",
															"});",
															"",
															"// 5) JSON schema guard",
															"pm.test(\"matches schema\", () => {",
															"  const schema = {",
															"    type: \"object\",",
															"    properties: {",
															"      affiliateList: {",
															"        type: \"array\",",
															"        items: {",
															"          type: \"object\",",
															"          properties: {",
															"            affiliateAddress: { type: \"string\", pattern: \"^dydx1[a-z0-9]{38}$\" },",
															"            affiliateReferralCode: { type: \"string\" },",
															"            affiliateEarnings: { type: \"number\" },",
															"            affiliateReferredTrades: { type: \"number\" },",
															"            affiliateTotalReferredFees: { type: \"number\" },",
															"            affiliateReferredUsers: { type: \"number\" },",
															"            affiliateReferredNetProtocolEarnings: { type: \"number\" },",
															"            affiliateReferredTotalVolume: { type: \"number\" },",
															"            affiliateReferredMakerFees: { type: \"number\" },",
															"            affiliateReferredTakerFees: { type: \"number\" },",
															"            affiliateReferredMakerRebates: { type: \"number\" }",
															"          },",
															"          required: [",
															"            \"affiliateAddress\",",
															"            \"affiliateReferralCode\",",
															"            \"affiliateEarnings\",",
															"            \"affiliateReferredTrades\",",
															"            \"affiliateTotalReferredFees\",",
															"            \"affiliateReferredUsers\",",
															"            \"affiliateReferredNetProtocolEarnings\",",
															"            \"affiliateReferredTotalVolume\",",
															"            \"affiliateReferredMakerFees\",",
															"            \"affiliateReferredTakerFees\",",
															"            \"affiliateReferredMakerRebates\"",
															"          ],",
															"          additionalProperties: true",
															"        }",
															"      },",
															"      currentOffset: { type: \"number\" },",
															"      total: { type: \"number\" }",
															"    },",
															"    required: [\"affiliateList\", \"currentOffset\", \"total\"],",
															"    additionalProperties: true",
															"  };",
															"  pm.response.to.have.jsonSchema(schema);",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{indexerBaseUrl}}/affiliates/snapshot?addressFilter[]={{dydxWithReferrals}}&addressFilter[]={{dydxWithReferrals2}}&offset=0&limit=999999",
													"host": [
														"{{indexerBaseUrl}}"
													],
													"path": [
														"affiliates",
														"snapshot"
													],
													"query": [
														{
															"key": "addressFilter[]",
															"value": "{{dydxWithReferrals}}"
														},
														{
															"key": "addressFilter[]",
															"value": "{{dydxWithReferrals2}}"
														},
														{
															"key": "offset",
															"value": "0"
														},
														{
															"key": "limit",
															"value": "999999"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "/affiliates/snapshot invalid",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"// Helpers",
															"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
															"",
															"// 1) Status + latency",
															"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
															"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
															"",
															"// 2) Shape",
															"const body = asJson();",
															"pm.test(\"has affiliateList[], currentOffset, total\", () => {",
															"  pm.expect(body).to.be.an(\"object\");",
															"  pm.expect(body.affiliateList).to.be.an(\"array\");",
															"  pm.expect(body.currentOffset).to.be.a(\"number\");",
															"  pm.expect(body.total).to.be.a(\"number\");",
															"});",
															"",
															"// 3) Empty list for invalid address",
															"pm.test(\"affiliateList empty for invalid address\", () => {",
															"  pm.expect(body.affiliateList).to.be.an(\"array\").that.is.empty;",
															"  pm.expect(body.currentOffset).to.equal(0);",
															"  pm.expect(body.total).to.equal(0);",
															"});",
															"",
															"// 4) JSON schema guard",
															"pm.test(\"matches schema\", () => {",
															"  const schema = {",
															"    type: \"object\",",
															"    properties: {",
															"      affiliateList: { type: \"array\", maxItems: 0 },",
															"      currentOffset: { type: \"number\" },",
															"      total: { type: \"number\" }",
															"    },",
															"    required: [\"affiliateList\", \"currentOffset\", \"total\"],",
															"    additionalProperties: true",
															"  };",
															"  pm.response.to.have.jsonSchema(schema);",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{indexerBaseUrl}}/affiliates/snapshot?addressFilter[]={{invaliddYdXAddress}}&offset=0&limit=10",
													"host": [
														"{{indexerBaseUrl}}"
													],
													"path": [
														"affiliates",
														"snapshot"
													],
													"query": [
														{
															"key": "addressFilter[]",
															"value": "{{invaliddYdXAddress}}"
														},
														{
															"key": "offset",
															"value": "0"
														},
														{
															"key": "limit",
															"value": "10"
														}
													]
												}
											},
											"response": []
										}
									]
								}
							]
						},
						{
							"name": "assetPositions",
							"item": [
								{
									"name": "/assetPositions VALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"const isNumericString = (v) => v !== null && v !== undefined && !Number.isNaN(Number(v));",
													"",
													"// 1) Status + latency",
													"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
													"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
													"",
													"// 2) Top-level shape",
													"const body = asJson();",
													"pm.test(\"has positions[]\", () => {",
													"  pm.expect(body).to.be.an(\"object\");",
													"  pm.expect(body.positions).to.be.an(\"array\");",
													"});",
													"",
													"// 3) Position schema + numeric strings",
													"pm.test(\"positions schema valid\", () => {",
													"  const expectedKeys = [\"symbol\", \"side\", \"size\", \"assetId\", \"subaccountNumber\"];",
													"  body.positions.forEach((p, i) => {",
													"    pm.expect(p, `pos ${i}`).to.be.an(\"object\");",
													"    pm.expect(p.symbol).to.be.a(\"string\");",
													"    pm.expect(p.side).to.be.a(\"string\");",
													"    pm.expect(p.size).to.be.a(\"string\");",
													"    pm.expect(isNumericString(p.size), `size numeric ${i}`).to.be.true;",
													"    pm.expect(p.assetId).to.be.a(\"string\");",
													"    pm.expect(p.subaccountNumber).to.be.a(\"number\");",
													"    Object.keys(p).forEach((k) => pm.expect(expectedKeys).to.include(k, `Unexpected property: ${k}`));",
													"  });",
													"});",
													"",
													"// 4) JSON schema guard",
													"pm.test(\"matches schema\", () => {",
													"  const schema = {",
													"    type: \"object\",",
													"    properties: {",
													"      positions: {",
													"        type: \"array\",",
													"        items: {",
													"          type: \"object\",",
													"          properties: {",
													"            symbol: { type: \"string\" },",
													"            side: { type: \"string\" },",
													"            size: { type: \"string\" },",
													"            assetId: { type: \"string\" },",
													"            subaccountNumber: { type: \"number\" }",
													"          },",
													"          required: [\"symbol\", \"side\", \"size\", \"assetId\", \"subaccountNumber\"],",
													"          additionalProperties: false",
													"        }",
													"      }",
													"    },",
													"    required: [\"positions\"],",
													"    additionalProperties: false",
													"  };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/assetPositions/?address={{validdYdXAddress}}&subaccountNumber=0",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"assetPositions",
												""
											],
											"query": [
												{
													"key": "address",
													"value": "{{validdYdXAddress}}"
												},
												{
													"key": "subaccountNumber",
													"value": "0"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "/assetPositions INVALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"",
													"// 1) Status",
													"pm.test(\"status 400\", () => pm.response.to.have.status(400));",
													"",
													"// 2) Errors array",
													"const body = asJson();",
													"pm.test(\"has errors[]\", () => {",
													"  pm.expect(body).to.have.property(\"errors\").that.is.an(\"array\").with.length.greaterThan(0);",
													"});",
													"",
													"// 3) Specific subaccountNumber validation error",
													"pm.test(\"subaccountNumber validation error present\", () => {",
													"  const err = body.errors.find((e) => e.param === \"subaccountNumber\") || body.errors[0];",
													"  pm.expect(err.value).to.eql(\"-\");",
													"  pm.expect(err.msg).to.eql(\"subaccountNumber must be a non-negative integer less than 128001\");",
													"  pm.expect(err.param).to.eql(\"subaccountNumber\");",
													"  pm.expect(err.location).to.eql(\"query\");",
													"});",
													"",
													"// 4) Schema guard",
													"pm.test(\"matches error schema\", () => {",
													"  const schema = {",
													"    type: \"object\",",
													"    properties: {",
													"      errors: {",
													"        type: \"array\",",
													"        minItems: 1,",
													"        items: {",
													"          type: \"object\",",
													"          properties: {",
													"            value: { type: \"string\" },",
													"            msg: { type: \"string\" },",
													"            param: { type: \"string\" },",
													"            location: { type: \"string\" }",
													"          },",
													"          required: [\"value\", \"msg\", \"param\", \"location\"],",
													"          additionalProperties: true",
													"        }",
													"      }",
													"    },",
													"    required: [\"errors\"],",
													"    additionalProperties: true",
													"  };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/assetPositions/?address={{validdYdXAddress}}&subaccountNumber=-",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"assetPositions",
												""
											],
											"query": [
												{
													"key": "address",
													"value": "{{validdYdXAddress}}"
												},
												{
													"key": "subaccountNumber",
													"value": "-"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "/assetPositions/parentSubaccountNumber VALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"const isNumericString = (v) => v !== null && v !== undefined && !Number.isNaN(Number(v));",
													"const dydxAddressRe = /^dydx1[a-z0-9]{38}$/;",
													"",
													"// 1) Status + latency",
													"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
													"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
													"",
													"// 2) Top-level shape",
													"const body = asJson();",
													"pm.test(\"has subaccount object\", () => {",
													"  pm.expect(body).to.be.an(\"object\");",
													"  pm.expect(body.subaccount).to.be.an(\"object\");",
													"});",
													"",
													"// 3) Parent subaccount fields",
													"pm.test(\"parent subaccount schema + numeric strings\", () => {",
													"  const s = body.subaccount;",
													"  pm.expect(s.address).to.be.a(\"string\").and.match(dydxAddressRe);",
													"  pm.expect(s.parentSubaccountNumber).to.be.a(\"number\");",
													"  [\"equity\", \"freeCollateral\"].forEach((k) => {",
													"    pm.expect(s[k]).to.be.a(\"string\");",
													"    pm.expect(isNumericString(s[k]), `${k} numeric`).to.be.true;",
													"  });",
													"  pm.expect(s.childSubaccounts).to.be.an(\"array\");",
													"});",
													"",
													"// 4) Child subaccounts",
													"pm.test(\"child subaccounts schema\", () => {",
													"  const children = body.subaccount.childSubaccounts;",
													"  pm.expect(children.length).to.be.above(0);",
													"  children.forEach((c, i) => {",
													"    pm.expect(c.address, `addr ${i}`).to.be.a(\"string\").and.match(dydxAddressRe);",
													"    pm.expect(c.subaccountNumber).to.be.a(\"number\");",
													"    [\"equity\", \"freeCollateral\", \"updatedAtHeight\", \"latestProcessedBlockHeight\"].forEach((k) => {",
													"      pm.expect(c[k]).to.be.a(\"string\");",
													"      pm.expect(isNumericString(c[k]), `${k} numeric ${i}`).to.be.true;",
													"    });",
													"    pm.expect(c.marginEnabled).to.be.a(\"boolean\");",
													"    pm.expect(c.openPerpetualPositions).to.be.an(\"object\");",
													"    pm.expect(c.assetPositions).to.be.an(\"object\");",
													"  });",
													"});",
													"",
													"// 5) Asset positions for each child (if any)",
													"pm.test(\"child assetPositions valid\", () => {",
													"  const children = body.subaccount.childSubaccounts;",
													"  children.forEach((c, i) => {",
													"    const assets = c.assetPositions || {};",
													"    Object.values(assets).forEach((pos, j) => {",
													"      [\"size\", \"symbol\", \"side\"].forEach((k) => pm.expect(pos[k], `child ${i} asset ${j} ${k}`).to.be.a(\"string\"));",
													"      pm.expect(isNumericString(pos.size), `child ${i} asset ${j} size numeric`).to.be.true;",
													"      pm.expect(pos.assetId).to.be.a(\"string\");",
													"      pm.expect(pos.subaccountNumber).to.eql(c.subaccountNumber);",
													"    });",
													"  });",
													"});",
													"",
													"// 6) JSON schema guard",
													"pm.test(\"matches schema\", () => {",
													"  const schema = {",
													"    type: \"object\",",
													"    properties: {",
													"      subaccount: {",
													"        type: \"object\",",
													"        properties: {",
													"          address: { type: \"string\", pattern: \"^dydx1[a-z0-9]{38}$\" },",
													"          parentSubaccountNumber: { type: \"number\" },",
													"          equity: { type: \"string\" },",
													"          freeCollateral: { type: \"string\" },",
													"          childSubaccounts: {",
													"            type: \"array\",",
													"            items: {",
													"              type: \"object\",",
													"              properties: {",
													"                address: { type: \"string\", pattern: \"^dydx1[a-z0-9]{38}$\" },",
													"                subaccountNumber: { type: \"number\" },",
													"                equity: { type: \"string\" },",
													"                freeCollateral: { type: \"string\" },",
													"                openPerpetualPositions: { type: \"object\" },",
													"                assetPositions: { type: \"object\" },",
													"                marginEnabled: { type: \"boolean\" },",
													"                updatedAtHeight: { type: \"string\" },",
													"                latestProcessedBlockHeight: { type: \"string\" }",
													"              },",
													"              required: [",
													"                \"address\",",
													"                \"subaccountNumber\",",
													"                \"equity\",",
													"                \"freeCollateral\",",
													"                \"openPerpetualPositions\",",
													"                \"assetPositions\",",
													"                \"marginEnabled\",",
													"                \"updatedAtHeight\",",
													"                \"latestProcessedBlockHeight\"",
													"              ],",
													"              additionalProperties: false",
													"            }",
													"          }",
													"        },",
													"        required: [\"address\", \"parentSubaccountNumber\", \"equity\", \"freeCollateral\", \"childSubaccounts\"],",
													"        additionalProperties: false",
													"      }",
													"    },",
													"    required: [\"subaccount\"],",
													"    additionalProperties: false",
													"  };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/addresses/{{validdYdXAddress}}/parentSubaccountNumber/0",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"addresses",
												"{{validdYdXAddress}}",
												"parentSubaccountNumber",
												"0"
											]
										}
									},
									"response": []
								},
								{
									"name": "/assetPositions/parentSubaccountNumber INVALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"",
													"// 1) Status",
													"pm.test(\"status 400\", () => pm.response.to.have.status(400));",
													"",
													"// 2) Errors array",
													"const body = asJson();",
													"pm.test(\"has errors[]\", () => {",
													"  pm.expect(body).to.have.property(\"errors\").that.is.an(\"array\").with.length.greaterThan(0);",
													"});",
													"",
													"// 3) Specific parentSubaccountNumber validation error",
													"pm.test(\"parentSubaccountNumber validation error present\", () => {",
													"  const err = body.errors.find((e) => e.param === \"parentSubaccountNumber\") || body.errors[0];",
													"  pm.expect(err.value).to.eql(\"-\");",
													"  pm.expect(err.msg).to.eql(\"parentSubaccountNumber must be a non-negative integer less than 128\");",
													"  pm.expect(err.param).to.eql(\"parentSubaccountNumber\");",
													"  pm.expect(err.location).to.eql(\"params\");",
													"});",
													"",
													"// 4) Schema guard",
													"pm.test(\"matches error schema\", () => {",
													"  const schema = {",
													"    type: \"object\",",
													"    properties: {",
													"      errors: {",
													"        type: \"array\",",
													"        minItems: 1,",
													"        items: {",
													"          type: \"object\",",
													"          properties: {",
													"            value: { type: \"string\" },",
													"            msg: { type: \"string\" },",
													"            param: { type: \"string\" },",
													"            location: { type: \"string\" }",
													"          },",
													"          required: [\"value\", \"msg\", \"param\", \"location\"],",
													"          additionalProperties: true",
													"        }",
													"      }",
													"    },",
													"    required: [\"errors\"],",
													"    additionalProperties: true",
													"  };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/addresses/{{validdYdXAddress}}/parentSubaccountNumber/-",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"addresses",
												"{{validdYdXAddress}}",
												"parentSubaccountNumber",
												"-"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "candles",
							"item": [
								{
									"name": "/candles/perpetualMarkets/ticker/ VALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"const isNumericString = (v) => v !== null && v !== undefined && !Number.isNaN(Number(v));",
													"const isIso = (s) => /^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?Z)$/.test(s);",
													"",
													"// 1) Status + latency",
													"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
													"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
													"",
													"// 2) Shape",
													"const body = asJson();",
													"pm.test(\"has candles[]\", () => {",
													"  pm.expect(body).to.be.an(\"object\");",
													"  pm.expect(body.candles).to.be.an(\"array\").with.length.greaterThan(0);",
													"});",
													"",
													"// 3) Candle schema + value checks",
													"pm.test(\"candles have expected fields and types\", () => {",
													"  body.candles.forEach((c, i) => {",
													"    pm.expect(c.startedAt, `startedAt ${i}`).to.be.a(\"string\");",
													"    pm.expect(isIso(c.startedAt), `startedAt ISO ${i}`).to.be.true;",
													"    pm.expect(c.ticker, `ticker ${i}`).to.be.a(\"string\");",
													"    pm.expect(c.resolution, `resolution ${i}`).to.eql(\"1MIN\");",
													"    [\"low\", \"high\", \"open\", \"close\", \"baseTokenVolume\", \"usdVolume\", \"startingOpenInterest\"].forEach((k) => {",
													"      pm.expect(c[k], `${k} ${i}`).to.be.a(\"string\");",
													"      pm.expect(isNumericString(c[k]), `${k} numeric ${i}`).to.be.true;",
													"    });",
													"    pm.expect(c.trades, `trades ${i}`).to.be.a(\"number\");",
													"    // Optional fields",
													"    [\"orderbookMidPriceOpen\", \"orderbookMidPriceClose\"].forEach((k) => {",
													"      if (k in c && c[k] !== null) {",
													"        pm.expect(c[k], `${k} ${i}`).to.be.a(\"string\");",
													"        pm.expect(isNumericString(c[k]), `${k} numeric ${i}`).to.be.true;",
													"      }",
													"    });",
													"  });",
													"});",
													"",
													"// 4) Ordering (most recent first)",
													"pm.test(\"candles ordered by startedAt desc\", () => {",
													"  const ts = body.candles.map((c) => Date.parse(c.startedAt));",
													"  for (let i = 0; i < ts.length - 1; i++) {",
													"    pm.expect(ts[i]).to.be.at.least(ts[i + 1]);",
													"  }",
													"});",
													"",
													"// 5) JSON schema guard",
													"pm.test(\"matches schema\", () => {",
													"  const schema = {",
													"    type: \"object\",",
													"    properties: {",
													"      candles: {",
													"        type: \"array\",",
													"        minItems: 1,",
													"        items: {",
													"          type: \"object\",",
													"          properties: {",
													"            startedAt: { type: \"string\", format: \"date-time\" },",
													"            ticker: { type: \"string\" },",
													"            resolution: { type: \"string\", enum: [\"1MIN\"] },",
													"            low: { type: \"string\" },",
													"            high: { type: \"string\" },",
													"            open: { type: \"string\" },",
													"            close: { type: \"string\" },",
													"            baseTokenVolume: { type: \"string\" },",
													"            usdVolume: { type: \"string\" },",
													"            trades: { type: \"number\" },",
													"            startingOpenInterest: { type: \"string\" },",
													"            orderbookMidPriceOpen: { type: [\"string\", \"null\"] },",
													"            orderbookMidPriceClose: { type: [\"string\", \"null\"] }",
													"          },",
													"          required: [",
													"            \"startedAt\",",
													"            \"ticker\",",
													"            \"resolution\",",
													"            \"low\",",
													"            \"high\",",
													"            \"open\",",
													"            \"close\",",
													"            \"baseTokenVolume\",",
													"            \"usdVolume\",",
													"            \"trades\",",
													"            \"startingOpenInterest\"",
													"          ],",
													"          additionalProperties: true",
													"        }",
													"      }",
													"    },",
													"    required: [\"candles\"],",
													"    additionalProperties: true",
													"  };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/candles/perpetualMarkets/{{ticker}}?resolution=1MIN",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"candles",
												"perpetualMarkets",
												"{{ticker}}"
											],
											"query": [
												{
													"key": "resolution",
													"value": "1MIN"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "/candles/perpetualMarkets/ticker/ INVALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"",
													"// 1) Status",
													"pm.test(\"status 400\", () => pm.response.to.have.status(400));",
													"",
													"// 2) Errors array",
													"const body = asJson();",
													"pm.test(\"has errors[]\", () => {",
													"  pm.expect(body).to.have.property(\"errors\").that.is.an(\"array\").with.length.greaterThan(0);",
													"});",
													"",
													"// 3) Specific resolution validation error",
													"pm.test(\"resolution validation error present\", () => {",
													"  const err = body.errors.find((e) => e.param === \"resolution\") || body.errors[0];",
													"  pm.expect(err.value).to.eql(\"1MINS\");",
													"  pm.expect(err.msg).to.eql(\"resolution must be a valid Candle Resolution, one of 1MIN,5MINS,15MINS,30MINS,1HOUR,4HOURS,1DAY\");",
													"  pm.expect(err.param).to.eql(\"resolution\");",
													"  pm.expect(err.location).to.eql(\"query\");",
													"});",
													"",
													"// 4) Schema guard",
													"pm.test(\"matches error schema\", () => {",
													"  const schema = {",
													"    type: \"object\",",
													"    properties: {",
													"      errors: {",
													"        type: \"array\",",
													"        minItems: 1,",
													"        items: {",
													"          type: \"object\",",
													"          properties: {",
													"            value: { type: \"string\" },",
													"            msg: { type: \"string\" },",
													"            param: { type: \"string\" },",
													"            location: { type: \"string\" }",
													"          },",
													"          required: [\"value\", \"msg\", \"param\", \"location\"],",
													"          additionalProperties: true",
													"        }",
													"      }",
													"    },",
													"    required: [\"errors\"],",
													"    additionalProperties: true",
													"  };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/candles/perpetualMarkets/{{ticker}}?resolution=1MINS",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"candles",
												"perpetualMarkets",
												"{{ticker}}"
											],
											"query": [
												{
													"key": "resolution",
													"value": "1MINS"
												}
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "compliance",
							"item": [
								{
									"name": "screen",
									"item": [
										{
											"name": "/compliance/screen/ VALID",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"// Helpers",
															"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
															"const isIso = (s) => /^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?Z)$/.test(s);",
															"",
															"// 1) Status + latency",
															"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
															"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
															"",
															"// 2) Shape + types",
															"const body = asJson();",
															"pm.test(\"has status, reason, updatedAt\", () => {",
															"  pm.expect(body).to.be.an(\"object\");",
															"  pm.expect(body.status).to.be.a(\"string\");",
															"  pm.expect(body).to.have.property(\"reason\"); // can be null or string",
															"  pm.expect(body.updatedAt).to.be.a(\"string\");",
															"});",
															"",
															"// 3) Status value",
															"pm.test(\"status is COMPLIANT\", () => pm.expect(body.status).to.eql(\"COMPLIANT\"));",
															"",
															"// 4) updatedAt is ISO 8601",
															"pm.test(\"updatedAt is valid ISO-8601\", () => pm.expect(isIso(body.updatedAt)).to.be.true);",
															"",
															"// 5) JSON schema guard (allows null reason)",
															"pm.test(\"matches schema\", () => {",
															"  const schema = {",
															"    type: \"object\",",
															"    properties: {",
															"      status: { type: \"string\" },",
															"      reason: { type: [\"string\", \"null\"] },",
															"      updatedAt: { type: \"string\", format: \"date-time\" }",
															"    },",
															"    required: [\"status\", \"reason\", \"updatedAt\"],",
															"    additionalProperties: true",
															"  };",
															"  pm.response.to.have.jsonSchema(schema);",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{indexerBaseUrl}}/compliance/screen/{{validdYdXAddress}}",
													"host": [
														"{{indexerBaseUrl}}"
													],
													"path": [
														"compliance",
														"screen",
														"{{validdYdXAddress}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "/compliance/screen/INVALID",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"// Helpers",
															"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
															"",
															"// 1) Status + latency",
															"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
															"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
															"",
															"// 2) Shape and value",
															"const body = asJson();",
															"pm.test(\"has status = COMPLIANT\", () => {",
															"  pm.expect(body).to.be.an(\"object\");",
															"  pm.expect(body.status).to.eql(\"COMPLIANT\");",
															"});",
															"",
															"// 3) (Optional) ensure minimal payload (no extras expected here)",
															"pm.test(\"no reason/updatedAt for invalid address\", () => {",
															"  pm.expect(body).to.not.have.property(\"reason\");",
															"  pm.expect(body).to.not.have.property(\"updatedAt\");",
															"});",
															"",
															"// 4) Schema guard (minimal, allow future fields)",
															"pm.test(\"matches schema\", () => {",
															"  const schema = {",
															"    type: \"object\",",
															"    properties: { status: { type: \"string\", enum: [\"COMPLIANT\"] } },",
															"    required: [\"status\"],",
															"    additionalProperties: true",
															"  };",
															"  pm.response.to.have.jsonSchema(schema);",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{indexerBaseUrl}}/compliance/screen/{{invaliddYdXAddress}}",
													"host": [
														"{{indexerBaseUrl}}"
													],
													"path": [
														"compliance",
														"screen",
														"{{invaliddYdXAddress}}"
													]
												}
											},
											"response": []
										}
									]
								}
							]
						},
						{
							"name": "fills",
							"item": [
								{
									"name": "parentSubaccount",
									"item": []
								},
								{
									"name": "/fills/ VALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"const isNumericString = (v) => v !== null && v !== undefined && !Number.isNaN(Number(v));",
													"",
													"// 1) Status + latency",
													"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
													"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
													"",
													"// 2) Shape",
													"const body = asJson();",
													"pm.test(\"has non-empty fills[]\", () => {",
													"  pm.expect(body).to.be.an(\"object\");",
													"  pm.expect(body.fills).to.be.an(\"array\").with.length.greaterThan(0);",
													"});",
													"",
													"// 3) Fill schema + value checks",
													"pm.test(\"fills have expected fields and enums\", () => {",
													"  body.fills.forEach((f, i) => {",
													"    pm.expect(f.id, `id ${i}`).to.be.a(\"string\");",
													"    pm.expect([\"BUY\", \"SELL\"], `side ${i}`).to.include(f.side);",
													"    pm.expect([\"MAKER\", \"TAKER\"], `liquidity ${i}`).to.include(f.liquidity);",
													"    pm.expect([\"LIMIT\", \"MARKET\"], `type ${i}`).to.include(f.type);",
													"    pm.expect([\"PERPETUAL\", \"SPOT\"], `marketType ${i}`).to.include(f.marketType);",
													"    [\"market\", \"price\", \"size\", \"fee\", \"affiliateRevShare\", \"createdAt\", \"createdAtHeight\", \"orderId\", \"clientMetadata\"].forEach((k) =>",
													"      pm.expect(f[k], `${k} ${i}`).to.be.a(\"string\")",
													"    );",
													"    [\"price\", \"size\", \"fee\", \"affiliateRevShare\", \"createdAtHeight\"].forEach((k) =>",
													"      pm.expect(isNumericString(f[k]), `${k} numeric ${i}`).to.be.true",
													"    );",
													"    pm.expect(f.subaccountNumber, `subaccountNumber ${i}`).to.be.a(\"number\");",
													"  });",
													"});",
													"",
													"// 4) Ordering (most recent first)",
													"pm.test(\"fills ordered by createdAt desc\", () => {",
													"  const ts = body.fills.map((f) => Date.parse(f.createdAt));",
													"  for (let i = 0; i < ts.length - 1; i++) {",
													"    pm.expect(ts[i]).to.be.at.least(ts[i + 1]);",
													"  }",
													"});",
													"",
													"// 5) JSON schema guard",
													"pm.test(\"matches schema\", () => {",
													"  const fillSchema = {",
													"    type: \"object\",",
													"    properties: {",
													"      id: { type: \"string\" },",
													"      side: { type: \"string\", enum: [\"BUY\", \"SELL\"] },",
													"      liquidity: { type: \"string\", enum: [\"MAKER\", \"TAKER\"] },",
													"      type: { type: \"string\", enum: [\"LIMIT\", \"MARKET\"] },",
													"      market: { type: \"string\" },",
													"      marketType: { type: \"string\", enum: [\"PERPETUAL\", \"SPOT\"] },",
													"      price: { type: \"string\" },",
													"      size: { type: \"string\" },",
													"      fee: { type: \"string\" },",
													"      affiliateRevShare: { type: \"string\" },",
													"      createdAt: { type: \"string\", format: \"date-time\" },",
													"      createdAtHeight: { type: \"string\" },",
													"      orderId: { type: \"string\" },",
													"      clientMetadata: { type: \"string\" },",
													"      subaccountNumber: { type: \"number\" }",
													"    },",
													"    required: [",
													"      \"id\",",
													"      \"side\",",
													"      \"liquidity\",",
													"      \"type\",",
													"      \"market\",",
													"      \"marketType\",",
													"      \"price\",",
													"      \"size\",",
													"      \"fee\",",
													"      \"affiliateRevShare\",",
													"      \"createdAt\",",
													"      \"createdAtHeight\",",
													"      \"orderId\",",
													"      \"clientMetadata\",",
													"      \"subaccountNumber\"",
													"    ],",
													"    additionalProperties: true",
													"  };",
													"",
													"  const responseSchema = {",
													"    type: \"object\",",
													"    properties: {",
													"      fills: {",
													"        type: \"array\",",
													"        minItems: 1,",
													"        items: fillSchema",
													"      }",
													"    },",
													"    required: [\"fills\"],",
													"    additionalProperties: true",
													"  };",
													"",
													"  pm.response.to.have.jsonSchema(responseSchema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/fills?address={{validdYdXAddress}}&subaccountNumber=0",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"fills"
											],
											"query": [
												{
													"key": "address",
													"value": "{{validdYdXAddress}}"
												},
												{
													"key": "subaccountNumber",
													"value": "0"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "/fills INVALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"",
													"// 1) Status + latency",
													"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
													"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
													"",
													"// 2) Shape",
													"const body = asJson();",
													"pm.test(\"has fills[]\", () => {",
													"  pm.expect(body).to.be.an(\"object\");",
													"  pm.expect(body.fills).to.be.an(\"array\");",
													"});",
													"",
													"// 3) Empty for invalid address",
													"pm.test(\"fills is empty for invalid address\", () => {",
													"  pm.expect(body.fills).to.have.length(0);",
													"});",
													"",
													"// 4) Schema guard",
													"pm.test(\"matches schema\", () => {",
													"  const schema = {",
													"    type: \"object\",",
													"    properties: { fills: { type: \"array\", maxItems: 0 } },",
													"    required: [\"fills\"],",
													"    additionalProperties: true",
													"  };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/fills?address={{invaliddYdXAddress}}&subaccountNumber=0",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"fills"
											],
											"query": [
												{
													"key": "address",
													"value": "{{invaliddYdXAddress}}"
												},
												{
													"key": "subaccountNumber",
													"value": "0"
												}
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "height",
							"item": [
								{
									"name": "/height",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"const isIso = (s) => /^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?Z)$/.test(s);",
													"const isNumericString = (v) => v !== null && v !== undefined && !Number.isNaN(Number(v));",
													"",
													"// 1) Status + latency",
													"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
													"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
													"",
													"// 2) Shape + types",
													"const body = asJson();",
													"pm.test(\"has height (string) and time (string)\", () => {",
													"  pm.expect(body).to.be.an(\"object\");",
													"  pm.expect(body.height).to.be.a(\"string\");",
													"  pm.expect(body.time).to.be.a(\"string\");",
													"});",
													"",
													"// 3) Value checks",
													"pm.test(\"height is numeric string > 0\", () => {",
													"  pm.expect(isNumericString(body.height)).to.be.true;",
													"  pm.expect(Number(body.height)).to.be.above(0);",
													"});",
													"pm.test(\"time is ISO-8601\", () => pm.expect(isIso(body.time)).to.be.true);",
													"",
													"// 4) JSON schema guard",
													"pm.test(\"matches schema\", () => {",
													"  const schema = {",
													"    type: \"object\",",
													"    properties: {",
													"      height: { type: \"string\" },",
													"      time: { type: \"string\", format: \"date-time\" }",
													"    },",
													"    required: [\"height\", \"time\"],",
													"    additionalProperties: true",
													"  };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/height",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"height"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "historicalBlockTradingRewards",
							"item": [
								{
									"name": "historicalBlockTradingRewards/ VALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"const isNumericString = (v) => v !== null && v !== undefined && !Number.isNaN(Number(v));",
													"const isIso = (s) => /^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?Z)$/.test(s);",
													"",
													"// 1) Status + latency",
													"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
													"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
													"",
													"// 2) Shape",
													"const body = asJson();",
													"pm.test(\"has rewards[]\", () => {",
													"  pm.expect(body).to.be.an(\"object\");",
													"  pm.expect(body.rewards).to.be.an(\"array\");",
													"});",
													"",
													"// 3) (Optional) non-empty check if you expect data",
													"pm.test(\"rewards non-empty\", () => pm.expect(body.rewards.length).to.be.above(0));",
													"",
													"// 4) Reward schema + values",
													"pm.test(\"rewards have numeric strings and ISO timestamps\", () => {",
													"  body.rewards.forEach((r, i) => {",
													"    pm.expect(r.tradingReward, `tradingReward ${i}`).to.be.a(\"string\");",
													"    pm.expect(isNumericString(r.tradingReward), `tradingReward numeric ${i}`).to.be.true;",
													"    pm.expect(r.createdAt, `createdAt ${i}`).to.be.a(\"string\");",
													"    pm.expect(isIso(r.createdAt), `createdAt ISO ${i}`).to.be.true;",
													"    pm.expect(r.createdAtHeight, `createdAtHeight ${i}`).to.be.a(\"string\");",
													"    pm.expect(isNumericString(r.createdAtHeight), `createdAtHeight numeric ${i}`).to.be.true;",
													"  });",
													"});",
													"",
													"// 5) (Optional) non-negative numeric values",
													"pm.test(\"numeric fields non-negative\", () => {",
													"  body.rewards.forEach((r, i) => {",
													"    pm.expect(Number(r.tradingReward), `tradingReward >=0 ${i}`).to.be.at.least(0);",
													"    pm.expect(Number(r.createdAtHeight), `createdAtHeight >=0 ${i}`).to.be.at.least(0);",
													"  });",
													"});",
													"",
													"// 6) Optional ordering (newest first)",
													"pm.test(\"rewards ordered by createdAt desc\", () => {",
													"  const ts = body.rewards.map((r) => Date.parse(r.createdAt));",
													"  for (let i = 0; i < ts.length - 1; i++) {",
													"    pm.expect(ts[i]).to.be.at.least(ts[i + 1]);",
													"  }",
													"});",
													"",
													"// 7) JSON schema guard",
													"pm.test(\"matches schema\", () => {",
													"  const rewardSchema = {",
													"    type: \"object\",",
													"    properties: {",
													"      tradingReward: { type: \"string\" },",
													"      createdAt: { type: \"string\", format: \"date-time\" },",
													"      createdAtHeight: { type: \"string\" }",
													"    },",
													"    required: [\"tradingReward\", \"createdAt\", \"createdAtHeight\"],",
													"    additionalProperties: true",
													"  };",
													"",
													"  const responseSchema = {",
													"    type: \"object\",",
													"    properties: {",
													"      rewards: {",
													"        type: \"array\",",
													"        items: rewardSchema",
													"      }",
													"    },",
													"    required: [\"rewards\"],",
													"    additionalProperties: true",
													"  };",
													"",
													"  pm.response.to.have.jsonSchema(responseSchema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/historicalBlockTradingRewards/{{validdYdXAddress}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"historicalBlockTradingRewards",
												"{{validdYdXAddress}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "historicalBlockTradingRewards/ INVALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"",
													"// 1) Status + latency",
													"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
													"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
													"",
													"// 2) Shape",
													"const body = asJson();",
													"pm.test(\"has rewards[]\", () => {",
													"  pm.expect(body).to.be.an(\"object\");",
													"  pm.expect(body.rewards).to.be.an(\"array\");",
													"});",
													"",
													"// 3) Empty for invalid address",
													"pm.test(\"rewards empty for invalid address\", () => pm.expect(body.rewards).to.have.length(0));",
													"",
													"// 4) Schema guard",
													"pm.test(\"matches schema\", () => {",
													"  const schema = {",
													"    type: \"object\",",
													"    properties: {",
													"      rewards: { type: \"array\", maxItems: 0 }",
													"    },",
													"    required: [\"rewards\"],",
													"    additionalProperties: true",
													"  };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/historicalBlockTradingRewards/{{invaliddYdXAddress}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"historicalBlockTradingRewards",
												"{{invaliddYdXAddress}}"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "historicalFunding",
							"item": [
								{
									"name": "historicalFunding/ticker/ VALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"const isNumericString = (v) => v !== null && v !== undefined && !Number.isNaN(Number(v));",
													"const isIso = (s) => /^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?Z)$/.test(s);",
													"",
													"// 1) Status + latency",
													"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
													"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
													"",
													"// 2) Shape",
													"const body = asJson();",
													"pm.test(\"has historicalFunding[]\", () => {",
													"  pm.expect(body).to.be.an(\"object\");",
													"  pm.expect(body.historicalFunding).to.be.an(\"array\");",
													"});",
													"",
													"// 3) (Optional) non-empty check if you expect data",
													"pm.test(\"historicalFunding non-empty\", () => pm.expect(body.historicalFunding.length).to.be.above(0));",
													"",
													"// 4) Item schema + values",
													"pm.test(\"items have expected fields and numeric strings\", () => {",
													"  body.historicalFunding.forEach((item, i) => {",
													"    pm.expect(item.ticker, `ticker ${i}`).to.be.a(\"string\");",
													"    pm.expect(item.rate, `rate ${i}`).to.be.a(\"string\");",
													"    pm.expect(isNumericString(item.rate), `rate numeric ${i}`).to.be.true;",
													"    pm.expect(item.price, `price ${i}`).to.be.a(\"string\");",
													"    pm.expect(isNumericString(item.price), `price numeric ${i}`).to.be.true;",
													"    pm.expect(item.effectiveAtHeight, `height ${i}`).to.be.a(\"string\");",
													"    pm.expect(isNumericString(item.effectiveAtHeight), `height numeric ${i}`).to.be.true;",
													"    pm.expect(item.effectiveAt, `effectiveAt ${i}`).to.be.a(\"string\");",
													"    pm.expect(isIso(item.effectiveAt), `effectiveAt ISO ${i}`).to.be.true;",
													"  });",
													"});",
													"",
													"// 5) At least one non-zero rate (if expected)",
													"pm.test(\"at least one rate is non-zero\", () => {",
													"  const allZero = body.historicalFunding.every((f) => Number(f.rate) === 0);",
													"  pm.expect(allZero, \"all rates are zero\").to.be.false;",
													"});",
													"",
													"// 6) Ordering (newest first by effectiveAtHeight)",
													"pm.test(\"ordered by effectiveAtHeight desc\", () => {",
													"  const heights = body.historicalFunding.map((f) => Number(f.effectiveAtHeight));",
													"  for (let i = 0; i < heights.length - 1; i++) {",
													"    pm.expect(heights[i]).to.be.at.least(heights[i + 1]);",
													"  }",
													"});",
													"",
													"// 7) JSON schema guard",
													"pm.test(\"matches schema\", () => {",
													"  const itemSchema = {",
													"    type: \"object\",",
													"    properties: {",
													"      ticker: { type: \"string\" },",
													"      rate: { type: \"string\" },",
													"      price: { type: \"string\" },",
													"      effectiveAtHeight: { type: \"string\" },",
													"      effectiveAt: { type: \"string\", format: \"date-time\" }",
													"    },",
													"    required: [\"ticker\", \"rate\", \"price\", \"effectiveAtHeight\", \"effectiveAt\"],",
													"    additionalProperties: true",
													"  };",
													"  const schema = {",
													"    type: \"object\",",
													"    properties: { historicalFunding: { type: \"array\", items: itemSchema } },",
													"    required: [\"historicalFunding\"],",
													"    additionalProperties: true",
													"  };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/historicalFunding/{{ticker}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"historicalFunding",
												"{{ticker}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "historicalFunding/ticker/ INVALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"",
													"// 1) Status",
													"pm.test(\"status 400\", () => pm.response.to.have.status(400));",
													"",
													"// 2) Errors array",
													"const body = asJson();",
													"pm.test(\"has errors[]\", () => {",
													"  pm.expect(body).to.be.an(\"object\");",
													"  pm.expect(body.errors).to.be.an(\"array\").with.length.greaterThan(0);",
													"});",
													"",
													"// 3) Specific ticker validation error",
													"pm.test(\"ticker validation error present\", () => {",
													"  const err = body.errors.find((e) => e.param === \"ticker\") || body.errors[0];",
													"  pm.expect(err.value).to.be.a(\"string\"); // value exists, string",
													"  pm.expect(err.msg).to.eql(\"ticker must be a valid ticker (BTC-USD, etc)\");",
													"  pm.expect(err.param).to.eql(\"ticker\");",
													"  pm.expect(err.location).to.eql(\"params\");",
													"});",
													"",
													"// 4) Schema guard",
													"pm.test(\"matches error schema\", () => {",
													"  const schema = {",
													"    type: \"object\",",
													"    properties: {",
													"      errors: {",
													"        type: \"array\",",
													"        minItems: 1,",
													"        items: {",
													"          type: \"object\",",
													"          properties: {",
													"            value: { type: \"string\" },",
													"            msg: { type: \"string\" },",
													"            param: { type: \"string\" },",
													"            location: { type: \"string\" }",
													"          },",
													"          required: [\"value\", \"msg\", \"param\", \"location\"],",
													"          additionalProperties: true",
													"        }",
													"      }",
													"    },",
													"    required: [\"errors\"],",
													"    additionalProperties: true",
													"  };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/historicalFunding/{{invalidTicker}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"historicalFunding",
												"{{invalidTicker}}"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "historical-pnl",
							"item": [
								{
									"name": "historical-pnl VALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"const isNumericString = (v) => v !== null && v !== undefined && !Number.isNaN(Number(v));",
													"const isIso = (s) => /^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?Z)$/.test(s);",
													"",
													"// 1) Status + latency",
													"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
													"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
													"",
													"// 2) Shape",
													"const body = asJson();",
													"pm.test(\"has historicalPnl[]\", () => {",
													"  pm.expect(body).to.be.an(\"object\");",
													"  pm.expect(body.historicalPnl).to.be.an(\"array\");",
													"});",
													"",
													"// 3) (Optional) non-empty check if you expect data",
													"pm.test(\"historicalPnl non-empty\", () => pm.expect(body.historicalPnl.length).to.be.above(0));",
													"",
													"// 4) Item schema + values",
													"pm.test(\"items have expected fields, numeric strings, ISO times\", () => {",
													"  body.historicalPnl.forEach((p, i) => {",
													"    [\"equity\", \"totalPnl\", \"netTransfers\", \"blockHeight\", \"blockTime\", \"createdAt\"].forEach((k) =>",
													"      pm.expect(p[k], `${k} ${i}`).to.be.a(\"string\")",
													"    );",
													"    [\"equity\", \"totalPnl\", \"netTransfers\", \"blockHeight\"].forEach((k) =>",
													"      pm.expect(isNumericString(p[k]), `${k} numeric ${i}`).to.be.true",
													"    );",
													"    pm.expect(isIso(p.createdAt), `createdAt ISO ${i}`).to.be.true;",
													"    pm.expect(isIso(p.blockTime), `blockTime ISO ${i}`).to.be.true;",
													"  });",
													"});",
													"",
													"// 5) Ordering (newest first by blockHeight)",
													"pm.test(\"ordered by blockHeight desc\", () => {",
													"  const heights = body.historicalPnl.map((p) => Number(p.blockHeight));",
													"  for (let i = 0; i < heights.length - 1; i++) {",
													"    pm.expect(heights[i]).to.be.at.least(heights[i + 1]);",
													"  }",
													"});",
													"",
													"// 6) JSON schema guard",
													"pm.test(\"matches schema\", () => {",
													"  const itemSchema = {",
													"    type: \"object\",",
													"    properties: {",
													"      equity: { type: \"string\" },",
													"      totalPnl: { type: \"string\" },",
													"      netTransfers: { type: \"string\" },",
													"      createdAt: { type: \"string\", format: \"date-time\" },",
													"      blockHeight: { type: \"string\" },",
													"      blockTime: { type: \"string\", format: \"date-time\" }",
													"    },",
													"    required: [\"equity\", \"totalPnl\", \"netTransfers\", \"createdAt\", \"blockHeight\", \"blockTime\"],",
													"    additionalProperties: true",
													"  };",
													"  const schema = {",
													"    type: \"object\",",
													"    properties: {",
													"      historicalPnl: { type: \"array\", items: itemSchema }",
													"    },",
													"    required: [\"historicalPnl\"],",
													"    additionalProperties: true",
													"  };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/historical-pnl/?address={{validdYdXAddress}}&subaccountNumber={{subAccountNumber}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"historical-pnl",
												""
											],
											"query": [
												{
													"key": "address",
													"value": "{{validdYdXAddress}}"
												},
												{
													"key": "subaccountNumber",
													"value": "{{subAccountNumber}}"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "historical-pnl INVALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"",
													"// 1) Status + latency",
													"pm.test(\"status 404 or 400\", () => pm.expect(pm.response.code).to.be.oneOf([404, 400]));",
													"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
													"",
													"// 2) Shape",
													"const body = asJson();",
													"pm.test(\"has errors[]\", () => {",
													"  pm.expect(body).to.be.an(\"object\");",
													"  pm.expect(body.errors).to.be.an(\"array\").with.length.greaterThan(0);",
													"});",
													"",
													"// 3) Error schema + message",
													"pm.test(\"errors contain msg and mention subaccount not found\", () => {",
													"  const err = body.errors[0];",
													"  pm.expect(err.msg).to.be.a(\"string\");",
													"  pm.expect(err.msg).to.include(\"No subaccount found\");",
													"});",
													"",
													"// 4) No unexpected properties",
													"pm.test(\"no unexpected properties on error objects\", () => {",
													"  const allowed = [\"msg\", \"value\", \"param\", \"location\"];",
													"  body.errors.forEach((e) => {",
													"    Object.keys(e).forEach((k) => pm.expect(allowed).to.include(k));",
													"  });",
													"});",
													"",
													"// 5) JSON schema guard",
													"pm.test(\"matches error schema\", () => {",
													"  const schema = {",
													"    type: \"object\",",
													"    properties: {",
													"      errors: {",
													"        type: \"array\",",
													"        minItems: 1,",
													"        items: {",
													"          type: \"object\",",
													"          properties: {",
													"            msg: { type: \"string\" },",
													"            value: { type: \"string\" },",
													"            param: { type: \"string\" },",
													"            location: { type: \"string\" }",
													"          },",
													"          required: [\"msg\"],",
													"          additionalProperties: true",
													"        }",
													"      }",
													"    },",
													"    required: [\"errors\"],",
													"    additionalProperties: true",
													"  };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/historical-pnl/?address={{invaliddYdXAddress}}&subaccountNumber={{subAccountNumber}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"historical-pnl",
												""
											],
											"query": [
												{
													"key": "address",
													"value": "{{invaliddYdXAddress}}"
												},
												{
													"key": "subaccountNumber",
													"value": "{{subAccountNumber}}"
												}
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "historicalTradingRewardAggregations",
							"item": [
								{
									"name": "historicalTradingRewardAggregations/ VALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"const isNumericString = (v) => v !== null && v !== undefined && !Number.isNaN(Number(v));",
													"const isIso = (s) => /^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?Z)$/.test(s);",
													"",
													"// 1) Status + latency",
													"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
													"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
													"",
													"// 2) Shape",
													"const body = asJson();",
													"pm.test(\"has rewards[]\", () => {",
													"  pm.expect(body).to.be.an(\"object\");",
													"  pm.expect(body.rewards).to.be.an(\"array\");",
													"});",
													"",
													"// 3) (Optional) non-empty if you expect data",
													"pm.test(\"rewards non-empty\", () => pm.expect(body.rewards.length).to.be.above(0));",
													"",
													"// 4) Reward schema + values",
													"pm.test(\"rewards have expected fields/types\", () => {",
													"  body.rewards.forEach((r, i) => {",
													"    pm.expect(r.tradingReward, `tradingReward ${i}`).to.be.a(\"string\");",
													"    pm.expect(isNumericString(r.tradingReward), `tradingReward numeric ${i}`).to.be.true;",
													"",
													"    pm.expect(r.startedAt, `startedAt ${i}`).to.be.a(\"string\");",
													"    pm.expect(isIso(r.startedAt), `startedAt ISO ${i}`).to.be.true;",
													"    pm.expect(r.startedAtHeight, `startedAtHeight ${i}`).to.be.a(\"string\");",
													"    pm.expect(isNumericString(r.startedAtHeight), `startedAtHeight numeric ${i}`).to.be.true;",
													"",
													"    pm.expect(r.period, `period ${i}`).to.eql(\"DAILY\");",
													"",
													"    // Nullable fields",
													"    pm.expect(r.endedAt === null || typeof r.endedAt === \"string\", `endedAt nullable ${i}`).to.be.true;",
													"    pm.expect(r.endedAtHeight === null || typeof r.endedAtHeight === \"string\", `endedAtHeight nullable ${i}`).to.be.true;",
													"",
													"    if (r.endedAt !== null) pm.expect(isIso(r.endedAt), `endedAt ISO ${i}`).to.be.true;",
													"    if (r.endedAtHeight !== null) pm.expect(isNumericString(r.endedAtHeight), `endedAtHeight numeric ${i}`).to.be.true;",
													"  });",
													"});",
													"",
													"// 5) Ordering (newest first by startedAt)",
													"pm.test(\"rewards ordered by startedAt desc\", () => {",
													"  const ts = body.rewards.map((r) => Date.parse(r.startedAt));",
													"  for (let i = 0; i < ts.length - 1; i++) {",
													"    pm.expect(ts[i]).to.be.at.least(ts[i + 1]);",
													"  }",
													"});",
													"",
													"// 6) JSON schema guard",
													"pm.test(\"matches schema\", () => {",
													"  const rewardSchema = {",
													"    type: \"object\",",
													"    properties: {",
													"      tradingReward: { type: \"string\" },",
													"      startedAt: { type: \"string\", format: \"date-time\" },",
													"      startedAtHeight: { type: \"string\" },",
													"      endedAt: { type: [\"string\", \"null\"] },",
													"      endedAtHeight: { type: [\"string\", \"null\"] },",
													"      period: { type: \"string\", enum: [\"DAILY\", \"WEEKLY\", \"MONTHLY\"] }",
													"    },",
													"    required: [\"tradingReward\", \"startedAt\", \"startedAtHeight\", \"endedAt\", \"endedAtHeight\", \"period\"],",
													"    additionalProperties: true",
													"  };",
													"",
													"  const schema = {",
													"    type: \"object\",",
													"    properties: {",
													"      rewards: { type: \"array\", items: rewardSchema }",
													"    },",
													"    required: [\"rewards\"],",
													"    additionalProperties: true",
													"  };",
													"",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/historicalTradingRewardAggregations/{{validdYdXAddress}}?period=DAILY",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"historicalTradingRewardAggregations",
												"{{validdYdXAddress}}"
											],
											"query": [
												{
													"key": "period",
													"value": "DAILY"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "historicalTradingRewardAggregations/ INVALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"",
													"// 1) Status + latency",
													"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
													"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
													"",
													"// 2) Shape",
													"const body = asJson();",
													"pm.test(\"has rewards[]\", () => {",
													"  pm.expect(body).to.be.an(\"object\");",
													"  pm.expect(body.rewards).to.be.an(\"array\");",
													"});",
													"",
													"// 3) Empty for invalid address",
													"pm.test(\"rewards empty for invalid address\", () => pm.expect(body.rewards).to.have.length(0));",
													"",
													"// 4) JSON schema guard",
													"pm.test(\"matches schema\", () => {",
													"  const schema = {",
													"    type: \"object\",",
													"    properties: {",
													"      rewards: { type: \"array\", maxItems: 0 }",
													"    },",
													"    required: [\"rewards\"],",
													"    additionalProperties: true",
													"  };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/historicalTradingRewardAggregations/{{invaliddYdXAddress}}?period=DAILY",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"historicalTradingRewardAggregations",
												"{{invaliddYdXAddress}}"
											],
											"query": [
												{
													"key": "period",
													"value": "DAILY"
												}
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "orderbooks",
							"item": [
								{
									"name": "orderbooks/perpetualMarket",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"const isNumericString = (v) => v !== null && v !== undefined && !Number.isNaN(Number(v));",
													"",
													"// 1) Status + latency",
													"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
													"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
													"",
													"// 2) Shape",
													"const body = asJson();",
													"pm.test(\"has bids[] and asks[]\", () => {",
													"  pm.expect(body).to.be.an(\"object\");",
													"  pm.expect(body.bids).to.be.an(\"array\").with.length.greaterThan(0);",
													"  pm.expect(body.asks).to.be.an(\"array\").with.length.greaterThan(0);",
													"});",
													"",
													"// 3) Entries schema + numeric strings",
													"pm.test(\"bids/asks have price/size as numeric strings\", () => {",
													"  const checkSide = (arr, name) => {",
													"    arr.forEach((o, i) => {",
													"      pm.expect(o, `${name} ${i}`).to.be.an(\"object\");",
													"      pm.expect(o.price, `${name} price ${i}`).to.be.a(\"string\");",
													"      pm.expect(o.size, `${name} size ${i}`).to.be.a(\"string\");",
													"      pm.expect(isNumericString(o.price), `${name} price numeric ${i}`).to.be.true;",
													"      pm.expect(isNumericString(o.size), `${name} size numeric ${i}`).to.be.true;",
													"      Object.keys(o).forEach((k) => pm.expect([\"price\", \"size\"]).to.include(k, `Unexpected key ${k} in ${name} ${i}`));",
													"    });",
													"  };",
													"  checkSide(body.bids, \"bid\");",
													"  checkSide(body.asks, \"ask\");",
													"});",
													"",
													"// 4) Sorting",
													"pm.test(\"bids descending by price\", () => {",
													"  const prices = body.bids.map((b) => Number(b.price));",
													"  for (let i = 0; i < prices.length - 1; i++) pm.expect(prices[i]).to.be.at.least(prices[i + 1]);",
													"});",
													"pm.test(\"asks ascending by price\", () => {",
													"  const prices = body.asks.map((a) => Number(a.price));",
													"  for (let i = 0; i < prices.length - 1; i++) pm.expect(prices[i]).to.be.at.most(prices[i + 1]);",
													"});",
													"",
													"// 5) JSON schema guard",
													"pm.test(\"matches schema\", () => {",
													"  const side = {",
													"    type: \"object\",",
													"    properties: { price: { type: \"string\" }, size: { type: \"string\" } },",
													"    required: [\"price\", \"size\"],",
													"    additionalProperties: false",
													"  };",
													"  const schema = {",
													"    type: \"object\",",
													"    properties: {",
													"      bids: { type: \"array\", items: side },",
													"      asks: { type: \"array\", items: side }",
													"    },",
													"    required: [\"bids\", \"asks\"],",
													"    additionalProperties: false",
													"  };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/orderbooks/perpetualMarket/{{ticker}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"orderbooks",
												"perpetualMarket",
												"{{ticker}}"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "orders",
							"item": [
								{
									"name": "orders/listOrders VALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"const isNumericString = (v) => v !== null && v !== undefined && !Number.isNaN(Number(v));",
													"const isIso = (s) => /^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?Z)$/.test(s);",
													"",
													"// 1) Status + latency",
													"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
													"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
													"",
													"// 2) Shape",
													"const body = asJson();",
													"pm.test(\"response is an array\", () => pm.expect(body).to.be.an(\"array\"));",
													"",
													"// 3) Order schema + values",
													"pm.test(\"orders have expected fields and types\", () => {",
													"  body.forEach((o, i) => {",
													"    // Required",
													"    [\"id\",\"subaccountId\",\"clientId\",\"clobPairId\",\"side\",\"size\",\"totalFilled\",\"price\",\"type\",\"status\",",
													"     \"timeInForce\",\"reduceOnly\",\"orderFlags\",\"createdAtHeight\",\"clientMetadata\",\"updatedAt\",",
													"     \"updatedAtHeight\",\"postOnly\",\"ticker\",\"subaccountNumber\"",
													"    ].forEach((k) => pm.expect(o, `${k} ${i}`).to.have.property(k));",
													"",
													"    pm.expect(o.id).to.be.a(\"string\");",
													"    pm.expect(o.subaccountId).to.be.a(\"string\");",
													"    pm.expect(o.clientId).to.be.a(\"string\");",
													"    pm.expect(o.clobPairId).to.be.a(\"string\");",
													"    pm.expect([\"BUY\",\"SELL\"]).to.include(o.side);",
													"    pm.expect(o.size).to.be.a(\"string\"); pm.expect(isNumericString(o.size)).to.be.true;",
													"    pm.expect(o.totalFilled).to.be.a(\"string\"); pm.expect(isNumericString(o.totalFilled)).to.be.true;",
													"    pm.expect(o.price).to.be.a(\"string\"); pm.expect(isNumericString(o.price)).to.be.true;",
													"    pm.expect(o.type).to.be.a(\"string\");",
													"    pm.expect(o.status).to.be.a(\"string\");",
													"    pm.expect(o.timeInForce).to.be.a(\"string\");",
													"    pm.expect(o.reduceOnly).to.be.a(\"boolean\");",
													"    pm.expect(o.orderFlags).to.be.a(\"string\");",
													"    pm.expect(o.createdAtHeight).to.be.a(\"string\"); pm.expect(isNumericString(o.createdAtHeight)).to.be.true;",
													"    pm.expect(o.clientMetadata).to.be.a(\"string\");",
													"    pm.expect(o.updatedAt).to.be.a(\"string\"); pm.expect(isIso(o.updatedAt)).to.be.true;",
													"    pm.expect(o.updatedAtHeight).to.be.a(\"string\"); pm.expect(isNumericString(o.updatedAtHeight)).to.be.true;",
													"    pm.expect(o.postOnly).to.be.a(\"boolean\");",
													"    pm.expect(o.ticker).to.be.a(\"string\");",
													"    pm.expect(o.subaccountNumber).to.be.a(\"number\");",
													"",
													"    // Optional",
													"    if (o.hasOwnProperty(\"goodTilBlockTime\")) {",
													"      pm.expect(o.goodTilBlockTime).to.be.a(\"string\");",
													"      pm.expect(isIso(o.goodTilBlockTime)).to.be.true;",
													"    }",
													"    if (o.hasOwnProperty(\"goodTilBlock\")) {",
													"      pm.expect(o.goodTilBlock).to.be.a(\"string\");",
													"      pm.expect(isNumericString(o.goodTilBlock)).to.be.true;",
													"    }",
													"    if (o.hasOwnProperty(\"orderRouterAddress\")) {",
													"      pm.expect(typeof o.orderRouterAddress === \"string\" || o.orderRouterAddress === null).to.be.true;",
													"    }",
													"",
													"    // No unexpected keys",
													"    const allowed = [",
													"      \"id\",\"subaccountId\",\"clientId\",\"clobPairId\",\"side\",\"size\",\"totalFilled\",\"price\",\"type\",\"status\",",
													"      \"timeInForce\",\"reduceOnly\",\"orderFlags\",\"createdAtHeight\",\"clientMetadata\",\"updatedAt\",\"updatedAtHeight\",",
													"      \"postOnly\",\"ticker\",\"subaccountNumber\",\"goodTilBlockTime\",\"goodTilBlock\",\"orderRouterAddress\"",
													"    ];",
													"    Object.keys(o).forEach((k) => pm.expect(allowed).to.include(k, `Unexpected property: ${k}`));",
													"  });",
													"});",
													"",
													"",
													"// 4) JSON schema guard",
													"pm.test(\"matches schema\", () => {",
													"  const item = {",
													"    type: \"object\",",
													"    properties: {",
													"      id: { type: \"string\" },",
													"      subaccountId: { type: \"string\" },",
													"      clientId: { type: \"string\" },",
													"      clobPairId: { type: \"string\" },",
													"      side: { type: \"string\", enum: [\"BUY\",\"SELL\"] },",
													"      size: { type: \"string\" },",
													"      totalFilled: { type: \"string\" },",
													"      price: { type: \"string\" },",
													"      type: { type: \"string\" },",
													"      status: { type: \"string\" },",
													"      timeInForce: { type: \"string\" },",
													"      reduceOnly: { type: \"boolean\" },",
													"      orderFlags: { type: \"string\" },",
													"      goodTilBlockTime: { type: \"string\" },",
													"      goodTilBlock: { type: \"string\" },",
													"      createdAtHeight: { type: \"string\" },",
													"      clientMetadata: { type: \"string\" },",
													"      updatedAt: { type: \"string\", format: \"date-time\" },",
													"      updatedAtHeight: { type: \"string\" },",
													"      orderRouterAddress: { type: [\"string\",\"null\"] },",
													"      postOnly: { type: \"boolean\" },",
													"      ticker: { type: \"string\" },",
													"      subaccountNumber: { type: \"number\" }",
													"    },",
													"    required: [",
													"      \"id\",\"subaccountId\",\"clientId\",\"clobPairId\",\"side\",\"size\",\"totalFilled\",\"price\",\"type\",\"status\",",
													"      \"timeInForce\",\"reduceOnly\",\"orderFlags\",\"createdAtHeight\",\"clientMetadata\",\"updatedAt\",\"updatedAtHeight\",",
													"      \"postOnly\",\"ticker\",\"subaccountNumber\"",
													"    ],",
													"    additionalProperties: false",
													"  };",
													"  const schema = { type: \"array\", items: item };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/orders/?address={{validdYdXAddress}}&subaccountNumber=0",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"orders",
												""
											],
											"query": [
												{
													"key": "address",
													"value": "{{validdYdXAddress}}"
												},
												{
													"key": "subaccountNumber",
													"value": "0"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "orders/listOrders INVALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"",
													"// 1) Status + latency",
													"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
													"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
													"",
													"// 2) Shape",
													"const body = asJson();",
													"pm.test(\"response is an array\", () => pm.expect(body).to.be.an(\"array\"));",
													"",
													"// 3) Empty for invalid address",
													"pm.test(\"array is empty for invalid address\", () => pm.expect(body.length).to.eql(0));",
													"",
													"// 4) Schema guard",
													"pm.test(\"matches schema\", () => {",
													"  const schema = {",
													"    type: \"array\",",
													"    maxItems: 0,",
													"    items: { type: \"object\" }",
													"  };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/orders/?address={{invaliddYdXAddress}}&subaccountNumber=0",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"orders",
												""
											],
											"query": [
												{
													"key": "address",
													"value": "{{invaliddYdXAddress}}"
												},
												{
													"key": "subaccountNumber",
													"value": "0"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "orders/getOrder VALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"const isNumericString = (v) => v !== null && v !== undefined && !Number.isNaN(Number(v));",
													"const isIso = (s) => /^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?Z)$/.test(s);",
													"",
													"// 1) Status + latency",
													"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
													"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
													"",
													"// 2) Shape",
													"const order = asJson();",
													"pm.test(\"response is an object\", () => pm.expect(order).to.be.an(\"object\"));",
													"",
													"// 3) Required fields and types",
													"pm.test(\"order has required fields\", () => {",
													"  [",
													"    \"id\",\"subaccountId\",\"clientId\",\"clobPairId\",\"side\",\"size\",\"totalFilled\",\"price\",\"type\",\"status\",",
													"    \"timeInForce\",\"reduceOnly\",\"orderFlags\",\"createdAtHeight\",\"clientMetadata\",\"updatedAt\",\"updatedAtHeight\",",
													"    \"postOnly\",\"ticker\",\"subaccountNumber\"",
													"  ].forEach((k) => pm.expect(order).to.have.property(k));",
													"",
													"  pm.expect([\"BUY\",\"SELL\"]).to.include(order.side);",
													"  pm.expect(order.size).to.be.a(\"string\"); pm.expect(isNumericString(order.size)).to.be.true;",
													"  pm.expect(order.totalFilled).to.be.a(\"string\"); pm.expect(isNumericString(order.totalFilled)).to.be.true;",
													"  pm.expect(order.price).to.be.a(\"string\"); pm.expect(isNumericString(order.price)).to.be.true;",
													"  pm.expect(order.type).to.be.a(\"string\");",
													"  pm.expect(order.status).to.be.a(\"string\");",
													"  pm.expect(order.timeInForce).to.be.a(\"string\");",
													"  pm.expect(order.reduceOnly).to.be.a(\"boolean\");",
													"  pm.expect(order.orderFlags).to.be.a(\"string\");",
													"  pm.expect(order.createdAtHeight).to.be.a(\"string\"); pm.expect(isNumericString(order.createdAtHeight)).to.be.true;",
													"  pm.expect(order.clientMetadata).to.be.a(\"string\");",
													"  pm.expect(order.updatedAt).to.be.a(\"string\"); pm.expect(isIso(order.updatedAt)).to.be.true;",
													"  pm.expect(order.updatedAtHeight).to.be.a(\"string\"); pm.expect(isNumericString(order.updatedAtHeight)).to.be.true;",
													"  pm.expect(order.postOnly).to.be.a(\"boolean\");",
													"  pm.expect(order.ticker).to.be.a(\"string\");",
													"  pm.expect(order.subaccountNumber).to.be.a(\"number\");",
													"",
													"  // Optional fields",
													"  if (order.hasOwnProperty(\"goodTilBlockTime\")) {",
													"    pm.expect(order.goodTilBlockTime).to.be.a(\"string\");",
													"    pm.expect(isIso(order.goodTilBlockTime)).to.be.true;",
													"  }",
													"  if (order.hasOwnProperty(\"goodTilBlock\")) {",
													"    pm.expect(order.goodTilBlock).to.be.a(\"string\");",
													"    pm.expect(isNumericString(order.goodTilBlock)).to.be.true;",
													"  }",
													"  if (order.hasOwnProperty(\"orderRouterAddress\")) {",
													"    pm.expect(typeof order.orderRouterAddress === \"string\" || order.orderRouterAddress === null).to.be.true;",
													"  }",
													"});",
													"",
													"// 4) No unexpected properties",
													"pm.test(\"no unexpected properties\", () => {",
													"  const allowed = [",
													"    \"id\",\"subaccountId\",\"clientId\",\"clobPairId\",\"side\",\"size\",\"totalFilled\",\"price\",\"type\",\"status\",",
													"    \"timeInForce\",\"reduceOnly\",\"orderFlags\",\"createdAtHeight\",\"clientMetadata\",\"updatedAt\",\"updatedAtHeight\",",
													"    \"postOnly\",\"ticker\",\"subaccountNumber\",\"goodTilBlockTime\",\"goodTilBlock\",\"orderRouterAddress\"",
													"  ];",
													"  Object.keys(order).forEach((k) => pm.expect(allowed).to.include(k, `Unexpected property: ${k}`));",
													"});",
													"",
													"// 5) JSON schema guard",
													"pm.test(\"matches schema\", () => {",
													"  const schema = {",
													"    type: \"object\",",
													"    properties: {",
													"      id: { type: \"string\" },",
													"      subaccountId: { type: \"string\" },",
													"      clientId: { type: \"string\" },",
													"      clobPairId: { type: \"string\" },",
													"      side: { type: \"string\", enum: [\"BUY\",\"SELL\"] },",
													"      size: { type: \"string\" },",
													"      totalFilled: { type: \"string\" },",
													"      price: { type: \"string\" },",
													"      type: { type: \"string\" },",
													"      status: { type: \"string\" },",
													"      timeInForce: { type: \"string\" },",
													"      reduceOnly: { type: \"boolean\" },",
													"      orderFlags: { type: \"string\" },",
													"      goodTilBlockTime: { type: \"string\" },",
													"      goodTilBlock: { type: \"string\" },",
													"      createdAtHeight: { type: \"string\" },",
													"      clientMetadata: { type: \"string\" },",
													"      updatedAt: { type: \"string\", format: \"date-time\" },",
													"      updatedAtHeight: { type: \"string\" },",
													"      orderRouterAddress: { type: [\"string\",\"null\"] },",
													"      postOnly: { type: \"boolean\" },",
													"      ticker: { type: \"string\" },",
													"      subaccountNumber: { type: \"number\" }",
													"    },",
													"    required: [",
													"      \"id\",\"subaccountId\",\"clientId\",\"clobPairId\",\"side\",\"size\",\"totalFilled\",\"price\",\"type\",\"status\",",
													"      \"timeInForce\",\"reduceOnly\",\"orderFlags\",\"createdAtHeight\",\"clientMetadata\",\"updatedAt\",\"updatedAtHeight\",",
													"      \"postOnly\",\"ticker\",\"subaccountNumber\"",
													"    ],",
													"    additionalProperties: false",
													"  };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/orders/{{validOrderID}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"orders",
												"{{validOrderID}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "orders/getOrder INVALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"",
													"// 1) Status + latency",
													"pm.test(\"status 400\", () => pm.response.to.have.status(400));",
													"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
													"",
													"// 2) Shape",
													"const body = asJson();",
													"pm.test(\"has errors[]\", () => {",
													"  pm.expect(body).to.be.an(\"object\");",
													"  pm.expect(body.errors).to.be.an(\"array\").with.length.greaterThan(0);",
													"});",
													"",
													"// 3) Error object structure and values",
													"pm.test(\"error object fields\", () => {",
													"  const err = body.errors[0];",
													"  pm.expect(err.value).to.be.a(\"string\");",
													"  pm.expect(err.msg).to.include(\"Invalid value\");",
													"  pm.expect(err.param).to.eql(\"orderId\");",
													"  pm.expect(err.location).to.eql(\"params\");",
													"});",
													"",
													"// 4) Schema guard",
													"pm.test(\"matches error schema\", () => {",
													"  const schema = {",
													"    type: \"object\",",
													"    properties: {",
													"      errors: {",
													"        type: \"array\",",
													"        minItems: 1,",
													"        items: {",
													"          type: \"object\",",
													"          properties: {",
													"            value: { type: \"string\" },",
													"            msg: { type: \"string\" },",
													"            param: { type: \"string\" },",
													"            location: { type: \"string\" }",
													"          },",
													"          required: [\"value\", \"msg\", \"param\", \"location\"],",
													"          additionalProperties: true",
													"        }",
													"      }",
													"    },",
													"    required: [\"errors\"],",
													"    additionalProperties: true",
													"  };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/orders/{{inValidOrderID}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"orders",
												"{{inValidOrderID}}"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "perpetualMarkets",
							"item": [
								{
									"name": "/perpetualMarkets/ListPerpetualMarkets",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"const isNumericString = (v) => v !== null && v !== undefined && !Number.isNaN(Number(v));",
													"",
													"// 1) Status + latency",
													"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
													"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
													"",
													"// 2) Shape",
													"const body = asJson();",
													"pm.test(\"has markets object\", () => {",
													"  pm.expect(body).to.be.an(\"object\");",
													"  pm.expect(body.markets).to.be.an(\"object\");",
													"  pm.expect(Object.keys(body.markets).length).to.be.above(0);",
													"});",
													"",
													"// 3) Market entries schema + numeric strings",
													"pm.test(\"market entries have expected fields/types\", () => {",
													"  Object.values(body.markets).forEach((m, i) => {",
													"    [",
													"      \"clobPairId\",\"ticker\",\"status\",\"oraclePrice\",\"priceChange24H\",\"volume24H\",\"trades24H\",",
													"      \"nextFundingRate\",\"initialMarginFraction\",\"maintenanceMarginFraction\",\"openInterest\",",
													"      \"atomicResolution\",\"quantumConversionExponent\",\"tickSize\",\"stepSize\",\"stepBaseQuantums\",",
													"      \"subticksPerTick\",\"marketType\",\"openInterestLowerCap\",\"openInterestUpperCap\",",
													"      \"baseOpenInterest\",\"defaultFundingRate1H\"",
													"    ].forEach((k) => pm.expect(m, `${k} ${i}`).to.have.property(k));",
													"",
													"    [\"oraclePrice\",\"priceChange24H\",\"volume24H\",\"nextFundingRate\",\"initialMarginFraction\",",
													"     \"maintenanceMarginFraction\",\"openInterest\",\"tickSize\",\"stepSize\",",
													"     \"openInterestLowerCap\",\"openInterestUpperCap\",\"baseOpenInterest\"",
													"    ].forEach((k) => {",
													"      pm.expect(m[k], `${k} ${i}`).to.be.a(\"string\");",
													"      pm.expect(isNumericString(m[k]), `${k} numeric ${i}`).to.be.true;",
													"    });",
													"",
													"    pm.expect(m.trades24H, `trades24H ${i}`).to.be.a(\"number\");",
													"    pm.expect(m.atomicResolution, `atomicResolution ${i}`).to.be.a(\"number\");",
													"    pm.expect(m.quantumConversionExponent, `quantumConversionExponent ${i}`).to.be.a(\"number\");",
													"    pm.expect(m.stepBaseQuantums, `stepBaseQuantums ${i}`).to.be.a(\"number\");",
													"    pm.expect(m.subticksPerTick, `subticksPerTick ${i}`).to.be.a(\"number\");",
													"    pm.expect(m.status, `status ${i}`).to.be.a(\"string\");",
													"    pm.expect(m.marketType, `marketType ${i}`).to.be.a(\"string\");",
													"    // defaultFundingRate1H can be string or null",
													"    pm.expect(typeof m.defaultFundingRate1H === \"string\" || m.defaultFundingRate1H === null, `defaultFundingRate1H ${i}`).to.be.true;",
													"  });",
													"});",
													"",
													"// 4) JSON schema guard",
													"pm.test(\"matches schema\", () => {",
													"  const marketSchema = {",
													"    type: \"object\",",
													"    properties: {",
													"      clobPairId: { type: \"string\" },",
													"      ticker: { type: \"string\" },",
													"      status: { type: \"string\" },",
													"      oraclePrice: { type: \"string\" },",
													"      priceChange24H: { type: \"string\" },",
													"      volume24H: { type: \"string\" },",
													"      trades24H: { type: \"number\" },",
													"      nextFundingRate: { type: \"string\" },",
													"      initialMarginFraction: { type: \"string\" },",
													"      maintenanceMarginFraction: { type: \"string\" },",
													"      openInterest: { type: \"string\" },",
													"      atomicResolution: { type: \"number\" },",
													"      quantumConversionExponent: { type: \"number\" },",
													"      tickSize: { type: \"string\" },",
													"      stepSize: { type: \"string\" },",
													"      stepBaseQuantums: { type: \"number\" },",
													"      subticksPerTick: { type: \"number\" },",
													"      marketType: { type: \"string\" },",
													"      openInterestLowerCap: { type: \"string\" },",
													"      openInterestUpperCap: { type: \"string\" },",
													"      baseOpenInterest: { type: \"string\" },",
													"      defaultFundingRate1H: { type: [\"string\", \"null\"] }",
													"    },",
													"    required: [",
													"      \"clobPairId\",\"ticker\",\"status\",\"oraclePrice\",\"priceChange24H\",\"volume24H\",\"trades24H\",",
													"      \"nextFundingRate\",\"initialMarginFraction\",\"maintenanceMarginFraction\",\"openInterest\",",
													"      \"atomicResolution\",\"quantumConversionExponent\",\"tickSize\",\"stepSize\",\"stepBaseQuantums\",",
													"      \"subticksPerTick\",\"marketType\",\"openInterestLowerCap\",\"openInterestUpperCap\",\"baseOpenInterest\",\"defaultFundingRate1H\"",
													"    ],",
													"    additionalProperties: false",
													"  };",
													"",
													"  const schema = {",
													"    type: \"object\",",
													"    properties: {",
													"      markets: {",
													"        type: \"object\",",
													"        patternProperties: { \".*\": marketSchema },",
													"        additionalProperties: false",
													"      }",
													"    },",
													"    required: [\"markets\"],",
													"    additionalProperties: false",
													"  };",
													"",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/perpetualMarkets/",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"perpetualMarkets",
												""
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "perpetualPositions",
							"item": [
								{
									"name": "getPositions VALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"const isNumericString = (v) => v !== null && v !== undefined && !Number.isNaN(Number(v));",
													"const isIso = (s) => /^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?Z)$/.test(s);",
													"",
													"// 1) Status + latency",
													"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
													"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
													"",
													"// 2) Shape",
													"const body = asJson();",
													"pm.test(\"has positions[]\", () => {",
													"  pm.expect(body).to.be.an(\"object\");",
													"  pm.expect(body.positions).to.be.an(\"array\");",
													"});",
													"",
													"// 3) Non-empty (expected) and per-position schema",
													"pm.test(\"positions non-empty and valid\", () => {",
													"  pm.expect(body.positions.length).to.be.above(0, \"expected at least one position\");",
													"  body.positions.forEach((p, i) => {",
													"    [\"market\",\"status\",\"side\",\"size\",\"maxSize\",\"entryPrice\",\"exitPrice\",\"realizedPnl\",",
													"     \"unrealizedPnl\",\"createdAt\",\"createdAtHeight\",\"closedAt\",\"sumOpen\",\"sumClose\",",
													"     \"netFunding\",\"subaccountNumber\"",
													"    ].forEach((k) => pm.expect(p, `${k} ${i}`).to.have.property(k));",
													"",
													"    pm.expect(p.market).to.be.a(\"string\");",
													"    pm.expect(p.status).to.be.a(\"string\");",
													"    pm.expect(p.side).to.be.a(\"string\");",
													"    [\"size\",\"maxSize\",\"entryPrice\",\"realizedPnl\",\"unrealizedPnl\",\"sumOpen\",\"sumClose\",\"netFunding\",\"createdAtHeight\"]",
													"      .forEach((k) => { pm.expect(p[k]).to.be.a(\"string\"); pm.expect(isNumericString(p[k]), `${k} numeric ${i}`).to.be.true; });",
													"    pm.expect(p.subaccountNumber).to.be.a(\"number\");",
													"",
													"    // nullable fields",
													"    pm.expect(p.exitPrice === null || typeof p.exitPrice === \"string\", `exitPrice nullable ${i}`).to.be.true;",
													"    if (p.exitPrice !== null) pm.expect(isNumericString(p.exitPrice), `exitPrice numeric ${i}`).to.be.true;",
													"    pm.expect(p.closedAt === null || typeof p.closedAt === \"string\", `closedAt nullable ${i}`).to.be.true;",
													"",
													"    // date checks",
													"    pm.expect(isIso(p.createdAt), `createdAt ISO ${i}`).to.be.true;",
													"    if (p.closedAt) pm.expect(isIso(p.closedAt), `closedAt ISO ${i}`).to.be.true;",
													"  });",
													"});",
													"",
													"// 4) Enums for status/side",
													"pm.test(\"status/side enums\", () => {",
													"  const validStatus = [\"OPEN\", \"CLOSED\"];",
													"  const validSides = [\"LONG\", \"SHORT\"];",
													"  body.positions.forEach((p, i) => {",
													"    pm.expect(validStatus, `status ${i}`).to.include(p.status);",
													"    pm.expect(validSides, `side ${i}`).to.include(p.side);",
													"  });",
													"});",
													"",
													"// 5) JSON schema guard",
													"pm.test(\"matches schema\", () => {",
													"  const item = {",
													"    type: \"object\",",
													"    properties: {",
													"      market: { type: \"string\" },",
													"      status: { type: \"string\", enum: [\"OPEN\", \"CLOSED\"] },",
													"      side: { type: \"string\", enum: [\"LONG\", \"SHORT\"] },",
													"      size: { type: \"string\" },",
													"      maxSize: { type: \"string\" },",
													"      entryPrice: { type: \"string\" },",
													"      exitPrice: { type: [\"string\",\"null\"] },",
													"      realizedPnl: { type: \"string\" },",
													"      unrealizedPnl: { type: \"string\" },",
													"      createdAt: { type: \"string\", format: \"date-time\" },",
													"      createdAtHeight: { type: \"string\" },",
													"      closedAt: { type: [\"string\",\"null\"] },",
													"      sumOpen: { type: \"string\" },",
													"      sumClose: { type: \"string\" },",
													"      netFunding: { type: \"string\" },",
													"      subaccountNumber: { type: \"number\" }",
													"    },",
													"    required: [",
													"      \"market\",\"status\",\"side\",\"size\",\"maxSize\",\"entryPrice\",\"exitPrice\",\"realizedPnl\",",
													"      \"unrealizedPnl\",\"createdAt\",\"createdAtHeight\",\"closedAt\",\"sumOpen\",\"sumClose\",",
													"      \"netFunding\",\"subaccountNumber\"",
													"    ],",
													"    additionalProperties: false",
													"  };",
													"  const schema = { type: \"object\", properties: { positions: { type: \"array\", items: item } }, required: [\"positions\"], additionalProperties: false };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/perpetualPositions?address={{validdYdXAddress}}&subaccountNumber=0",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"perpetualPositions"
											],
											"query": [
												{
													"key": "address",
													"value": "{{validdYdXAddress}}"
												},
												{
													"key": "subaccountNumber",
													"value": "0"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "getPositions INVALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"",
													"// 1) Status + latency",
													"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
													"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
													"",
													"// 2) Shape",
													"const body = asJson();",
													"pm.test(\"has positions[]\", () => {",
													"  pm.expect(body).to.be.an(\"object\");",
													"  pm.expect(body.positions).to.be.an(\"array\");",
													"});",
													"",
													"// 3) Empty for invalid address",
													"pm.test(\"positions array is empty for invalid address\", () => pm.expect(body.positions.length).to.eql(0));",
													"",
													"// 4) Schema guard",
													"pm.test(\"matches schema\", () => {",
													"  const schema = {",
													"    type: \"object\",",
													"    properties: {",
													"      positions: { type: \"array\", maxItems: 0 }",
													"    },",
													"    required: [\"positions\"],",
													"    additionalProperties: true",
													"  };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/perpetualPositions?address={{invaliddYdXAddress}}&subaccountNumber=0",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"perpetualPositions"
											],
											"query": [
												{
													"key": "address",
													"value": "{{invaliddYdXAddress}}"
												},
												{
													"key": "subaccountNumber",
													"value": "0"
												}
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "sparklines",
							"item": [
								{
									"name": "sparklines",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"const isNumericString = (v) => v !== null && v !== undefined && !Number.isNaN(Number(v));",
													"",
													"// 1) Status + latency",
													"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
													"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
													"",
													"// 2) Shape",
													"const body = asJson();",
													"pm.test(\"response is object with arrays\", () => {",
													"  pm.expect(body).to.be.an(\"object\");",
													"  Object.keys(body).forEach((k) => pm.expect(body[k], k).to.be.an(\"array\"));",
													"});",
													"",
													"// 3) Values are stringified numbers",
													"pm.test(\"sparkline values are numeric strings\", () => {",
													"  Object.keys(body).forEach((k) => {",
													"    body[k].forEach((v, i) => {",
													"      pm.expect(v, `${k}[${i}]`).to.be.a(\"string\");",
													"      pm.expect(isNumericString(v), `${k}[${i}] numeric`).to.be.true;",
													"    });",
													"  });",
													"});",
													"",
													"// 4) JSON schema guard",
													"pm.test(\"matches schema\", () => {",
													"  const schema = {",
													"    type: \"object\",",
													"    patternProperties: {",
													"      \".*\": {",
													"        type: \"array\",",
													"        items: { type: \"string\" }",
													"      }",
													"    },",
													"    additionalProperties: false",
													"  };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/sparklines/?timePeriod=ONE_DAY",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"sparklines",
												""
											],
											"query": [
												{
													"key": "timePeriod",
													"value": "ONE_DAY"
												}
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "trader",
							"item": [
								{
									"name": "search/ VALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"const dydxAddressRe = /^dydx1[a-z0-9]{38}$/;",
													"",
													"// 1) Status + latency",
													"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
													"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
													"",
													"// 2) Shape",
													"const body = asJson();",
													"pm.test(\"has result object\", () => {",
													"  pm.expect(body).to.be.an(\"object\");",
													"  pm.expect(body.result).to.be.an(\"object\");",
													"});",
													"",
													"// 3) Fields and types",
													"pm.test(\"result fields valid\", () => {",
													"  const r = body.result;",
													"  pm.expect(r.address).to.be.a(\"string\").and.match(dydxAddressRe);",
													"  pm.expect(r.subaccountNumber).to.be.a(\"number\");",
													"  pm.expect(r.subaccountId).to.be.a(\"string\");",
													"  pm.expect(r.username).to.be.a(\"string\");",
													"});",
													"",
													"// 4) No unexpected properties",
													"pm.test(\"no unexpected properties in result\", () => {",
													"  const allowed = [\"address\",\"subaccountNumber\",\"subaccountId\",\"username\"];",
													"  Object.keys(body.result).forEach((k) => pm.expect(allowed).to.include(k));",
													"});",
													"",
													"// 5) JSON schema guard",
													"pm.test(\"matches schema\", () => {",
													"  const schema = {",
													"    type: \"object\",",
													"    properties: {",
													"      result: {",
													"        type: \"object\",",
													"        properties: {",
													"          address: { type: \"string\", pattern: \"^dydx1[a-z0-9]{38}$\" },",
													"          subaccountNumber: { type: \"number\" },",
													"          subaccountId: { type: \"string\" },",
													"          username: { type: \"string\" }",
													"        },",
													"        required: [\"address\",\"subaccountNumber\",\"subaccountId\",\"username\"],",
													"        additionalProperties: false",
													"      }",
													"    },",
													"    required: [\"result\"],",
													"    additionalProperties: false",
													"  };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/trader/search?searchParam={{validdYdXAddress}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"trader",
												"search"
											],
											"query": [
												{
													"key": "searchParam",
													"value": "{{validdYdXAddress}}"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "search/ INVALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"",
													"// 1) Status (API returns 404 for not found; allow 400 if validation)",
													"pm.test(\"status is 404 or 400\", () => pm.expect(pm.response.code).to.be.oneOf([404, 400]));",
													"",
													"// 2) Latency",
													"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
													"",
													"// 3) Shape",
													"const body = asJson();",
													"pm.test(\"has errors[]\", () => {",
													"  pm.expect(body).to.be.an(\"object\");",
													"  pm.expect(body.errors).to.be.an(\"array\").with.length.greaterThan(0);",
													"});",
													"",
													"// 4) Error message content",
													"pm.test(\"error message indicates subaccount not found\", () => {",
													"  const err = body.errors[0];",
													"  pm.expect(err.msg).to.be.a(\"string\");",
													"  pm.expect(err.msg).to.include(\"Subaccount not found\");",
													"});",
													"",
													"// 5) Schema guard",
													"pm.test(\"matches error schema\", () => {",
													"  const schema = {",
													"    type: \"object\",",
													"    properties: {",
													"      errors: {",
													"        type: \"array\",",
													"        minItems: 1,",
													"        items: {",
													"          type: \"object\",",
													"          properties: { msg: { type: \"string\" } },",
													"          required: [\"msg\"],",
													"          additionalProperties: true",
													"        }",
													"      }",
													"    },",
													"    required: [\"errors\"],",
													"    additionalProperties: true",
													"  };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/trader/search?searchParam={{invaliddYdXAddress}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"trader",
												"search"
											],
											"query": [
												{
													"key": "searchParam",
													"value": "{{invaliddYdXAddress}}"
												}
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "time",
							"item": [
								{
									"name": "getTime",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"const isIso = (s) => /^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?Z)$/.test(s);",
													"",
													"// 1) Status + latency",
													"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
													"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
													"",
													"// 2) Shape",
													"const body = asJson();",
													"pm.test(\"has iso (string) and epoch (number)\", () => {",
													"  pm.expect(body).to.be.an(\"object\");",
													"  pm.expect(body.iso).to.be.a(\"string\");",
													"  pm.expect(body.epoch).to.be.a(\"number\");",
													"});",
													"",
													"// 3) Value checks",
													"pm.test(\"iso is valid ISO-8601\", () => pm.expect(isIso(body.iso)).to.be.true);",
													"pm.test(\"epoch is numeric\", () => pm.expect(body.epoch).to.be.a(\"number\"));",
													"",
													"// 4) JSON schema guard",
													"pm.test(\"matches schema\", () => {",
													"  const schema = {",
													"    type: \"object\",",
													"    properties: {",
													"      iso: { type: \"string\", format: \"date-time\" },",
													"      epoch: { type: \"number\" }",
													"    },",
													"    required: [\"iso\", \"epoch\"],",
													"    additionalProperties: true",
													"  };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/time",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"time"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "trades",
							"item": [
								{
									"name": "trades/perptualMarket/ VALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"const isNumericString = (v) => v !== null && v !== undefined && !Number.isNaN(Number(v));",
													"",
													"// 1) Status + latency",
													"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
													"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
													"",
													"// 2) Shape",
													"const body = asJson();",
													"pm.test(\"has trades[]\", () => {",
													"  pm.expect(body).to.be.an(\"object\");",
													"  pm.expect(body.trades).to.be.an(\"array\");",
													"});",
													"",
													"// 3) Trade schema + values",
													"pm.test(\"trades have expected fields/types\", () => {",
													"  body.trades.forEach((t, i) => {",
													"    [\"id\",\"side\",\"size\",\"price\",\"type\",\"createdAt\",\"createdAtHeight\"].forEach((k) =>",
													"      pm.expect(t, `${k} ${i}`).to.have.property(k)",
													"    );",
													"    pm.expect(t.id).to.be.a(\"string\");",
													"    pm.expect([\"BUY\",\"SELL\"]).to.include(t.side);",
													"    pm.expect(t.size).to.be.a(\"string\"); pm.expect(isNumericString(t.size)).to.be.true;",
													"    pm.expect(t.price).to.be.a(\"string\"); pm.expect(isNumericString(t.price)).to.be.true;",
													"    pm.expect(t.type).to.be.a(\"string\");",
													"    pm.expect(t.createdAt).to.be.a(\"string\");",
													"    pm.expect(t.createdAtHeight).to.be.a(\"string\"); pm.expect(isNumericString(t.createdAtHeight)).to.be.true;",
													"    // createdAt parses as date",
													"    const d = new Date(t.createdAt);",
													"    pm.expect(d.toString()).not.to.equal(\"Invalid Date\");",
													"    // No unexpected keys",
													"    const allowed = [\"id\",\"side\",\"size\",\"price\",\"type\",\"createdAt\",\"createdAtHeight\"];",
													"    Object.keys(t).forEach((k) => pm.expect(allowed).to.include(k, `Unexpected property: ${k}`));",
													"  });",
													"});",
													"",
													"// 4) Optional: descending order by createdAt",
													"pm.test(\"trades ordered by createdAt desc\", () => {",
													"  const ts = body.trades.map((t) => Date.parse(t.createdAt));",
													"  for (let i = 0; i < ts.length - 1; i++) pm.expect(ts[i]).to.be.at.least(ts[i + 1]);",
													"});",
													"",
													"// 5) JSON schema guard",
													"pm.test(\"matches schema\", () => {",
													"  const item = {",
													"    type: \"object\",",
													"    properties: {",
													"      id: { type: \"string\" },",
													"      side: { type: \"string\" },",
													"      size: { type: \"string\" },",
													"      price: { type: \"string\" },",
													"      type: { type: \"string\" },",
													"      createdAt: { type: \"string\", format: \"date-time\" },",
													"      createdAtHeight: { type: \"string\" }",
													"    },",
													"    required: [\"id\",\"side\",\"size\",\"price\",\"type\",\"createdAt\",\"createdAtHeight\"],",
													"    additionalProperties: false",
													"  };",
													"  const schema = { type: \"object\", properties: { trades: { type: \"array\", items: item } }, required: [\"trades\"], additionalProperties: false };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/trades/perpetualMarket/{{ticker}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"trades",
												"perpetualMarket",
												"{{ticker}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "trades/perptualMarket/ INVALID",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"",
													"// 1) Status",
													"pm.test(\"status 400\", () => pm.response.to.have.status(400));",
													"",
													"// 2) Errors array",
													"const body = asJson();",
													"pm.test(\"has errors[]\", () => {",
													"  pm.expect(body).to.be.an(\"object\");",
													"  pm.expect(body.errors).to.be.an(\"array\").with.length.greaterThan(0);",
													"});",
													"",
													"// 3) Error object structure and values",
													"pm.test(\"ticker validation error present\", () => {",
													"  const err = body.errors.find((e) => e.param === \"ticker\") || body.errors[0];",
													"  pm.expect(err.value).to.eql(\"!!!-!!!\");",
													"  pm.expect(err.msg).to.include(\"must be a valid ticker\");",
													"  pm.expect(err.param).to.eql(\"ticker\");",
													"  pm.expect(err.location).to.eql(\"params\");",
													"});",
													"",
													"// 4) Schema guard",
													"pm.test(\"matches error schema\", () => {",
													"  const schema = {",
													"    type: \"object\",",
													"    properties: {",
													"      errors: {",
													"        type: \"array\",",
													"        minItems: 1,",
													"        items: {",
													"          type: \"object\",",
													"          properties: {",
													"            value: { type: \"string\" },",
													"            msg: { type: \"string\" },",
													"            param: { type: \"string\" },",
													"            location: { type: \"string\" }",
													"          },",
													"          required: [\"value\", \"msg\", \"param\", \"location\"],",
													"          additionalProperties: true",
													"        }",
													"      }",
													"    },",
													"    required: [\"errors\"],",
													"    additionalProperties: true",
													"  };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/trades/perpetualMarket/{{invalidTicker}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"trades",
												"perpetualMarket",
												"{{invalidTicker}}"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "transfers",
							"item": [
								{
									"name": "getTransfers",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// Helpers",
													"const asJson = () => { try { return pm.response.json(); } catch (e) { pm.expect.fail(`Response not JSON: ${e}`); } };",
													"const isNumericString = (v) => v !== null && v !== undefined && !Number.isNaN(Number(v));",
													"const dydxAddressRe = /^dydx1[a-z0-9]{38}$/;",
													"",
													"// 1) Status + latency",
													"pm.test(\"status 200\", () => pm.response.to.have.status(200));",
													"pm.test(\"latency < 6000ms\", () => pm.expect(pm.response.responseTime).to.be.below(6000));",
													"",
													"// 2) Shape",
													"const body = asJson();",
													"pm.test(\"has transfers[]\", () => {",
													"  pm.expect(body).to.be.an(\"object\");",
													"  pm.expect(body.transfers).to.be.an(\"array\");",
													"});",
													"",
													"// 3) Transfer schema + values",
													"pm.test(\"transfers have expected fields\", () => {",
													"  body.transfers.forEach((t, i) => {",
													"    [\"id\",\"sender\",\"recipient\",\"size\",\"createdAt\",\"createdAtHeight\",\"symbol\",\"type\",\"transactionHash\"]",
													"      .forEach((k) => pm.expect(t, `${k} ${i}`).to.have.property(k));",
													"",
													"    pm.expect(t.id).to.be.a(\"string\");",
													"    pm.expect(t.size).to.be.a(\"string\"); pm.expect(isNumericString(t.size)).to.be.true;",
													"    pm.expect(t.createdAt).to.be.a(\"string\"); pm.expect(new Date(t.createdAt).toString()).not.to.equal(\"Invalid Date\");",
													"    pm.expect(t.createdAtHeight).to.be.a(\"string\"); pm.expect(isNumericString(t.createdAtHeight)).to.be.true;",
													"    pm.expect(t.symbol).to.be.a(\"string\");",
													"    pm.expect(t.type).to.be.a(\"string\"); // e.g., TRANSFER_IN/TRANSFER_OUT",
													"    pm.expect(t.transactionHash).to.be.a(\"string\");",
													"",
													"    // sender/recipient",
													"    pm.expect(t.sender).to.be.an(\"object\");",
													"    pm.expect(t.recipient).to.be.an(\"object\");",
													"    pm.expect(t.sender.address).to.be.a(\"string\").and.match(dydxAddressRe);",
													"    pm.expect(t.recipient.address).to.be.a(\"string\").and.match(dydxAddressRe);",
													"    pm.expect(t.sender.subaccountNumber).to.be.a(\"number\");",
													"    pm.expect(t.recipient.subaccountNumber).to.be.a(\"number\");",
													"",
													"    // No unexpected keys at top-level transfer",
													"    const allowed = [\"id\",\"sender\",\"recipient\",\"size\",\"createdAt\",\"createdAtHeight\",\"symbol\",\"type\",\"transactionHash\"];",
													"    Object.keys(t).forEach((k) => pm.expect(allowed).to.include(k, `Unexpected key: ${k}`));",
													"  });",
													"});",
													"",
													"// 4) Optional: type enum check",
													"pm.test(\"transfer type is expected\", () => {",
													"  const allowedTypes = [\"TRANSFER_IN\",\"TRANSFER_OUT\"];",
													"  body.transfers.forEach((t) => pm.expect(allowedTypes).to.include(t.type));",
													"});",
													"",
													"// 5) JSON schema guard",
													"pm.test(\"matches schema\", () => {",
													"  const party = {",
													"    type: \"object\",",
													"    properties: {",
													"      address: { type: \"string\", pattern: \"^dydx1[a-z0-9]{38}$\" },",
													"      subaccountNumber: { type: \"number\" }",
													"    },",
													"    required: [\"address\",\"subaccountNumber\"],",
													"    additionalProperties: false",
													"  };",
													"  const item = {",
													"    type: \"object\",",
													"    properties: {",
													"      id: { type: \"string\" },",
													"      sender: party,",
													"      recipient: party,",
													"      size: { type: \"string\" },",
													"      createdAt: { type: \"string\", format: \"date-time\" },",
													"      createdAtHeight: { type: \"string\" },",
													"      symbol: { type: \"string\" },",
													"      type: { type: \"string\" },",
													"      transactionHash: { type: \"string\" }",
													"    },",
													"    required: [\"id\",\"sender\",\"recipient\",\"size\",\"createdAt\",\"createdAtHeight\",\"symbol\",\"type\",\"transactionHash\"],",
													"    additionalProperties: false",
													"  };",
													"  const schema = { type: \"object\", properties: { transfers: { type: \"array\", items: item } }, required: [\"transfers\"], additionalProperties: false };",
													"  pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/transfers?address={{validdYdXAddress}}&subaccountNumber=0",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"transfers"
											],
											"query": [
												{
													"key": "address",
													"value": "{{validdYdXAddress}}"
												},
												{
													"key": "subaccountNumber",
													"value": "0"
												}
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "vault",
							"item": [
								{
									"name": "v1/megavault/historicalPnl",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify response status code is 200",
													"pm.test(\"Response status code is 200\", function () {",
													"    pm.response.to.have.status(200);",
													"});",
													"",
													"// 2. Check that the response time is below 6000ms",
													"pm.test(\"Response time is less than 6000ms\", function () {",
													"    pm.expect(pm.response.responseTime).to.be.below(6000);",
													"});",
													"",
													"// 3. Validate the top-level structure",
													"pm.test(\"Response contains a 'megavaultPnl' array\", function () {",
													"    const responseJson = pm.response.json();",
													"    pm.expect(responseJson).to.be.an(\"object\");",
													"    pm.expect(responseJson).to.have.property(\"megavaultPnl\").that.is.an(\"array\");",
													"});",
													"",
													"// 4. Ensure `megavaultPnl` is not empty (if applicable, or adjust if it can be empty)",
													"pm.test(\"'megavaultPnl' array is not empty\", function () {",
													"    const responseJson = pm.response.json(); // Parse it fresh or ensure it's available",
													"    // First, ensure megavaultPnl exists and is an array before checking its length",
													"    if (responseJson && responseJson.megavaultPnl && Array.isArray(responseJson.megavaultPnl)) {",
													"        pm.expect(responseJson.megavaultPnl.length).to.be.above(",
													"            0,",
													"            \"Expected at least one 'megavaultPnl' record, but got none.\" // Corrected message",
													"        );",
													"    } else {",
													"        // If it can be legitimately empty or missing, this part might need adjustment",
													"        // For now, if it's missing and expected, let's fail clearly.",
													"        pm.expect.fail(\"Response does not contain a 'megavaultPnl' array or it's not an array.\");",
													"    }",
													"});",
													"",
													"// 5. Validate each record's structure",
													"pm.test(\"Validate structure of each record in 'megavaultPnl'\", function () {",
													"    const responseJson = pm.response.json();",
													"    ",
													"    // It's good practice to check if megavaultPnl exists and has items before iterating",
													"    // Test #4 should ideally cover the \"not empty\" part, but an extra check here is robust",
													"    if (!responseJson.megavaultPnl || responseJson.megavaultPnl.length === 0) {",
													"        // If test #4 already asserts it's not empty, this condition might not be hit often",
													"        // Or, you could remove this check if test #4 is deemed sufficient",
													"        console.warn(\"Skipping record structure validation as 'megavaultPnl' is empty or missing.\");",
													"        return; // Exit this test if no records to validate",
													"    }",
													"",
													"    responseJson.megavaultPnl.forEach((record, index) => {",
													"        pm.test(`Record ${index} has correct structure`, function() { // Individual test per record",
													"            pm.expect(record).to.be.an(\"object\");",
													"",
													"            // Required properties based on YOUR PROVIDED JSON",
													"            pm.expect(record, `Record ${index} missing 'equity'`).to.have.property(\"equity\").that.is.a(\"string\");",
													"            pm.expect(record, `Record ${index} missing 'totalPnl'`).to.have.property(\"totalPnl\").that.is.a(\"string\");",
													"            pm.expect(record, `Record ${index} missing 'netTransfers'`).to.have.property(\"netTransfers\").that.is.a(\"string\");",
													"            pm.expect(record, `Record ${index} missing 'createdAt'`).to.have.property(\"createdAt\").that.is.a(\"string\");",
													"            pm.expect(record, `Record ${index} missing 'blockHeight'`).to.have.property(\"blockHeight\").that.is.a(\"string\");",
													"            pm.expect(record, `Record ${index} missing 'blockTime'`).to.have.property(\"blockTime\").that.is.a(\"string\");",
													"",
													"",
													"            // Check numeric fields are indeed parseable as numbers",
													"            pm.expect(parseFloat(record.equity), `Record ${index} 'equity' is not a valid number`).to.not.be.NaN;",
													"            pm.expect(parseFloat(record.totalPnl), `Record ${index} 'totalPnl' is not a valid number`).to.not.be.NaN;",
													"            pm.expect(parseFloat(record.netTransfers), `Record ${index} 'netTransfers' is not a valid number`).to.not.be.NaN;",
													"",
													"            // Check blockHeight looks parseable as an integer",
													"            pm.expect(parseInt(record.blockHeight, 10), `Record ${index} 'blockHeight' is not a valid integer`).to.not.be.NaN;",
													"",
													"            // Check date fields are valid",
													"            const createdDate = new Date(record.createdAt);",
													"            pm.expect(createdDate.toString(), `Record ${index} 'createdAt' is not a valid date`).not.to.equal(\"Invalid Date\");",
													"",
													"            const blockDate = new Date(record.blockTime);",
													"            pm.expect(blockDate.toString(), `Record ${index} 'blockTime' is not a valid date`).not.to.equal(\"Invalid Date\");",
													"        });",
													"    });",
													"});",
													"",
													"// 6. Validate the response body against a JSON Schema",
													"pm.test(\"Response matches JSON schema for megavaultPnl\", function () {",
													"    const schema = {",
													"        type: \"object\",",
													"        required: [\"megavaultPnl\"],",
													"        properties: {",
													"            megavaultPnl: {",
													"                type: \"array\",",
													"                minItems: 0, // Allow empty array if that's valid, or 1 if it must not be empty",
													"                items: {",
													"                    type: \"object\",",
													"                    required: [",
													"                        \"equity\",",
													"                        \"totalPnl\",",
													"                        \"netTransfers\",",
													"                        \"createdAt\",",
													"                        \"blockHeight\",",
													"                        \"blockTime\"",
													"                    ],",
													"                    properties: {",
													"                        equity: {",
													"                            type: \"string\",",
													"                            // Updated pattern to allow for optional decimal part",
													"                            pattern: \"^-?[0-9]+(?:\\\\.[0-9]+)?$\"",
													"                        },",
													"                        totalPnl: {",
													"                            type: \"string\",",
													"                            // Updated pattern to allow for optional decimal part",
													"                            pattern: \"^-?[0-9]+(?:\\\\.[0-9]+)?$\"",
													"                        },",
													"                        netTransfers: {",
													"                            type: \"string\",",
													"                            // Updated pattern to allow for optional decimal part",
													"                            pattern: \"^-?[0-9]+(?:\\\\.[0-9]+)?$\"",
													"                        },",
													"                        createdAt: { type: \"string\", format: \"date-time\" },",
													"                        blockHeight: { type: \"string\", pattern: \"^[0-9]+$\" }, // Assumes blockHeight is always a positive integer string",
													"                        blockTime: { type: \"string\", format: \"date-time\" }",
													"                    },",
													"                    additionalProperties: false // Set to true if other properties are allowed but not validated",
													"                }",
													"            }",
													"        }",
													"    };",
													"",
													"    const responseData = pm.response.json();",
													"",
													"    // Optional: Log a sample of the data that's causing issues if the test fails",
													"    // This helps in debugging if the pattern is still too restrictive",
													"    if (responseData.megavaultPnl && responseData.megavaultPnl.length > 0) {",
													"        const firstRecord = responseData.megavaultPnl[0];",
													"        console.log(\"First record equity:\", firstRecord.equity);",
													"        console.log(\"First record totalPnl:\", firstRecord.totalPnl);",
													"        if (responseData.megavaultPnl.length > 53) { // Check if record 53 exists for netTransfers",
													"             console.log(\"Record 53 netTransfers:\", responseData.megavaultPnl[53].netTransfers);",
													"        }",
													"    }",
													"",
													"    pm.response.to.have.jsonSchema(schema);",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/vault/v1/megavault/historicalPnl",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"vault",
												"v1",
												"megavault",
												"historicalPnl"
											]
										}
									},
									"response": []
								},
								{
									"name": "v1/vaults/historicalPnl",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify response status code is 200",
													"pm.test(\"Response status code is 200\", function () {",
													"  pm.response.to.have.status(200);",
													"});",
													"",
													"// 2. Check that the response time is below a threshold (increase if needed)",
													"pm.test(\"Response time is under 20000 ms for large data\", function () {",
													"  pm.expect(pm.response.responseTime).to.be.below(20000); // 20 seconds",
													"});",
													"",
													"// 3. Parse the response JSON & top-level structure",
													"pm.test(\"Response has 'vaultsPnl' as an array\", function () {",
													"  const responseJson = pm.response.json();",
													"  pm.expect(responseJson).to.be.an(\"object\");",
													"  pm.expect(responseJson).to.have.property(\"vaultsPnl\").that.is.an(\"array\");",
													"});",
													"",
													"// 4. For each vault, check structure: 'ticker' & 'historicalPnl'",
													"pm.test(\"Each vault has a ticker and a historicalPnl array\", function () {",
													"  const { vaultsPnl } = pm.response.json();",
													"",
													"  pm.expect(vaultsPnl.length).to.be.above(0);",
													"",
													"  const maxVaultsToCheck = 20;",
													"  vaultsPnl.slice(0, maxVaultsToCheck).forEach((vault, vaultIndex) => {",
													"    pm.expect(vault).to.have.property(\"ticker\").that.is.a(\"string\");",
													"    pm.expect(vault).to.have.property(\"historicalPnl\").that.is.an(\"array\");",
													"",
													"    // 5. Validate each record in historicalPnl",
													"    const maxPnlRecordsToCheck = 20; ",
													"    vault.historicalPnl.slice(0, maxPnlRecordsToCheck).forEach((record, recIndex) => {",
													"      pm.expect(record).to.be.an(\"object\");",
													"",
													"      // Check required fields & types",
													"      pm.expect(record).to.have.property(\"equity\").that.is.a(\"string\");",
													"      pm.expect(record).to.have.property(\"totalPnl\").that.is.a(\"string\");",
													"      pm.expect(record).to.have.property(\"netTransfers\").that.is.a(\"string\");",
													"      pm.expect(record).to.have.property(\"createdAt\").that.is.a(\"string\");",
													"      pm.expect(record).to.have.property(\"blockHeight\").that.is.a(\"string\");",
													"      pm.expect(record).to.have.property(\"blockTime\").that.is.a(\"string\");",
													"",
													"      // Validate numeric fields are parseable",
													"      pm.expect(parseFloat(record.equity)).to.not.be.NaN;",
													"      pm.expect(parseFloat(record.totalPnl)).to.not.be.NaN;",
													"      pm.expect(parseFloat(record.netTransfers)).to.not.be.NaN;",
													"      pm.expect(parseInt(record.blockHeight, 10)).to.not.be.NaN;",
													"",
													"      // Validate date fields",
													"      const createdAtDate = new Date(record.createdAt);",
													"      pm.expect(createdAtDate.toString()).not.to.equal(\"Invalid Date\");",
													"",
													"      const blockTimeDate = new Date(record.blockTime);",
													"      pm.expect(blockTimeDate.toString()).not.to.equal(\"Invalid Date\");",
													"    });",
													"  });",
													"});",
													"",
													"// 6. Validate the overall response against a JSON Schema",
													"pm.test(\"Response matches JSON schema for vaults/vaultsPnl\", function () {",
													"  const schema = {",
													"    type: \"object\",",
													"    required: [\"vaultsPnl\"],",
													"    properties: {",
													"      vaultsPnl: {",
													"        type: \"array\",",
													"        items: {",
													"          type: \"object\",",
													"          required: [\"ticker\", \"historicalPnl\"],",
													"          properties: {",
													"            ticker: { type: \"string\" },",
													"            historicalPnl: {",
													"              type: \"array\",",
													"              items: {",
													"                type: \"object\",",
													"                required: [",
													"                  \"equity\",",
													"                  \"totalPnl\",",
													"                  \"netTransfers\",",
													"                  \"createdAt\",",
													"                  \"blockTime\"",
													"                ],",
													"                properties: {",
													"                  equity: { type: \"string\" },",
													"                  totalPnl: { type: \"string\" },",
													"                  netTransfers: { type: \"string\" },",
													"                  createdAt: { type: \"string\", format: \"date-time\" },",
													"                  blockHeight: { type: \"string\" },",
													"                  blockTime: { type: \"string\", format: \"date-time\" }",
													"                }",
													"              }",
													"            }",
													"          }",
													"        }",
													"      }",
													"    }",
													"  };",
													"",
													"  pm.response.to.have.jsonSchema(schema);",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/vault/v1/vaults/historicalPnl",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"vault",
												"v1",
												"vaults",
												"historicalPnl"
											]
										}
									},
									"response": []
								}
							]
						}
					]
				}
			]
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					"// Collection-level helpers",
					"const getTimeout = () => Number(pm.environment.get(\"defaultTimeoutMs\") || pm.collectionVariables.get(\"defaultTimeoutMs\") || 6000);",
					"if (!pm.testHelpers) {",
					"  const asJson = () => {",
					"    try { return pm.response.json(); }",
					"    catch (e) { pm.expect.fail(`Response not JSON: ${e}`); }",
					"  };",
					"  const isNumericString = (v) => v !== null && v !== undefined && !Number.isNaN(Number(v));",
					"  const isIso = (s) => /^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?Z)$/.test(s);",
					"  const dydxAddressRe = /^dydx1[a-z0-9]{38}$/;",
					"  pm.testHelpers = { asJson, isNumericString, isIso, dydxAddressRe, getTimeout };",
					"}",
					"// Baseline latency check applied to all requests",
					"pm.test(\"latency < defaultTimeoutMs\", () => pm.expect(pm.response.responseTime).to.be.below(getTimeout()));"
				]
			}
		}
	]
}