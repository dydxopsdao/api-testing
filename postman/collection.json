{
	"info": {
		"_postman_id": "981cef60-dcd2-4b5e-aefb-c7d1dd2e08dc",
		"name": "dYdX",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "41849022",
		"_collection_link": "https://dydx-ops-services.postman.co/workspace/fdeed7e0-d6ed-46c3-926d-fdf269d648ad/collection/41849022-981cef60-dcd2-4b5e-aefb-c7d1dd2e08dc?action=share&source=collection_link&creator=41849022"
	},
	"item": [
		{
			"name": "Indexer",
			"item": [
				{
					"name": "addresses",
					"item": [
						{
							"name": "address",
							"item": [
								{
									"name": "/addresses/{address} valid Address",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify response status code",
													"pm.test(\"Response status code is 200\", function () {",
													"    pm.response.to.have.status(200);",
													"});",
													"",
													"// 2. Check response time (threshold set to 500ms)",
													"pm.test(\"Response time is less than 6000ms\", function () {",
													"    pm.expect(pm.response.responseTime).to.be.below(6000);",
													"});",
													"",
													"// 3. Validate top-level structure",
													"pm.test(\"Response has 'subaccounts' array and 'totalTradingRewards'\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData).to.be.an('object');",
													"",
													"    // Ensure the expected properties exist",
													"    pm.expect(jsonData).to.have.property('subaccounts').that.is.an('array');",
													"    pm.expect(jsonData).to.have.property('totalTradingRewards').that.is.a('string');",
													"",
													"    // Ensure totalTradingRewards is a valid number (even if it's 0)",
													"    const totalTradingRewards = parseFloat(jsonData.totalTradingRewards);",
													"    pm.expect(totalTradingRewards).to.be.a('number');",
													"    pm.expect(totalTradingRewards).to.be.at.least(0);",
													"});",
													"",
													"// 4. Validate the schema of each subaccount dynamically",
													"pm.test(\"Validate schema for each subaccount\", function () {",
													"    const responseData = pm.response.json();",
													"    const subaccounts = responseData.subaccounts;",
													"",
													"    pm.expect(subaccounts).to.be.an('array');",
													"",
													"    subaccounts.forEach((subaccount) => {",
													"        // Basic property checks",
													"        pm.expect(subaccount).to.have.property('address').that.is.a('string');",
													"        pm.expect(subaccount).to.have.property('subaccountNumber').that.is.a('number');",
													"        pm.expect(subaccount).to.have.property('equity').that.is.a('string');",
													"        pm.expect(subaccount).to.have.property('freeCollateral').that.is.a('string');",
													"        pm.expect(subaccount).to.have.property('marginEnabled').that.is.a('boolean');",
													"        pm.expect(subaccount).to.have.property('updatedAtHeight').that.is.a('string');",
													"        pm.expect(subaccount).to.have.property('latestProcessedBlockHeight').that.is.a('string');",
													"        pm.expect(subaccount).to.have.property('openPerpetualPositions').that.is.an('object');",
													"        pm.expect(subaccount).to.have.property('assetPositions').that.is.an('object');",
													"",
													"        // Ensure numerical values are valid",
													"        pm.expect(parseFloat(subaccount.equity)).to.not.be.NaN;",
													"        pm.expect(parseFloat(subaccount.freeCollateral)).to.not.be.NaN;",
													"        pm.expect(parseInt(subaccount.updatedAtHeight)).to.not.be.NaN;",
													"        pm.expect(parseInt(subaccount.latestProcessedBlockHeight)).to.not.be.NaN;",
													"",
													"        // Validate assetPositions structure if not empty",
													"        if (Object.keys(subaccount.assetPositions).length > 0) {",
													"            Object.values(subaccount.assetPositions).forEach(asset => {",
													"                pm.expect(asset).to.have.property('size').that.is.a('string');",
													"                pm.expect(asset).to.have.property('symbol').that.is.a('string');",
													"                pm.expect(asset).to.have.property('side').that.is.a('string');",
													"                pm.expect(asset).to.have.property('assetId');",
													"                pm.expect(asset).to.have.property('subaccountNumber').that.is.a('number');",
													"",
													"                // Ensure size is a valid number",
													"                pm.expect(parseFloat(asset.size)).to.not.be.NaN;",
													"            });",
													"        }",
													"    });",
													"});",
													"",
													"// 5. Ensure no unexpected properties exist in subaccounts (schema integrity check)",
													"pm.test(\"No unexpected properties in subaccount schema\", function () {",
													"    const responseData = pm.response.json();",
													"    const subaccounts = responseData.subaccounts;",
													"",
													"    const expectedKeys = [",
													"        \"address\",",
													"        \"subaccountNumber\",",
													"        \"equity\",",
													"        \"freeCollateral\",",
													"        \"openPerpetualPositions\",",
													"        \"assetPositions\",",
													"        \"marginEnabled\",",
													"        \"updatedAtHeight\",",
													"        \"latestProcessedBlockHeight\"",
													"    ];",
													"",
													"    subaccounts.forEach((subaccount) => {",
													"        const keys = Object.keys(subaccount);",
													"        keys.forEach(key => {",
													"            pm.expect(expectedKeys).to.include(key, `Unexpected property found: ${key}`);",
													"        });",
													"    });",
													"});",
													"",
													"// 6. Ensure each subaccount address is a valid dydx address format (basic check)",
													"pm.test(\"All subaccounts have a valid dydx address format\", function () {",
													"    const subaccounts = pm.response.json().subaccounts;",
													"    const dydxAddressPattern = /^dydx1[a-z0-9]{38}$/; // Rough regex for dydx address",
													"",
													"    subaccounts.forEach((subaccount) => {",
													"        pm.expect(subaccount.address).to.match(dydxAddressPattern, \"Invalid dydx address format\");",
													"    });",
													"});",
													"",
													"const schema = {",
													"    \"type\": \"object\",",
													"    \"properties\": {",
													"        \"subaccounts\": {",
													"            \"type\": \"array\",",
													"            \"items\": {",
													"                \"type\": \"object\",",
													"                \"properties\": {",
													"                    \"address\": { \"type\": \"string\" },",
													"                    \"subaccountNumber\": { \"type\": \"number\" },",
													"                    \"equity\": { \"type\": \"string\" },",
													"                    \"freeCollateral\": { \"type\": \"string\" },",
													"                    \"marginEnabled\": { \"type\": \"boolean\" },",
													"                    \"updatedAtHeight\": { \"type\": \"string\" },",
													"                    \"latestProcessedBlockHeight\": { \"type\": \"string\" },",
													"                    \"openPerpetualPositions\": { \"type\": \"object\" },",
													"                    \"assetPositions\": { \"type\": \"object\" }",
													"                },",
													"                \"required\": [\"address\", \"subaccountNumber\", \"equity\", \"freeCollateral\", \"marginEnabled\", \"updatedAtHeight\", \"latestProcessedBlockHeight\", \"openPerpetualPositions\", \"assetPositions\"]",
													"            }",
													"        },",
													"        \"totalTradingRewards\": { \"type\": \"string\" }",
													"    },",
													"    \"required\": [\"subaccounts\", \"totalTradingRewards\"]",
													"};",
													"",
													"pm.test(\"Response matches expected schema\", function () {",
													"    pm.response.to.have.jsonSchema(schema);",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/addresses/{{validdYdXAddress}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"addresses",
												"{{validdYdXAddress}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "/addresses/{address} invalid Address",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify response status code (should be 400 or 404)",
													"pm.test(\"Response status code is 400 or 404 for invalid address\", function () {",
													"    pm.expect(pm.response.code).to.be.oneOf([400, 404]);",
													"});",
													"",
													"// 2. Validate the presence and structure of the 'errors' array",
													"pm.test(\"Response contains 'errors' array\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData).to.have.property(\"errors\").that.is.an(\"array\").with.lengthOf.at.least(1);",
													"});",
													"",
													"// 3. Validate the structure of each error object",
													"pm.test(\"Each error object contains 'msg' property\", function () {",
													"    const jsonData = pm.response.json();",
													"",
													"    jsonData.errors.forEach(error => {",
													"        pm.expect(error).to.have.property(\"msg\").that.is.a(\"string\");",
													"    });",
													"});",
													"",
													"// 4. Validate the specific error message format",
													"pm.test(\"Error message is correct for invalid address\", function () {",
													"    const jsonData = pm.response.json();",
													"    const errorMsg = jsonData.errors[0].msg;",
													"",
													"    pm.expect(errorMsg).to.match(/^No subaccounts found for address dydy/);",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/addresses/{{invaliddYdXAddress}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"addresses",
												"{{invaliddYdXAddress}}"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "subaccountNumber",
							"item": [
								{
									"name": "/addresses/{address}/subaccountNumber Invalid",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify response status code is 400",
													"pm.test(\"Response status code is 400 for invalid subaccountNumber\", function () {",
													"    pm.response.to.have.status(400);",
													"});",
													"",
													"// 2. Validate presence of 'errors' array",
													"pm.test(\"Response contains 'errors' array\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData).to.have.property(\"errors\").that.is.an(\"array\").with.lengthOf.at.least(1);",
													"});",
													"",
													"// 3. Validate structure of error object",
													"pm.test(\"Each error object contains 'msg', 'value', 'param', and 'location'\", function () {",
													"    const jsonData = pm.response.json();",
													"",
													"    jsonData.errors.forEach(error => {",
													"        pm.expect(error).to.have.property(\"msg\").that.is.a(\"string\");",
													"        pm.expect(error).to.have.property(\"value\").that.is.a(\"string\");",
													"        pm.expect(error).to.have.property(\"param\").that.is.a(\"string\");",
													"        pm.expect(error).to.have.property(\"location\").that.is.a(\"string\");",
													"    });",
													"});",
													"",
													"// 4. Validate error message for incorrect subaccountNumber",
													"pm.test(\"Error message is correct for invalid subaccountNumber\", function () {",
													"    const jsonData = pm.response.json();",
													"    const errorMsg = jsonData.errors[0].msg;",
													"",
													"    pm.expect(errorMsg).to.eql(\"subaccountNumber must be a non-negative integer less than 128001\");",
													"});",
													"",
													"// 5. Validate 'param' is correctly identifying subaccountNumber",
													"pm.test(\"Error response correctly identifies 'subaccountNumber' as the invalid parameter\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData.errors[0].param).to.eql(\"subaccountNumber\");",
													"});",
													"",
													"// 6. Validate 'location' is in 'params'",
													"pm.test(\"'location' is correctly specified as 'params'\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData.errors[0].location).to.eql(\"params\");",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/addresses/{{validdYdXAddress}}/subaccountNumber/{{invaliddYdXAddressSubAccountNumber}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"addresses",
												"{{validdYdXAddress}}",
												"subaccountNumber",
												"{{invaliddYdXAddressSubAccountNumber}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "/addresses/{address}/subaccountNumber Valid",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify response status code is 200",
													"pm.test(\"Response status code is 200\", function () {",
													"    pm.response.to.have.status(200);",
													"});",
													"",
													"// 2. Validate top-level response structure",
													"pm.test(\"Response contains 'subaccount' object\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData).to.be.an(\"object\");",
													"    pm.expect(jsonData).to.have.property(\"subaccount\").that.is.an(\"object\");",
													"});",
													"",
													"// 3. Validate the schema of the 'subaccount' object",
													"pm.test(\"Subaccount object contains required properties\", function () {",
													"    const subaccount = pm.response.json().subaccount;",
													"",
													"    pm.expect(subaccount).to.have.property(\"address\").that.is.a(\"string\");",
													"    pm.expect(subaccount).to.have.property(\"subaccountNumber\").that.is.a(\"number\");",
													"    pm.expect(subaccount).to.have.property(\"equity\").that.is.a(\"string\");",
													"    pm.expect(subaccount).to.have.property(\"freeCollateral\").that.is.a(\"string\");",
													"    pm.expect(subaccount).to.have.property(\"marginEnabled\").that.is.a(\"boolean\");",
													"    pm.expect(subaccount).to.have.property(\"updatedAtHeight\").that.is.a(\"string\");",
													"    pm.expect(subaccount).to.have.property(\"latestProcessedBlockHeight\").that.is.a(\"string\");",
													"    pm.expect(subaccount).to.have.property(\"openPerpetualPositions\").that.is.an(\"object\");",
													"    pm.expect(subaccount).to.have.property(\"assetPositions\").that.is.an(\"object\");",
													"});",
													"",
													"// 4. Validate numeric values",
													"pm.test(\"Equity and FreeCollateral should be valid numeric strings\", function () {",
													"    console.log(\"Environment Variables:\");",
													"console.log(\"validdYdXAddress:\", pm.environment.get(\"validdYdXAddress\"));",
													"console.log(\"validdYdXAddressSubAccountNumber:\", pm.environment.get(\"validdYdXAddressSubAccountNumber\"));",
													"    const subaccount = pm.response.json().subaccount;",
													"",
													"    pm.expect(parseFloat(subaccount.equity)).to.not.be.NaN;",
													"    pm.expect(parseFloat(subaccount.freeCollateral)).to.not.be.NaN;",
													"    pm.expect(parseInt(subaccount.updatedAtHeight)).to.not.be.NaN;",
													"    pm.expect(parseInt(subaccount.latestProcessedBlockHeight)).to.not.be.NaN;",
													"});",
													"",
													"// 5. Validate assetPositions if present",
													"pm.test(\"Validate assetPositions structure (if not empty)\", function () {",
													"    const subaccount = pm.response.json().subaccount;",
													"    if (Object.keys(subaccount.assetPositions).length > 0) {",
													"        Object.values(subaccount.assetPositions).forEach(asset => {",
													"            pm.expect(asset).to.have.property(\"size\").that.is.a(\"string\");",
													"            pm.expect(asset).to.have.property(\"symbol\").that.is.a(\"string\");",
													"            pm.expect(asset).to.have.property(\"side\").that.is.a(\"string\");",
													"            pm.expect(asset).to.have.property(\"assetId\");",
													"            pm.expect(asset).to.have.property(\"subaccountNumber\").that.equals(subaccount.subaccountNumber);",
													"",
													"            // Validate size is a numeric string",
													"            pm.expect(parseFloat(asset.size)).to.not.be.NaN;",
													"        });",
													"    }",
													"});",
													"",
													"// 6. Verify the address and subaccountNumber match the request",
													"pm.test(\"Address and subaccountNumber match requested values\", function () {",
													"    const subaccount = pm.response.json().subaccount;",
													"    const expectedAddress = pm.environment.get(\"validdYdXAddress\"); ",
													"    const expectedSubaccountNumber = parseInt(pm.environment.get(\"validdYdXAddressSubAccountNumber\"), 10);",
													"",
													"    pm.expect(subaccount.address).to.eql(expectedAddress);",
													"    pm.expect(subaccount.subaccountNumber).to.eql(expectedSubaccountNumber);",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/addresses/{{validdYdXAddress}}/subaccountNumber/{{validdYdXAddressSubAccountNumber}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"addresses",
												"{{validdYdXAddress}}",
												"subaccountNumber",
												"{{validdYdXAddressSubAccountNumber}}"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "registerToken",
							"item": [
								{
									"name": "/addresses/{address}/registerToken valid",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\n  \"language\": \"string\",\n  \"token\": \"string\"\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{indexerBaseUrl}}addresses/{{validdYdXAddress}}/registerToken",
											"host": [
												"{{indexerBaseUrl}}addresses"
											],
											"path": [
												"{{validdYdXAddress}}",
												"registerToken"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "testNotification",
							"item": [
								{
									"name": "/addresses/{address}/testNotification",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}addresses/{{validdYdXAddress}}/testNotification",
											"host": [
												"{{indexerBaseUrl}}addresses"
											],
											"path": [
												"{{validdYdXAddress}}",
												"testNotification"
											]
										}
									},
									"response": []
								}
							]
						}
					]
				},
				{
					"name": "affiliates",
					"item": [
						{
							"name": "metadata",
							"item": [
								{
									"name": "/affiliates/metadata valid address",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify response status code is 200",
													"pm.test(\"Response status code is 200\", function () {",
													"    pm.response.to.have.status(200);",
													"});",
													"",
													"// 2. Validate top-level response structure",
													"pm.test(\"Response contains referral metadata properties\", function () {",
													"    const jsonData = pm.response.json();",
													"",
													"    pm.expect(jsonData).to.be.an(\"object\");",
													"    pm.expect(jsonData).to.have.property(\"referralCode\").that.is.a(\"string\");",
													"    pm.expect(jsonData).to.have.property(\"isVolumeEligible\").that.is.a(\"boolean\");",
													"    pm.expect(jsonData).to.have.property(\"isAffiliate\").that.is.a(\"boolean\");",
													"});",
													"",
													"// 3. Ensure referralCode is a non-empty string",
													"pm.test(\"Referral code should be a valid non-empty string\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData.referralCode).to.be.a(\"string\").and.not.be.empty;",
													"});",
													"",
													"// 4. Validate `isVolumeEligible` and `isAffiliate` are boolean values",
													"pm.test(\"Boolean fields should be valid\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData.isVolumeEligible).to.be.a(\"boolean\");",
													"    pm.expect(jsonData.isAffiliate).to.be.a(\"boolean\");",
													"});",
													"",
													"if (pm.response.code === 200) {",
													"    const jsonData = pm.response.json();",
													"",
													"    // Ensure referralCode exists and is a valid string",
													"    if (jsonData.referralCode && typeof jsonData.referralCode === \"string\" && jsonData.referralCode.length > 0) {",
													"        pm.environment.set(\"referralCode\", jsonData.referralCode);",
													"        console.log(\"Saved referralCode:\", jsonData.referralCode);",
													"    } else {",
													"        console.log(\"Referral code is missing or invalid\");",
													"    }",
													"}"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/affiliates/metadata?address={{dydxWithReferrals}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"affiliates",
												"metadata"
											],
											"query": [
												{
													"key": "address",
													"value": "{{dydxWithReferrals}}"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "/affiliates/metadata invalid address",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify response status code is 400 or 404",
													"pm.test(\"Response status code is 400 or 404 for invalid address\", function () {",
													"    pm.response.to.have.status(404)",
													"});",
													"",
													"// 2. Validate presence of 'errors' array",
													"pm.test(\"Response contains 'errors' array\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData).to.have.property(\"errors\").that.is.an(\"array\").with.lengthOf.at.least(1);",
													"});",
													"",
													"// 3. Validate the structure of the error message",
													"pm.test(\"Each error object contains 'msg' property\", function () {",
													"    const jsonData = pm.response.json();",
													"",
													"    jsonData.errors.forEach(error => {",
													"        pm.expect(error).to.have.property(\"msg\").that.is.a(\"string\");",
													"    });",
													"});",
													"",
													"// 4. Ensure error message format is correct",
													"pm.test(\"Error message correctly indicates wallet not found\", function () {",
													"    const jsonData = pm.response.json();",
													"    const errorMsg = jsonData.errors[0].msg;",
													"",
													"    pm.expect(errorMsg).to.match(/^Wallet with address dydy/);",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/affiliates/metadata?address={{invaliddYdXAddress}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"affiliates",
												"metadata"
											],
											"query": [
												{
													"key": "address",
													"value": "{{invaliddYdXAddress}}"
												}
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "address",
							"item": [
								{
									"name": "/affiliates/address valid referralCode",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify response status code is 200",
													"pm.test(\"Response status code is 200\", function () {",
													"    pm.response.to.have.status(200);",
													"});",
													"",
													"// 2. Validate response contains 'address' property",
													"pm.test(\"Response contains valid address\", function () {",
													"    const jsonData = pm.response.json();",
													"    ",
													"    pm.expect(jsonData).to.be.an(\"object\");",
													"    pm.expect(jsonData).to.have.property(\"address\").that.is.a(\"string\").and.not.be.empty;",
													"});",
													"",
													"// 3. Validate address format (basic dydx address structure check)",
													"pm.test(\"Address should be a valid dydx address format\", function () {",
													"    const jsonData = pm.response.json();",
													"    const dydxAddressPattern = /^dydx1[a-z0-9]{38}$/; // Basic regex for dydx address",
													"    ",
													"    pm.expect(jsonData.address).to.match(dydxAddressPattern, \"Invalid dydx address format\");",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/affiliates/address?referralCode={{referralCode}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"affiliates",
												"address"
											],
											"query": [
												{
													"key": "referralCode",
													"value": "{{referralCode}}"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "/affiliates/address invalid referralCode",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify response status code is 400 or 404",
													"pm.test(\"Response status code is 400 or 404 for invalid referral code\", function () {",
													"    pm.response.to.have.status(404)",
													"});",
													"",
													"// 2. Validate presence of 'errors' array",
													"pm.test(\"Response contains 'errors' array\", function () {",
													"    const jsonData = pm.response.json();",
													"    ",
													"    pm.expect(jsonData).to.have.property(\"errors\").that.is.an(\"array\").with.lengthOf.at.least(1);",
													"});",
													"",
													"// 3. Validate structure of error object",
													"pm.test(\"Each error object contains 'msg' property\", function () {",
													"    const jsonData = pm.response.json();",
													"    ",
													"    jsonData.errors.forEach(error => {",
													"        pm.expect(error).to.have.property(\"msg\").that.is.a(\"string\");",
													"    });",
													"});",
													"",
													"// 4. Ensure correct error message format",
													"pm.test(\"Error message correctly indicates referral code does not exist\", function () {",
													"    const jsonData = pm.response.json();",
													"    const expectedErrorMessage = `Referral code ${pm.environment.get(\"invalidReferralCode\")} does not exist`;",
													"",
													"    pm.expect(jsonData.errors[0].msg).to.eql(expectedErrorMessage);",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/affiliates/address?referralCode={{invalidReferralCode}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"affiliates",
												"address"
											],
											"query": [
												{
													"key": "referralCode",
													"value": "{{invalidReferralCode}}"
												}
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "snapshot",
							"item": [
								{
									"name": "/affiliates/snapshot valid",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify response status code is 200",
													"pm.test(\"Response status code is 200\", function () {",
													"    pm.response.to.have.status(200);",
													"});",
													"",
													"// 2. Validate response structure",
													"pm.test(\"Response contains 'affiliateList', 'currentOffset', and 'total'\", function () {",
													"    const jsonData = pm.response.json();",
													"",
													"    pm.expect(jsonData).to.be.an(\"object\");",
													"    pm.expect(jsonData).to.have.property(\"affiliateList\").that.is.an(\"array\");",
													"    pm.expect(jsonData).to.have.property(\"currentOffset\").that.is.a(\"number\");",
													"    pm.expect(jsonData).to.have.property(\"total\").that.is.a(\"number\");",
													"});",
													"",
													"// 3. Validate 'affiliateList' contains correct fields",
													"pm.test(\"Each affiliate object contains expected properties\", function () {",
													"    const jsonData = pm.response.json();",
													"    jsonData.affiliateList.forEach(affiliate => {",
													"        pm.expect(affiliate).to.have.property(\"affiliateAddress\").that.is.a(\"string\").and.not.be.empty;",
													"        pm.expect(affiliate).to.have.property(\"affiliateReferralCode\").that.is.a(\"string\").and.not.be.empty;",
													"        pm.expect(affiliate).to.have.property(\"affiliateEarnings\").that.is.a(\"number\");",
													"        pm.expect(affiliate).to.have.property(\"affiliateReferredTrades\").that.is.a(\"number\");",
													"        pm.expect(affiliate).to.have.property(\"affiliateTotalReferredFees\").that.is.a(\"number\");",
													"        pm.expect(affiliate).to.have.property(\"affiliateReferredUsers\").that.is.a(\"number\");",
													"        pm.expect(affiliate).to.have.property(\"affiliateReferredNetProtocolEarnings\").that.is.a(\"number\");",
													"        pm.expect(affiliate).to.have.property(\"affiliateReferredTotalVolume\").that.is.a(\"number\");",
													"        pm.expect(affiliate).to.have.property(\"affiliateReferredMakerFees\").that.is.a(\"number\");",
													"        pm.expect(affiliate).to.have.property(\"affiliateReferredTakerFees\").that.is.a(\"number\");",
													"        pm.expect(affiliate).to.have.property(\"affiliateReferredMakerRebates\").that.is.a(\"number\");",
													"    });",
													"});",
													"",
													"// 4. Validate address format for 'affiliateAddress'",
													"pm.test(\"Affiliate addresses should follow dydx address format\", function () {",
													"    const dydxAddressPattern = /^dydx1[a-z0-9]{38}$/;",
													"    const jsonData = pm.response.json();",
													"    jsonData.affiliateList.forEach(affiliate => {",
													"        pm.expect(affiliate.affiliateAddress).to.match(dydxAddressPattern, \"Invalid dydx address format\");",
													"    });",
													"});",
													"",
													"// 5. Validate numeric values are non-negative where applicable",
													"pm.test(\"Numeric fields should be valid and non-negative where applicable\", function () {",
													"    const jsonData = pm.response.json();",
													"    jsonData.affiliateList.forEach(affiliate => {",
													"        pm.expect(affiliate.affiliateEarnings).to.be.at.least(0);",
													"        pm.expect(affiliate.affiliateReferredTrades).to.be.at.least(0);",
													"        pm.expect(affiliate.affiliateTotalReferredFees).to.be.at.least(0);",
													"        pm.expect(affiliate.affiliateReferredUsers).to.be.at.least(0);",
													"        pm.expect(affiliate.affiliateReferredNetProtocolEarnings).to.be.at.least(0);",
													"        pm.expect(affiliate.affiliateReferredTotalVolume).to.be.at.least(0);",
													"        pm.expect(affiliate.affiliateReferredMakerFees).to.be.at.least(0);",
													"        pm.expect(affiliate.affiliateReferredTakerFees).to.be.at.least(0);",
													"        // 'affiliateReferredMakerRebates' can be negative, so it's not checked here",
													"    });",
													"});",
													"",
													"// 6. Validate pagination fields",
													"pm.test(\"Pagination fields should be correct\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData.currentOffset).to.be.a(\"number\").and.to.be.at.least(0);",
													"    pm.expect(jsonData.total).to.be.a(\"number\").and.to.be.at.least(0);",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/affiliates/snapshot?addressFilter={{dydxWithReferrals}}&offset=0&limit=10",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"affiliates",
												"snapshot"
											],
											"query": [
												{
													"key": "addressFilter",
													"value": "{{dydxWithReferrals}}"
												},
												{
													"key": "offset",
													"value": "0"
												},
												{
													"key": "limit",
													"value": "10"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "/affiliates/snapshot pagination limit 1",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify response status code is 200",
													"pm.test(\"Response status code is 200\", function () {",
													"    pm.response.to.have.status(200);",
													"});",
													"",
													"// 2. Validate response contains required fields",
													"pm.test(\"Response contains 'affiliateList', 'currentOffset', and 'total'\", function () {",
													"    const jsonData = pm.response.json();",
													"    ",
													"    pm.expect(jsonData).to.be.an(\"object\");",
													"    pm.expect(jsonData).to.have.property(\"affiliateList\").that.is.an(\"array\");",
													"    pm.expect(jsonData).to.have.property(\"currentOffset\").that.is.a(\"number\");",
													"    pm.expect(jsonData).to.have.property(\"total\").that.is.a(\"number\");",
													"});",
													"",
													"// 3. Ensure only one affiliate object is returned",
													"pm.test(\"Affiliate list should contain exactly 1 entry\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData.affiliateList.length).to.eql(1, \"Expected exactly 1 affiliate object\");",
													"});",
													"",
													"// 4. Validate affiliate object contains expected fields",
													"pm.test(\"Affiliate object contains required properties\", function () {",
													"    const jsonData = pm.response.json();",
													"    const affiliate = jsonData.affiliateList[0];",
													"",
													"    pm.expect(affiliate).to.have.property(\"affiliateAddress\").that.is.a(\"string\").and.not.be.empty;",
													"    pm.expect(affiliate).to.have.property(\"affiliateReferralCode\").that.is.a(\"string\").and.not.be.empty;",
													"    pm.expect(affiliate).to.have.property(\"affiliateEarnings\").that.is.a(\"number\");",
													"    pm.expect(affiliate).to.have.property(\"affiliateReferredTrades\").that.is.a(\"number\");",
													"    pm.expect(affiliate).to.have.property(\"affiliateTotalReferredFees\").that.is.a(\"number\");",
													"    pm.expect(affiliate).to.have.property(\"affiliateReferredUsers\").that.is.a(\"number\");",
													"    pm.expect(affiliate).to.have.property(\"affiliateReferredNetProtocolEarnings\").that.is.a(\"number\");",
													"    pm.expect(affiliate).to.have.property(\"affiliateReferredTotalVolume\").that.is.a(\"number\");",
													"    pm.expect(affiliate).to.have.property(\"affiliateReferredMakerFees\").that.is.a(\"number\");",
													"    pm.expect(affiliate).to.have.property(\"affiliateReferredTakerFees\").that.is.a(\"number\");",
													"    pm.expect(affiliate).to.have.property(\"affiliateReferredMakerRebates\").that.is.a(\"number\");",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/affiliates/snapshot?addressFilter[]={{dydxWithReferrals}}&addressFilter[]={{dydxWithReferrals2}}&offset=0&limit=1",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"affiliates",
												"snapshot"
											],
											"query": [
												{
													"key": "addressFilter[]",
													"value": "{{dydxWithReferrals}}"
												},
												{
													"key": "addressFilter[]",
													"value": "{{dydxWithReferrals2}}"
												},
												{
													"key": "offset",
													"value": "0"
												},
												{
													"key": "limit",
													"value": "1"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "/affiliates/snapshot pagination limit 0",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify response status code is 400 (Bad Request)",
													"pm.test(\"Response status code is 400 for invalid limit\", function () {",
													"    pm.response.to.have.status(400);",
													"});",
													"",
													"// 2. Validate response contains 'errors' array",
													"pm.test(\"Response contains 'errors' array\", function () {",
													"    const jsonData = pm.response.json();",
													"    ",
													"    pm.expect(jsonData).to.have.property(\"errors\").that.is.an(\"array\").with.lengthOf.at.least(1);",
													"});",
													"",
													"// 3. Validate error object structure",
													"pm.test(\"Each error object contains required properties\", function () {",
													"    const jsonData = pm.response.json();",
													"",
													"    jsonData.errors.forEach(error => {",
													"        pm.expect(error).to.have.property(\"value\").that.is.a(\"string\");",
													"        pm.expect(error).to.have.property(\"msg\").that.is.a(\"string\");",
													"        pm.expect(error).to.have.property(\"param\").that.is.a(\"string\");",
													"        pm.expect(error).to.have.property(\"location\").that.is.a(\"string\");",
													"    });",
													"});",
													"",
													"// 4. Validate the specific error message for 'limit=0'",
													"pm.test(\"Error message correctly indicates 'limit' must be a valid integer\", function () {",
													"    const jsonData = pm.response.json();",
													"    const expectedError = {",
													"        value: \"0\",",
													"        msg: \"limit must be a valid integer\",",
													"        param: \"limit\",",
													"        location: \"query\"",
													"    };",
													"",
													"    // Check if at least one error object matches expected structure",
													"    const matchingError = jsonData.errors.find(error =>",
													"        error.value === expectedError.value &&",
													"        error.msg === expectedError.msg &&",
													"        error.param === expectedError.param &&",
													"        error.location === expectedError.location",
													"    );",
													"",
													"    pm.expect(matchingError).to.be.an(\"object\", \"Expected error for invalid limit was not found\");",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/affiliates/snapshot?addressFilter[]={{dydxWithReferrals}}&addressFilter[]={{dydxWithReferrals2}}&offset=0&limit=0",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"affiliates",
												"snapshot"
											],
											"query": [
												{
													"key": "addressFilter[]",
													"value": "{{dydxWithReferrals}}"
												},
												{
													"key": "addressFilter[]",
													"value": "{{dydxWithReferrals2}}"
												},
												{
													"key": "offset",
													"value": "0"
												},
												{
													"key": "limit",
													"value": "0"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "/affiliates/snapshot pagination limit 2",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"Response status code is 200\", function () {",
													"    pm.response.to.have.status(200);",
													"});",
													"",
													"pm.test(\"Response contains 'affiliateList', 'currentOffset', and 'total'\", function () {",
													"    const jsonData = pm.response.json();",
													"    ",
													"    pm.expect(jsonData).to.be.an(\"object\");",
													"    pm.expect(jsonData).to.have.property(\"affiliateList\").that.is.an(\"array\");",
													"    pm.expect(jsonData).to.have.property(\"currentOffset\").that.is.a(\"number\");",
													"    pm.expect(jsonData).to.have.property(\"total\").that.is.a(\"number\");",
													"});",
													"",
													"pm.test(\"Affiliate list should contain 2 entries\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData.affiliateList.length).to.equal(2, \"Expected 2 affiliate objects\");",
													"});",
													"",
													"pm.test(\"Each affiliate object contains required properties\", function () {",
													"    const jsonData = pm.response.json();",
													"    ",
													"    jsonData.affiliateList.forEach(affiliate => {",
													"        pm.expect(affiliate.affiliateAddress).to.be.a(\"string\").and.not.be.empty;",
													"        pm.expect(affiliate.affiliateReferralCode).to.be.a(\"string\").and.not.be.empty;",
													"        pm.expect(affiliate.affiliateEarnings).to.be.a(\"number\");",
													"        pm.expect(affiliate.affiliateReferredTrades).to.be.a(\"number\");",
													"        pm.expect(affiliate.affiliateTotalReferredFees).to.be.a(\"number\");",
													"        pm.expect(affiliate.affiliateReferredUsers).to.be.a(\"number\");",
													"        pm.expect(affiliate.affiliateReferredNetProtocolEarnings).to.be.a(\"number\");",
													"        pm.expect(affiliate.affiliateReferredTotalVolume).to.be.a(\"number\");",
													"        pm.expect(affiliate.affiliateReferredMakerFees).to.be.a(\"number\");",
													"        pm.expect(affiliate.affiliateReferredTakerFees).to.be.a(\"number\");",
													"        pm.expect(affiliate.affiliateReferredMakerRebates).to.be.a(\"number\");",
													"    });",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/affiliates/snapshot?addressFilter[]={{dydxWithReferrals}}&addressFilter[]={{dydxWithReferrals2}}&offset=0&limit=3",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"affiliates",
												"snapshot"
											],
											"query": [
												{
													"key": "addressFilter[]",
													"value": "{{dydxWithReferrals}}"
												},
												{
													"key": "addressFilter[]",
													"value": "{{dydxWithReferrals2}}"
												},
												{
													"key": "offset",
													"value": "0"
												},
												{
													"key": "limit",
													"value": "3"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "/affiliates/snapshot invalid",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// 1. Verify response status code is 200 even for invalid address",
													"pm.test(\"Response status code is 200 for invalid dYdX address\", function () {",
													"    pm.response.to.have.status(200);",
													"});",
													"",
													"// 2. Validate response structure",
													"pm.test(\"Response contains 'affiliateList', 'currentOffset', and 'total'\", function () {",
													"    const jsonData = pm.response.json();",
													"    ",
													"    pm.expect(jsonData).to.be.an(\"object\");",
													"    pm.expect(jsonData).to.have.property(\"affiliateList\").that.is.an(\"array\");",
													"    pm.expect(jsonData).to.have.property(\"currentOffset\").that.is.a(\"number\");",
													"    pm.expect(jsonData).to.have.property(\"total\").that.is.a(\"number\");",
													"});",
													"",
													"// 3. Ensure 'affiliateList' is empty for invalid address",
													"pm.test(\"Affiliate list should be empty for invalid dYdX address\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData.affiliateList).to.be.an(\"array\").that.is.empty;",
													"});",
													"",
													"// 4. Validate pagination values",
													"pm.test(\"Pagination values should be correct for invalid address\", function () {",
													"    const jsonData = pm.response.json();",
													"    pm.expect(jsonData.currentOffset).to.equal(0);",
													"    pm.expect(jsonData.total).to.equal(0);",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/affiliates/snapshot?addressFilter[]={{invaliddYdXAddress}}&offset=0&limit=10",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"affiliates",
												"snapshot"
											],
											"query": [
												{
													"key": "addressFilter[]",
													"value": "{{invaliddYdXAddress}}"
												},
												{
													"key": "offset",
													"value": "0"
												},
												{
													"key": "limit",
													"value": "10"
												}
											]
										}
									},
									"response": []
								}
							]
						}
					]
				},
				{
					"name": "assetPositions",
					"item": []
				},
				{
					"name": "candles",
					"item": []
				},
				{
					"name": "compliance",
					"item": [
						{
							"name": "screen",
							"item": [
								{
									"name": "screen/",
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{indexerBaseUrl}}/compliance/screen/{{validdYdXAddress}}",
											"host": [
												"{{indexerBaseUrl}}"
											],
											"path": [
												"compliance",
												"screen",
												"{{validdYdXAddress}}"
											]
										}
									},
									"response": []
								}
							]
						}
					]
				},
				{
					"name": "fills",
					"item": []
				},
				{
					"name": "height",
					"item": []
				},
				{
					"name": "historicalBlockTradingRewards",
					"item": []
				},
				{
					"name": "historicalFunding",
					"item": []
				},
				{
					"name": "historical-pnl",
					"item": []
				},
				{
					"name": "historicalTradingRewardAggregations",
					"item": []
				},
				{
					"name": "orderbooks",
					"item": []
				},
				{
					"name": "orders",
					"item": []
				},
				{
					"name": "perpetualMarkets",
					"item": []
				},
				{
					"name": "perpetualPositions",
					"item": []
				},
				{
					"name": "trader",
					"item": []
				},
				{
					"name": "sparklines",
					"item": []
				},
				{
					"name": "time",
					"item": []
				},
				{
					"name": "trades",
					"item": []
				},
				{
					"name": "transfers",
					"item": []
				},
				{
					"name": "vault",
					"item": []
				}
			]
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					""
				]
			}
		}
	]
}