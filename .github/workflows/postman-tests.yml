name: Run Newman Tests (Self-Hosted with Direct Access - Testnet)

on:
  repository_dispatch:
    types: [run-tests]

jobs:
  run-tests:
    runs-on: self-hosted 
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4.2.2
        with:
          persist-credentials: true

      - name: Update Last Processed Upstream Run ID
        run: |
          echo "Updating .last_upstream_run_id.txt with ${{ github.event.client_payload.run_id }}"
          echo "${{ github.event.client_payload.run_id }}" > .last_upstream_run_id.txt
          
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          
          echo "Checking git status before stash:"
          git status --short

          echo "Stashing local changes..."
          git stash push -u -m "workflow_stash_for_run_id_update" || echo "No changes to stash or stash failed."
          
          echo "Pulling with rebase..."
          git pull --rebase
          
          echo "Attempting to pop stash..."
          if git rev-parse -q --verify refs/stash >/dev/null; then
            git stash pop || (
              echo "Warning: 'git stash pop' failed. Re-applying .last_upstream_run_id.txt manually."
              echo "${{ github.event.client_payload.run_id }}" > .last_upstream_run_id.txt
              git add .last_upstream_run_id.txt 
              git stash drop || echo "No stash to drop or already dropped."
            )
          else
            echo "No stash found to pop. Ensuring .last_upstream_run_id.txt content."
            echo "${{ github.event.client_payload.run_id }}" > .last_upstream_run_id.txt
            git add .last_upstream_run_id.txt
          fi
          
          echo "Committing .last_upstream_run_id.txt..."
          git commit -m "[skip ci] Update last processed upstream run id to ${{ github.event.client_payload.run_id }}" || echo "No changes to commit for last run ID."
          
          echo "Pushing changes..."
          git push
          
      - name: Run Newman Tests (Ultra-Simple Execution)
        id: newman # ID for conclusion checking
        run: |
          # The only command in this block is newman.
          # The script will exit with Newman's exit code.
          newman run postman/collection.json \
            -e postman/environment.testnet.json 
        # No NEWMAN_EXIT_CODE=$?
        # No echo "exit_code=..." >> $GITHUB_OUTPUT
        # No other echos after newman
        continue-on-error: true # We need this so the Slack step can run and interpret the result

      - name: Upload Test Results (JUnit XML)
        if: always()
        uses: actions/upload-artifact@v4.6.0
        with:
          name: postman-test-results
          path: results.xml
          if-no-files-found: warn

      - name: Upload HTML Report (Nice UI)
        if: always()
        uses: actions/upload-artifact@v4.6.0
        with:
          name: postman-html-report
          path: newman-report.html
          if-no-files-found: warn

      - name: Notify Slack Channel and Handle Overall Job Failure
        if: always() # Ensure this step always runs to determine final job status
        run: |
          NEWMAN_STEP_CONCLUSION="${{ steps.newman.conclusion }}" 
          # In the "Ultra-Simple Execution", steps.newman.outputs.exit_code will NOT be set.
          # We rely solely on steps.newman.conclusion.
          
          JOB_WAS_SUCCESSFUL_UP_TO_THIS_POINT="${{ success() }}" # True if all prior *required* steps passed.
                                                              # With continue-on-error on Newman, this will be true if steps before Newman passed.

          FINAL_MESSAGE=""
          ICON=":test_tube:" 
          COLOR="warning" 
          TITLE_TEXT="Newman Test Run (Testnet on Self-Hosted - No VPN)"
          MARK_JOB_AS_FAILED=false # This will be our flag to exit 1

          echo "Newman Step Conclusion: $NEWMAN_STEP_CONCLUSION"
          echo "Job was successful up to this point (before this Slack step): $JOB_WAS_SUCCESSFUL_UP_TO_THIS_POINT"

          if [ "$NEWMAN_STEP_CONCLUSION" == "success" ]; then
            # This means Newman exited with 0 (all its tests passed)
            FINAL_MESSAGE="All Newman tests passed successfully!"
            ICON=":white_check_mark:"
            COLOR="good"
            # MARK_JOB_AS_FAILED remains false
          elif [ "$NEWMAN_STEP_CONCLUSION" == "failure" ]; then
            # This means Newman exited non-zero (test failures) OR the script in the Newman step had an error.
            # For "Ultra-Simple Execution", it means Newman's tests failed.
            FINAL_MESSAGE="Newman tests encountered failures (Newman command exited non-zero)."
            ICON=":warning:" # Or :x: for hard red
            COLOR="danger" 
            MARK_JOB_AS_FAILED=true
          elif [ "$NEWMAN_STEP_CONCLUSION" == "skipped" ]; then
            FINAL_MESSAGE="Newman step was skipped (likely due to a failure in a previous required step)."
            ICON=":zzz:"
            COLOR="neutral"
            # If a previous *required* step failed, the job will already be marked as failure by GitHub.
            # We set MARK_JOB_AS_FAILED to true to reflect this.
            if ! $JOB_WAS_SUCCESSFUL_UP_TO_THIS_POINT; then
                MARK_JOB_AS_FAILED=true
            fi
          else # cancelled, etc.
            FINAL_MESSAGE="Newman step status: $NEWMAN_STEP_CONCLUSION. This might be due to job cancellation or an unknown issue."
            ICON=":grey_question:"
            COLOR="neutral"
            # If the job was already failing or was cancelled, reflect that.
            if ! $JOB_WAS_SUCCESSFUL_UP_TO_THIS_POINT || [ "$NEWMAN_STEP_CONCLUSION" == "cancelled" ]; then
                MARK_JOB_AS_FAILED=true
            fi
          fi
          
          # If the job overall had a failure in a step *before* the Newman step (which has continue-on-error),
          # ensure we still mark it as failed. The `success()` context function reflects this.
          if ! $JOB_WAS_SUCCESSFUL_UP_TO_THIS_POINT; then
             # Only override message if not already a Newman step failure message
             if [ "$NEWMAN_STEP_CONCLUSION" != "failure" ]; then 
                FINAL_MESSAGE="A previous step in the job failed. $FINAL_MESSAGE"
             fi
             ICON=":x:" 
             COLOR="danger"
             MARK_JOB_AS_FAILED=true
          fi

          TEXT_MESSAGE="$FINAL_MESSAGE Workflow: <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|${{ github.workflow }} Run #${{ github.run_number }}>"
          PAYLOAD=$(jq -n \
            --arg channel "indexer-api-testing" \
            --arg username "GitHub Actions" \
            --arg icon_emoji "$ICON" \
            --arg color "$COLOR" \
            --arg title "$TITLE_TEXT" \
            --arg text "$TEXT_MESSAGE" \
            '{channel: $channel, username: $username, icon_emoji: $icon_emoji, attachments: [{color: $color, title: $title, text: $text}]}')
          
          echo "Payload for Slack: $PAYLOAD"
          curl -X POST -H "Content-type: application/json" --data "$PAYLOAD" "${{ secrets.SLACK_WEBHOOK_URL }}"

          if [ "$MARK_JOB_AS_FAILED" = true ]; then
            echo "Final determination: Marking job as FAILED based on step outcomes."
            exit 1
          else
            echo "Final determination: Job considered SUCCESSFUL by this script."
          fi