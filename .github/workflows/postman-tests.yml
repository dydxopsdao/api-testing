name: Run Newman Tests (Self-Hosted with Direct Access - Testnet)

on:
  repository_dispatch:
    types: [run-tests]

jobs:
  run-tests:
    runs-on: self-hosted 
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4.2.2
        with:
          persist-credentials: true

      - name: Update Last Processed Upstream Run ID
        run: |
          echo "Updating .last_upstream_run_id.txt with ${{ github.event.client_payload.run_id }}"
          echo "${{ github.event.client_payload.run_id }}" > .last_upstream_run_id.txt
          
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          
          echo "Checking git status before stash:"
          git status --short

          echo "Stashing local changes..."
          git stash push -u -m "workflow_stash_for_run_id_update" || echo "No changes to stash or stash failed."
          
          echo "Pulling with rebase..."
          git pull --rebase
          
          echo "Attempting to pop stash..."
          if git rev-parse -q --verify refs/stash >/dev/null; then
            git stash pop || (
              echo "Warning: 'git stash pop' failed. Re-applying .last_upstream_run_id.txt manually."
              echo "${{ github.event.client_payload.run_id }}" > .last_upstream_run_id.txt
              git add .last_upstream_run_id.txt 
              git stash drop || echo "No stash to drop or already dropped."
            )
          else
            echo "No stash found to pop. Ensuring .last_upstream_run_id.txt content."
            echo "${{ github.event.client_payload.run_id }}" > .last_upstream_run_id.txt
            git add .last_upstream_run_id.txt
          fi
          
          echo "Committing .last_upstream_run_id.txt..."
          git commit -m "[skip ci] Update last processed upstream run id to ${{ github.event.client_payload.run_id }}" || echo "No changes to commit for last run ID."
          
          echo "Pushing changes..."
          git push
          
      - name: Run Newman Tests (Ultra-Simple Execution)
        id: newman # ID for conclusion checking
        run: |
          # The only command in this block is newman.
          # The script will exit with Newman's exit code.
          newman run postman/collection.json \
            -e postman/environment.testnet.json 
        # No NEWMAN_EXIT_CODE=$?
        # No echo "exit_code=..." >> $GITHUB_OUTPUT
        # No other echos after newman
        continue-on-error: true # We need this so the Slack step can run and interpret the result

      - name: Upload Test Results (JUnit XML)
        if: always()
        uses: actions/upload-artifact@v4.6.0
        with:
          name: postman-test-results
          path: results.xml
          if-no-files-found: warn

      - name: Upload HTML Report (Nice UI)
        if: always()
        uses: actions/upload-artifact@v4.6.0
        with:
          name: postman-html-report
          path: newman-report.html
          if-no-files-found: warn

      - name: Notify Slack Channel and Handle Overall Job Failure
        if: always() # This step will always run
        run: |
          NEWMAN_STEP_CONCLUSION="${{ steps.newman.conclusion }}" # success, failure, skipped, cancelled
          
          # Get the boolean success status from GitHub Actions context
          # It will be the string "True" or "False"
          OVERALL_JOB_SUCCESS_SO_FAR_RAW="${{ success() }}" 
          
          FINAL_MESSAGE=""
          ICON=":test_tube:" 
          COLOR="warning" 
          TITLE_TEXT="Newman Test Run (Testnet on Self-Hosted - No VPN)"
          MARK_JOB_AS_FAILED_FLAG=false # Our flag to exit 1

          echo "Newman Step Conclusion: $NEWMAN_STEP_CONCLUSION"
          echo "Overall Job Success So Far (Raw from GitHub context): $OVERALL_JOB_SUCCESS_SO_FAR_RAW"

          # Determine status based on Newman step
          if [ "$NEWMAN_STEP_CONCLUSION" == "success" ]; then
            FINAL_MESSAGE="All Newman tests passed successfully!"
            ICON=":white_check_mark:"
            COLOR="good"
            # MARK_JOB_AS_FAILED_FLAG remains false if OVERALL_JOB_SUCCESS_SO_FAR_RAW is "True"
            if [ "$OVERALL_JOB_SUCCESS_SO_FAR_RAW" == "False" ]; then
              MARK_JOB_AS_FAILED_FLAG=true # A previous required step failed
            fi
          elif [ "$NEWMAN_STEP_CONCLUSION" == "failure" ]; then
            FINAL_MESSAGE="Newman tests encountered failures (Newman command exited non-zero)."
            ICON=":warning:"
            COLOR="danger" 
            MARK_JOB_AS_FAILED_FLAG=true # Newman failure means job fails
          elif [ "$NEWMAN_STEP_CONCLUSION" == "skipped" ]; then
            FINAL_MESSAGE="Newman step was skipped." # Usually due to a prior *required* step failing
            ICON=":zzz:"
            COLOR="neutral"
            # If a previous required step failed, OVERALL_JOB_SUCCESS_SO_FAR_RAW will be "False"
            if [ "$OVERALL_JOB_SUCCESS_SO_FAR_RAW" == "False" ]; then
                MARK_JOB_AS_FAILED_FLAG=true
            fi
          else # cancelled, etc.
            FINAL_MESSAGE="Newman step status: $NEWMAN_STEP_CONCLUSION. This might be due to job cancellation or an unknown issue."
            ICON=":grey_question:"
            COLOR="neutral"
            # If the job was already failing/cancelled, mark it as failed.
            if [ "$OVERALL_JOB_SUCCESS_SO_FAR_RAW" == "False" ] || [ "$NEWMAN_STEP_CONCLUSION" == "cancelled" ]; then
                MARK_JOB_AS_FAILED_FLAG=true
            fi
          fi
          
          # Check if the job failed *before* the Newman step (if Newman didn't already cause a failure mark)
          # The newman step has continue-on-error, so success() reflects steps *before* it mainly.
          if [ "$OVERALL_JOB_SUCCESS_SO_FAR_RAW" == "False" ] && [ "$MARK_JOB_AS_FAILED_FLAG" = false ]; then
             FINAL_MESSAGE="A previous required step in the job failed. $FINAL_MESSAGE"
             ICON=":x:" 
             COLOR="danger"
             MARK_JOB_AS_FAILED_FLAG=true
          elif [ "$OVERALL_JOB_SUCCESS_SO_FAR_RAW" == "False" ] && [ "$NEWMAN_STEP_CONCLUSION" != "failure" ]; then
             # If a previous step failed, and Newman didn't explicitly fail but also didn't succeed (e.g. skipped)
             # Ensure the message reflects the prior failure more prominently.
             FINAL_MESSAGE="A previous required step in the job failed. Current Newman status: $NEWMAN_STEP_CONCLUSION."
             ICON=":x:" 
             COLOR="danger"
             MARK_JOB_AS_FAILED_FLAG=true
          fi

          TEXT_MESSAGE="$FINAL_MESSAGE Workflow: <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|${{ github.workflow }} Run #${{ github.run_number }}>"
          PAYLOAD=$(jq -n \
            --arg channel "indexer-api-testing" \
            --arg username "GitHub Actions" \
            --arg icon_emoji "$ICON" \
            --arg color "$COLOR" \
            --arg title "$TITLE_TEXT" \
            --arg text "$TEXT_MESSAGE" \
            '{channel: $channel, username: $username, icon_emoji: $icon_emoji, attachments: [{color: $color, title: $title, text: $text}]}')
          
          echo "Payload for Slack: $PAYLOAD"
          curl -X POST -H "Content-type: application/json" --data "$PAYLOAD" "${{ secrets.SLACK_WEBHOOK_URL }}"

          if [ "$MARK_JOB_AS_FAILED_FLAG" = true ]; then
            echo "Final determination: Marking job as FAILED based on step outcomes."
            exit 1
          else
            echo "Final determination: Job considered SUCCESSFUL by this script."
          fi